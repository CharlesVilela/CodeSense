{
  "metadata": {
    "title": "Effective Go",
    "url": "https://go.dev/doc/effective_go",
    "technology": "go",
    "category": "programming_languages",
    "english_level": "B1",
    "professional_context": "development",
    "content_type": "technical_documentation",
    "last_updated": "1761765727.0046048"
  },
  "content": "Documentation\nEffective Go\nEffective Go\nIntroduction\nGo is a new language.  Although it borrows ideas from\nexisting languages,\nit has unusual properties that make effective Go programs\ndifferent in character from programs written in its relatives.\nA straightforward translation of a C++ or Java program into Go\nis unlikely to produce a satisfactory result—Java programs\nare written in Java, not Go.\nOn the other hand, thinking about the problem from a Go\nperspective could produce a successful but quite different\nIn other words,\nto write Go well, it's important to understand its properties\nand idioms.\nIt's also important to know the established conventions for\nprogramming in Go, such as naming, formatting, program\nconstruction, and so on, so that programs you write\nwill be easy for other Go programmers to understand.\nThis document gives tips for writing clear, idiomatic Go code.\nIt augments the\nlanguage specification\nHow to Write Go Code\nall of which you\nshould read first.\nNote added January, 2022:\nThis document was written for Go's\nrelease in 2009, and has not been updated significantly since.\nAlthough it is a good guide to understand how to use the language\nitself, thanks to the stability of the language, it says little\nabout the libraries and nothing about significant changes to the\nGo ecosystem since it was written, such as the build system, testing,\nmodules, and polymorphism.\nThere are no plans to update it, as so much has happened and a large\nand growing set of documents, blogs, and books do a fine job of\ndescribing modern Go usage.\nEffective Go continues to be useful, but the reader should\nunderstand it is far from a complete guide.\nfor context.\nGo package sources\nare intended to serve not\nonly as the core library but also as examples of how to\nuse the language.\nMoreover, many of the packages contain working, self-contained\nexecutable examples you can run directly from the\nweb site, such as\nnecessary, click on the word \"Example\" to open it up).\nIf you have a question about how to approach a problem or how something\nmight be implemented, the documentation, code and examples in the\nlibrary can provide answers, ideas and\nbackground.\nFormatting issues are the most contentious\nbut the least consequential.\nPeople can adapt to different formatting styles\nbut it's better if they don't have to, and\nless time is devoted to the topic\nif everyone adheres to the same style.\nThe problem is how to approach this Utopia without a long\nprescriptive style guide.\nWith Go we take an unusual\napproach and let the machine\ntake care of most formatting issues.\n(also available as\noperates at the package level rather than source file level)\nreads a Go program\nand emits the source in a standard style of indentation\nand vertical alignment, retaining and if necessary\nreformatting comments.\nIf you want to know how to handle some new layout\nsituation, run\n; if the answer doesn't\nseem right, rearrange your program (or file a bug about\ndon't work around it.\nAs an example, there's no need to spend time lining up\nthe comments on the fields of a structure.\nwill do that for you.  Given the\ndeclaration\ntype T struct {\nname string // name of the object\nvalue int // its value\nwill line up the columns:\ntype T struct {\nname    string // name of the object\nvalue   int    // its value\nAll Go code in the standard packages has been formatted with\nSome formatting details remain.  Very briefly:\nIndentation\nWe use tabs for indentation and\nemits them by default.\nUse spaces only if you must.\nLine length\nGo has no line length limit.  Don't worry about overflowing a punched card.\nIf a line feels too long, wrap it and indent with an extra tab.\nParentheses\nGo needs fewer parentheses than C and Java: control structures (\n) do not have parentheses in\ntheir syntax.\nAlso, the operator precedence hierarchy is shorter and clearer, so\nx<<8 + y<<16\nmeans what the spacing implies, unlike in the other languages.\nGo provides C-style\nblock comments\nand C++-style\nline comments.\nLine comments are the norm;\nblock comments appear mostly as package comments, but\nare useful within an expression or to disable large swaths of code.\nComments that appear before top-level declarations, with no intervening newlines,\nare considered to document the declaration itself.\nThese “doc comments” are the primary documentation for a given Go package or command.\nFor more about doc comments, see “\nGo Doc Comments\nNames are as important in Go as in any other language.\nThey even have semantic effect:\nthe visibility of a name outside a package is determined by whether its\nfirst character is upper case.\nIt's therefore worth spending a little time talking about naming conventions\nin Go programs.\nPackage names\nWhen a package is imported, the package name becomes an accessor for the\ncontents.  After\nimport \"bytes\"\nthe importing package can talk about\nbytes.Buffer\nhelpful if everyone using the package can use the same name to refer to\nits contents, which implies that the package name should be good:\nshort, concise, evocative.  By convention, packages are given\nlower case, single-word names; there should be no need for underscores\nor mixedCaps.\nErr on the side of brevity, since everyone using your\npackage will be typing that name.\nAnd don't worry about collisions\nThe package name is only the default name for imports; it need not be unique\nacross all source code, and in the rare case of a collision the\nimporting package can choose a different name to use locally.\nIn any case, confusion is rare because the file name in the import\ndetermines just which package is being used.\nAnother convention is that the package name is the base name of\nits source directory;\nthe package in\nsrc/encoding/base64\nis imported as\n\"encoding/base64\"\nbut has name\nencoding_base64\nencodingBase64\nThe importer of a package will use the name to refer to its contents,\nso exported names in the package can use that fact\nto avoid repetition.\n(Don't use the\nnotation, which can simplify\ntests that must run outside the package they are testing, but should otherwise be avoided.)\nFor instance, the buffered reader type in the\npackage is called\n, because users see it as\nbufio.Reader\nwhich is a clear, concise name.\nbecause imported entities are always addressed with their package name,\nbufio.Reader\ndoes not conflict with\nSimilarly, the function to make new instances of\nis the definition of a\nconstructor\nin Go—would\nnormally be called\n, but since\nis the only type exported by the package, and since the\npackage is called\n, it's called just\nwhich clients of the package see as\nUse the package structure to help you choose good names.\nAnother short example is\nonce.Do(setup)\nreads well and would not be improved by\nonce.DoOrWaitUntilDone(setup)\nLong names don't automatically make things more readable.\nA helpful doc comment can often be more valuable than an extra long name.\nGo doesn't provide automatic support for getters and setters.\nThere's nothing wrong with providing getters and setters yourself,\nand it's often appropriate to do so, but it's neither idiomatic nor necessary\ninto the getter's name.  If you have a field called\n(lower case, unexported), the getter method should be\n(upper case, exported), not\nThe use of upper-case names for export provides the hook to discriminate\nthe field from the method.\nA setter function, if needed, will likely be called\nBoth names read well in practice:\nowner := obj.Owner()\nif owner != user {\nobj.SetOwner(user)\nInterface names\nBy convention, one-method interfaces are named by\nthe method name plus an -er suffix or similar modification\nto construct an agent noun:\nCloseNotifier\nThere are a number of such names and it's productive to honor them and the function\nnames they capture.\nand so on have\ncanonical signatures and meanings.  To avoid confusion,\ndon't give your method one of those names unless it\nhas the same signature and meaning.\nConversely, if your type implements a method with the\nsame meaning as a method on a well-known type,\ngive it the same name and signature;\ncall your string-converter method\nFinally, the convention in Go is to use\nrather than underscores to write\nmultiword names.\nLike C, Go's formal grammar uses semicolons to terminate statements,\nbut unlike in C, those semicolons do not appear in the source.\nInstead the lexer uses a simple rule to insert semicolons automatically\nas it scans, so the input text is mostly free of them.\nThe rule is this. If the last token before a newline is an identifier\n(which includes words like\na basic literal such as a number or string constant, or one of the\nbreak continue fallthrough return ++ -- ) }\nthe lexer always inserts a semicolon after the token.\nThis could be summarized as, “if the newline comes\nafter a token that could end a statement, insert a semicolon”.\nA semicolon can also be omitted immediately before a closing brace,\nso a statement such as\ngo func() { for { dst <- <-src } }()\nneeds no semicolons.\nIdiomatic Go programs have semicolons only in places such as\nloop clauses, to separate the initializer, condition, and\ncontinuation elements.  They are also necessary to separate multiple\nstatements on a line, should you write code that way.\nOne consequence of the semicolon insertion rules\nis that you cannot put the opening brace of a\ncontrol structure (\n) on the next line.  If you do, a semicolon\nwill be inserted before the brace, which could cause unwanted\neffects.  Write them like this\nif i < f() {\nnot like this\nif i < f()  // wrong!\n{           // wrong!\nControl structures\nThe control structures of Go are related to those of C but differ\nin important ways.\nThere is no\nloop, only a\nslightly generalized\nis more flexible;\naccept an optional\ninitialization statement like that of\ntake an optional label to identify what to break or continue;\nand there are new control structures including a type switch and a\nmultiway communications multiplexer,\nThe syntax is also slightly different:\nthere are no parentheses\nand the bodies must always be brace-delimited.\nIn Go a simple\nlooks like this:\nMandatory braces encourage writing simple\non multiple lines.  It's good style to do so anyway,\nespecially when the body contains a control statement such as a\naccept an initialization\nstatement, it's common to see one used to set up a local variable.\nif err := file.Chmod(0664); err != nil {\nlog.Print(err)\nIn the Go libraries, you'll find that\nstatement doesn't flow into the next statement—that is,\nthe body ends in\n—the unnecessary\nis omitted.\nf, err := os.Open(name)\nif err != nil {\ncodeUsing(f)\nThis is an example of a common situation where code must guard against a\nsequence of error conditions.  The code reads well if the\nsuccessful flow of control runs down the page, eliminating error cases\nas they arise.  Since error cases tend to end in\nstatements, the resulting code needs no\nstatements.\nRedeclaration and reassignment\nAn aside: The last example in the previous section demonstrates a detail of how the\nshort declaration form works.\nThe declaration that calls\nf, err := os.Open(name)\nThis statement declares two variables,\nA few lines later, the call to\nd, err := f.Stat()\nwhich looks as if it declares\nNotice, though, that\nappears in both statements.\nThis duplication is legal:\nis declared by the first statement,\nre-assigned\nin the second.\nThis means that the call to\nuses the existing\nvariable declared above, and just gives it a new value.\ndeclaration a variable\nmay appear even\nif it has already been declared, provided:\nthis declaration is in the same scope as the existing declaration of\nis already declared in an outer scope, the declaration will create a new variable §),\nthe corresponding value in the initialization is assignable to\nthere is at least one other variable that is created by the declaration.\nThis unusual property is pure pragmatism,\nmaking it easy to use a single\nvalue, for example,\nYou'll see it used often.\n§ It's worth noting here that in Go the scope of function parameters and return values\nis the same as the function body, even though they appear lexically outside the braces\nthat enclose the body.\nloop is similar to—but not the same as—C's.\nand there is no\nThere are three forms, only one of which has semicolons.\nShort declarations make it easy to declare the index variable right in the loop.\nfor i := 0; i < 10; i++ {\nIf you're looping over an array, slice, string, or map,\nor reading from a channel, a\nmanage the loop.\nfor key, value := range oldMap {\nnewMap[key] = value\nIf you only need the first item in the range (the key or index), drop the second:\nfor key := range m {\nif key.expired() {\ndelete(m, key)\nIf you only need the second item in the range (the value), use the\nblank identifier\n, an underscore, to discard the first:\nfor _, value := range array {\nsum += value\nThe blank identifier has many uses, as described in\na later section\nFor strings, the\ndoes more work for you, breaking out individual\nUnicode code points by parsing the UTF-8.\nErroneous encodings consume one byte and produce the\nreplacement rune U+FFFD.\n(The name (with associated builtin type)\nis Go terminology for a\nsingle Unicode code point.\nthe language specification\nfor details.)\nFinally, Go has no comma operator and\nare statements not expressions.\nThus if you want to run multiple variables in a\nyou should use parallel assignment (although that precludes\nfor i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {\na[i], a[j] = a[j], a[i]\nis more general than C's.\nThe expressions need not be constants or even integers,\nthe cases are evaluated top to bottom until a match is found,\nhas no expression it switches on\nIt's therefore possible—and idiomatic—to write an\nThere is no automatic fall through, but cases can be presented\nin comma-separated lists.\nAlthough they are not nearly as common in Go as some other C-like\nstatements can be used to terminate\nSometimes, though, it's necessary to break out of a surrounding loop,\nnot the switch, and in Go that can be accomplished by putting a label\non the loop and \"breaking\" to that label.\nThis example shows both uses.\nOf course, the\nstatement also accepts an optional label\nbut it applies only to loops.\nTo close this section, here's a comparison routine for byte slices that uses two\nstatements:\nType switch\nA switch can also be used to discover the dynamic type of an interface\nvariable.  Such a\ntype switch\nuses the syntax of a type\nassertion with the keyword\ninside the parentheses.\nIf the switch declares a variable in the expression, the variable will\nhave the corresponding type in each clause.\nIt's also idiomatic to reuse the name in such cases, in effect declaring\na new variable with the same name but a different type in each case.\nMultiple return values\nOne of Go's unusual features is that functions and methods\ncan return multiple values.  This form can be used to\nimprove on a couple of clumsy idioms in C programs: in-band\nerror returns such as\nand modifying an argument passed by address.\nIn C, a write error is signaled by a negative count with the\nerror code secreted away in a volatile location.\ncan return a count\nan error: “Yes, you wrote some\nbytes but not all of them because you filled the device”.\nThe signature of the\nmethod on files from\nfunc (file *File) Write(b []byte) (n int, err error)\nand as the documentation says, it returns the number of bytes\nwritten and a non-nil\nThis is a common style; see the section on error handling for more examples.\nA similar approach obviates the need to pass a pointer to a return\nvalue to simulate a reference parameter.\nHere's a simple-minded function to\ngrab a number from a position in a byte slice, returning the number\nand the next position.\nYou could use it to scan the numbers in an input slice\nfor i := 0; i < len(b); {\nx, i = nextInt(b, i)\nfmt.Println(x)\nNamed result parameters\nThe return or result \"parameters\" of a Go function can be given names and\nused as regular variables, just like the incoming parameters.\nWhen named, they are initialized to the zero values for their types when\nthe function begins; if the function executes a\nwith no arguments, the current values of the result parameters are\nused as the returned values.\nThe names are not mandatory but they can make code shorter and clearer:\nthey're documentation.\nIf we name the results of\nobvious which returned\nfunc nextInt(b []byte, pos int) (value, nextPos int) {\nBecause named results are initialized and tied to an unadorned return, they can simplify\nas well as clarify.  Here's a version\nio.ReadFull\nthat uses them well:\nstatement schedules a function call (the\nfunction) to be run immediately before the function\nexecuting the\nreturns.  It's an unusual but\neffective way to deal with situations such as resources that must be\nreleased regardless of which path a function takes to return.  The\ncanonical examples are unlocking a mutex or closing a file.\nDeferring a call to a function such as\nhas two advantages.  First, it\nguarantees that you will never forget to close the file, a mistake\nthat's easy to make if you later edit the function to add a new return\npath.  Second, it means that the close sits near the open,\nwhich is much clearer than placing it at the end of the function.\nThe arguments to the deferred function (which include the receiver if\nthe function is a method) are evaluated when the\nexecutes, not when the\nexecutes.  Besides avoiding worries\nabout variables changing values as the function executes, this means\nthat a single deferred call site can defer multiple function\nexecutions.  Here's a silly example.\nfor i := 0; i < 5; i++ {\ndefer fmt.Printf(\"%d \", i)\nDeferred functions are executed in LIFO order, so this code will cause\nto be printed when the function returns.  A\nmore plausible example is a simple way to trace function execution\nthrough the program.  We could write a couple of simple tracing\nroutines like this:\nWe can do better by exploiting the fact that arguments to deferred\nfunctions are evaluated when the\nexecutes.  The\ntracing routine can set up the argument to the untracing routine.\nThis example:\nentering: b\nentering: a\nFor programmers accustomed to block-level resource management from\nother languages,\nmay seem peculiar, but its most\ninteresting and powerful applications come precisely from the fact\nthat it's not block-based but function-based.  In the section on\nwe'll see another\nexample of its possibilities.\nAllocation with\nGo has two allocation primitives, the built-in functions\nThey do different things and apply to different types, which can be confusing,\nbut the rules are simple.\nLet's talk about\nIt's a built-in function that allocates memory, but unlike its namesakes\nin some other languages it does not\nthe memory,\nallocates zeroed storage for a new item of type\nand returns its address, a value of type\nIn Go terminology, it returns a pointer to a newly allocated zero value of type\nSince the memory returned by\nis zeroed, it's helpful to arrange\nwhen designing your data structures that the\nzero value of each type can be used without further initialization.  This means a user of\nthe data structure can create one with\nand get right to\nFor example, the documentation for\nbytes.Buffer\nstates that\n\"the zero value for\nis an empty buffer ready to use.\"\nhave an explicit constructor or\nInstead, the zero value for a\nis defined to be an unlocked mutex.\nThe zero-value-is-useful property works transitively. Consider this type declaration.\ntype SyncedBuffer struct {\nlock    sync.Mutex\nbuffer  bytes.Buffer\nValues of type\nSyncedBuffer\nare also ready to use immediately upon allocation\nor just declaration.  In the next snippet, both\ncorrectly without further arrangement.\np := new(SyncedBuffer)  // type *SyncedBuffer\nvar v SyncedBuffer      // type  SyncedBuffer\nConstructors and composite literals\nSometimes the zero value isn't good enough and an initializing\nconstructor is necessary, as in this example derived from\nThere's a lot of boilerplate in there.  We can simplify it\ncomposite literal\nan expression that creates a\nnew instance each time it is evaluated.\nNote that, unlike in C, it's perfectly OK to return the address of a local variable;\nthe storage associated with the variable survives after the function\nIn fact, taking the address of a composite literal\nallocates a fresh instance each time it is evaluated,\nso we can combine these last two lines.\nreturn &File{fd, name, nil, 0}\nThe fields of a composite literal are laid out in order and must all be present.\nHowever, by labeling the elements explicitly as\npairs, the initializers can appear in any\norder, with the missing ones left as their respective zero values.  Thus we could say\nreturn &File{fd: fd, name: name}\nAs a limiting case, if a composite literal contains no fields at all, it creates\na zero value for the type.  The expressions\nare equivalent.\nComposite literals can also be created for arrays, slices, and maps,\nwith the field labels being indices or map keys as appropriate.\nIn these examples, the initializations work regardless of the values of\n, as long as they are distinct.\nAllocation with\nBack to allocation.\nThe built-in function\na purpose different from\nIt creates slices, maps, and channels only, and it returns an\ninitialized\nvalue of type\nThe reason for the distinction\nis that these three types represent, under the covers, references to data structures that\nmust be initialized before use.\nA slice, for example, is a three-item descriptor\ncontaining a pointer to the data (inside an array), the length, and the\ncapacity, and until those items are initialized, the slice is\nFor slices, maps, and channels,\ninitializes the internal data structure and prepares\nthe value for use.\nFor instance,\nmake([]int, 10, 100)\nallocates an array of 100 ints and then creates a slice\nstructure with length 10 and a capacity of 100 pointing at the first\n10 elements of the array.\n(When making a slice, the capacity can be omitted; see the section on slices\nfor more information.)\nIn contrast,\nreturns a pointer to a newly allocated, zeroed slice\nstructure, that is, a pointer to a\nslice value.\nThese examples illustrate the difference between\nRemember that\napplies only to maps, slices and channels\nand does not return a pointer.\nTo obtain an explicit pointer allocate with\nor take the address\nof a variable explicitly.\nArrays are useful when planning the detailed layout of memory and sometimes\ncan help avoid allocation, but primarily\nthey are a building block for slices, the subject of the next section.\nTo lay the foundation for that topic, here are a few words about arrays.\nThere are major differences between the ways arrays work in Go and C.\nArrays are values. Assigning one array to another copies all the elements.\nIn particular, if you pass an array to a function, it\nwill receive a\nof the array, not a pointer to it.\nThe size of an array is part of its type.  The types\nare distinct.\nThe value property can be useful but also expensive; if you want C-like behavior and efficiency,\nyou can pass a pointer to the array.\nBut even this style isn't idiomatic Go.\nUse slices instead.\nSlices wrap arrays to give a more general, powerful, and convenient\ninterface to sequences of data.  Except for items with explicit\ndimension such as transformation matrices, most array programming in\nGo is done with slices rather than simple arrays.\nSlices hold references to an underlying array, and if you assign one\nslice to another, both refer to the same array.\nIf a function takes a slice argument, changes it makes to\nthe elements of the slice will be visible to the caller, analogous to\npassing a pointer to the underlying array.  A\nfunction can therefore accept a slice argument rather than a pointer\nand a count; the length within the slice sets an upper\nlimit of how much data to read.  Here is the signature of the\nmethod of the\ntype in package\nfunc (f *File) Read(buf []byte) (n int, err error)\nThe method returns the number of bytes read and an error value, if\nTo read into the first 32 bytes of a larger buffer\n(here used as a verb) the buffer.\nn, err := f.Read(buf[0:32])\nSuch slicing is common and efficient.  In fact, leaving efficiency aside for\nthe moment, the following snippet would also read the first 32 bytes of the buffer.\nThe length of a slice may be changed as long as it still fits within\nthe limits of the underlying array; just assign it to a slice of\nitself.  The\nof a slice, accessible by the built-in\n, reports the maximum length the slice may\nassume.  Here is a function to append data to a slice.  If the data\nexceeds the capacity, the slice is reallocated.  The\nresulting slice is returned.  The function uses the fact that\nare legal when applied to the\nslice, and return 0.\nWe must return the slice afterwards because, although\ncan modify the elements of\n, the slice itself (the run-time data\nstructure holding the pointer, length, and capacity) is passed by value.\nThe idea of appending to a slice is so useful it's captured by the\nbuilt-in function.  To understand that function's\ndesign, though, we need a little more information, so we'll return\nto it later.\nTwo-dimensional slices\nGo's arrays and slices are one-dimensional.\nTo create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays\nor slice-of-slices, like this:\nBecause slices are variable-length, it is possible to have each inner\nslice be a different length.\nThat can be a common situation, as in our\nLinesOfText\nexample: each line has an independent length.\nSometimes it's necessary to allocate a 2D slice, a situation that can arise when\nprocessing scan lines of pixels, for instance.\nThere are two ways to achieve this.\nOne is to allocate each slice independently; the other\nis to allocate a single array and point the individual slices into it.\nWhich to use depends on your application.\nIf the slices might grow or shrink, they should be allocated independently\nto avoid overwriting the next line; if not, it can be more efficient to construct\nthe object with a single allocation.\nFor reference, here are sketches of the two methods.\nFirst, a line at a time:\nAnd now as one allocation, sliced into lines:\nMaps are a convenient and powerful built-in data structure that associate\nvalues of one type (the\n) with values of another type\nThe key can be of any type for which the equality operator is defined,\nsuch as integers,\nfloating point and complex numbers,\nstrings, pointers, interfaces (as long as the dynamic type\nsupports equality), structs and arrays.\nSlices cannot be used as map keys,\nbecause equality is not defined on them.\nLike slices, maps hold references to an underlying data structure.\nIf you pass a map to a function\nthat changes the contents of the map, the changes will be visible\nin the caller.\nMaps can be constructed using the usual composite literal syntax\nwith colon-separated key-value pairs,\nso it's easy to build them during initialization.\nAssigning and fetching map values looks syntactically just like\ndoing the same for arrays and slices except that the index doesn't\nneed to be an integer.\noffset := timeZone[\"EST\"]\nAn attempt to fetch a map value with a key that\nis not present in the map will return the zero value for the type\nof the entries\nin the map.  For instance, if the map contains integers, looking\nup a non-existent key will return\nA set can be implemented as a map with value type\nSet the map entry to\nto put the value in the set, and then\ntest it by simple indexing.\nSometimes you need to distinguish a missing entry from\na zero value.  Is there an entry for\nor is that 0 because it's not in the map at all?\nYou can discriminate with a form of multiple assignment.\nvar seconds int\nvar ok bool\nseconds, ok = timeZone[tz]\nFor obvious reasons this is called the “comma ok” idiom.\nIn this example, if\nis present,\nwill be set appropriately and\nwill be true; if not,\nwill be set to zero and\nHere's a function that puts it together with a nice error report:\nTo test for presence in the map without worrying about the actual value,\nyou can use the\nblank identifier\nin place of the usual variable for the value.\n_, present := timeZone[tz]\nTo delete a map entry, use the\nbuilt-in function, whose arguments are the map and the key to be deleted.\nIt's safe to do this even if the key is already absent\nfrom the map.\ndelete(timeZone, \"PDT\")  // Now on Standard Time\nFormatted printing in Go uses a style similar to C's\nfamily but is richer and more general. The functions live in the\npackage and have capitalized names:\nfmt.Fprintf\nfmt.Sprintf\nand so on.  The string functions (\nreturn a string rather than filling in a provided buffer.\nYou don't need to provide a format string.  For each of\nthere is another pair\nof functions, for instance\nThese functions do not take a format string but instead generate a default\nformat for each argument. The\nversions also insert a blank\nbetween arguments and append a newline to the output while\nversions add blanks only if the operand on neither side is a string.\nIn this example each line produces the same output.\nThe formatted print functions\nand friends take as a first argument any object\nthat implements the\ninterface; the variables\nare familiar instances.\nHere things start to diverge from C.  First, the numeric formats such as\ndo not take flags for signedness or size; instead, the printing routines use the\ntype of the argument to decide these properties.\nvar x uint64 = 1<<64 - 1\nfmt.Printf(\"%d %x; %d %x\\n\", x, x, int64(x), int64(x))\n18446744073709551615 ffffffffffffffff; -1 -1\nIf you just want the default conversion, such as decimal for integers, you can use\nthe catchall format\n(for “value”); the result is exactly\nwould produce.\nMoreover, that format can print\nvalue, even arrays, slices, structs, and\nmaps.  Here is a print statement for the time zone map defined in the previous section.\nfmt.Printf(\"%v\\n\", timeZone)  // or just fmt.Println(timeZone)\nwhich gives output:\nmap[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]\nand friends sort the output lexicographically by key.\nWhen printing a struct, the modified format\nannotates the\nfields of the structure with their names, and for any value the alternate\nprints the value in full Go syntax.\n(Note the ampersands.)\nThat quoted string format is also available through\napplied to a value of type\nThe alternate format\nwill use backquotes instead if possible.\nformat also applies to integers and runes, producing a\nsingle-quoted rune constant.)\nworks on strings, byte arrays and byte slices as well as\non integers, generating a long hexadecimal string, and with\na space in the format (\n) it puts spaces between the bytes.\nAnother handy format is\n, which prints the\nof a value.\nfmt.Printf(\"%T\\n\", timeZone)\nmap[string]int\nIf you want to control the default format for a custom type, all that's required is to define\na method with the signature\nString() string\non the type.\nFor our simple type\n, that might look like this.\nto print in the format\n7/-2.35/\"abc\\tdef\"\n(If you need to print\nas well as pointers to\nthe receiver for\nmust be of value type; this example used a pointer because\nthat's more efficient and idiomatic for struct types.\nSee the section below on\npointers vs. value receivers\nfor more information.)\nmethod is able to call\nbecause the\nprint routines are fully reentrant and can be wrapped this way.\nThere is one important detail to understand about this approach,\nhowever: don't construct a\nmethod by calling\nin a way that will recur into your\nmethod indefinitely.  This can happen if the\ncall attempts to print the receiver directly as a string, which in\nturn will invoke the method again.  It's a common and easy mistake\nto make, as this example shows.\nIt's also easy to fix: convert the argument to the basic string type, which does not have the\ninitialization section\nwe'll see another technique that avoids this recursion.\nAnother printing technique is to pass a print routine's arguments directly to another such routine.\nThe signature of\nuses the type\n...interface{}\nfor its final argument to specify that an arbitrary number of parameters (of arbitrary type)\ncan appear after the format.\nfunc Printf(format string, v ...interface{}) (n int, err error) {\nWithin the function\nacts like a variable of type\n[]interface{}\nbut if it is passed to another variadic function, it acts like\na regular list of arguments.\nHere is the implementation of the\nlog.Println\nwe used above. It passes its arguments directly to\nfmt.Sprintln\nfor the actual formatting.\nin the nested call to\nto tell the\ncompiler to treat\nas a list of arguments; otherwise it would just pass\nas a single slice argument.\nThere's even more to printing than we've covered here.  See the\ndocumentation\nfor package\nfor the details.\nBy the way, a\nparameter can be of a specific type, for instance\nfor a min function that chooses the least of a list of integers:\nNow we have the missing piece we needed to explain the design of\nbuilt-in function.  The signature of\nis different from our custom\nfunction above.\nSchematically, it's like this:\nfunc append(slice []\n, elements ...\nis a placeholder for any given type.  You can't\nactually write a function in Go where the type\nis determined by the caller.\nis built in: it needs support from the\ndoes is append the elements to the end of\nthe slice and return the result.  The result needs to be returned\nbecause, as with our hand-written\n, the underlying\narray may change.  This simple example\nx := []int{1,2,3}\nx = append(x, 4, 5, 6)\nfmt.Println(x)\n[1 2 3 4 5 6]\nlittle like\n, collecting an arbitrary number of\nBut what if we wanted to do what our\nappend a slice to a slice?  Easy: use\nat the call\nsite, just as we did in the call to\nabove.  This\nsnippet produces identical output to the one above.\nx := []int{1,2,3}\ny := []int{4,5,6}\nx = append(x, y...)\nfmt.Println(x)\nWithout that\n, it wouldn't compile because the types\nwould be wrong;\nis not of type\nInitialization\nAlthough it doesn't look superficially very different from\ninitialization in C or C++, initialization in Go is more powerful.\nComplex structures can be built during initialization and the ordering\nissues among initialized objects, even among different packages, are handled\nConstants in Go are just that—constant.\nThey are created at compile time, even when defined as\nlocals in functions,\nand can only be numbers, characters (runes), strings or booleans.\nBecause of the compile-time restriction, the expressions\nthat define them must be constant expressions,\nevaluatable by the compiler.  For instance,\nis a constant expression, while\nmath.Sin(math.Pi/4)\nis not because\nthe function call to\nto happen at run time.\nIn Go, enumerated constants are created using the\nenumerator.  Since\ncan be part of an expression and\nexpressions can be implicitly repeated, it is easy to build intricate\nsets of values.\nThe ability to attach a method such as\nuser-defined type makes it possible for arbitrary values to format themselves\nautomatically for printing.\nAlthough you'll see it most often applied to structs, this technique is also useful for\nscalar types such as floating-point types like\nThe expression\nByteSize(1e13)\nThe use here of\nto implement\nmethod is safe\n(avoids recurring indefinitely) not because of a conversion but\nbecause it calls\nwhich is not a string format:\nwill only call\nmethod when it wants a string, and\nwants a floating-point value.\nVariables can be initialized just like constants but the\ninitializer can be a general expression computed at run time.\nThe init function\nFinally, each source file can define its own niladic\nfunction to\nset up whatever state is required.  (Actually each file can have multiple\nfunctions.)\nAnd finally means finally:\nis called after all the\nvariable declarations in the package have evaluated their initializers,\nand those are evaluated only after all the imported packages have been\ninitialized.\nBesides initializations that cannot be expressed as declarations,\na common use of\nfunctions is to verify or repair\ncorrectness of the program state before real execution begins.\nPointers vs. Values\nAs we saw with\nmethods can be defined for any named type (except a pointer or an interface);\nthe receiver does not have to be a struct.\nIn the discussion of slices above, we wrote an\nfunction.  We can define it as a method on slices instead.  To do\nthis, we first declare a named type to which we can bind the method, and\nthen make the receiver for the method a value of that type.\nThis still requires the method to return the updated slice.  We can\neliminate that clumsiness by redefining the method to take a\nas its receiver, so the\nmethod can overwrite the caller's slice.\nIn fact, we can do even better.  If we modify our function so it looks\nlike a standard\nmethod, like this,\nthen the type\nsatisfies the standard interface\n, which is handy.  For instance, we can\nprint into one.\nvar b ByteSlice\nfmt.Fprintf(&b, \"This hour has %d days\\n\", 7)\nWe pass the address of a\nbecause only\nThe rule about pointers vs. values for receivers is that value methods\ncan be invoked on pointers and values, but pointer methods can only be\ninvoked on pointers.\nThis rule arises because pointer methods can modify the receiver; invoking\nthem on a value would cause the method to receive a copy of the value, so\nany modifications would be discarded.\nThe language therefore disallows this mistake.\nThere is a handy exception, though. When the value is addressable, the\nlanguage takes care of the common case of invoking a pointer method on a\nvalue by inserting the address operator automatically.\nIn our example, the variable\nis addressable, so we can call\nmethod with just\n. The compiler\nwill rewrite that to\nBy the way, the idea of using\non a slice of bytes\nis central to the implementation of\nbytes.Buffer\nInterfaces and other types\nInterfaces in Go provide a way to specify the behavior of an\nobject: if something can do\n, then it can be used\n.  We've seen a couple of simple examples already;\ncustom printers can be implemented by a\ncan generate output to anything\nInterfaces with only one or two methods are common in Go code, and are\nusually given a name derived from the method, such as\nfor something that implements\nA type can implement multiple interfaces.\nFor instance, a collection can be sorted\nby the routines in package\nif it implements\nsort.Interface\n, which contains\nLess(i, j int) bool\nSwap(i, j int)\nand it could also have a custom formatter.\nIn this contrived example\nsatisfies both.\nConversions\nis recreating the\nalready does for slices.\n(It also has complexity O(N²), which is poor.) We can share the\neffort (and also speed it up) if we convert the\nbefore calling\nThis method is another example of the conversion technique for calling\nsafely from a\nBecause the two types (\nare the same if we ignore the type name, it's legal to convert between them.\nThe conversion doesn't create a new value, it just temporarily acts\nas though the existing value has a new type.\n(There are other legal conversions, such as from integer to floating point, that\ndo create a new value.)\nIt's an idiom in Go programs to convert the\ntype of an expression to access a different\nset of methods. As an example, we could use the existing\nsort.IntSlice\nto reduce the entire example\nNow, instead of having\nimplement multiple\ninterfaces (sorting and printing), we're using the ability of a data item to be\nconverted to multiple types (\nsort.IntSlice\n), each of which does some part of the job.\nThat's more unusual in practice but can be effective.\nInterface conversions and type assertions\nType switches\nare a form of conversion: they take an interface and, for\neach case in the switch, in a sense convert it to the type of that case.\nHere's a simplified version of how the code under\nturns a value into\na string using a type switch.\nIf it's already a string, we want the actual string value held by the interface, while if it has a\nmethod we want the result of calling the method.\nThe first case finds a concrete value; the second converts the interface into another interface.\nIt's perfectly fine to mix types this way.\nWhat if there's only one type we care about? If we know the value holds a\nand we just want to extract it?\nA one-case type switch would do, but so would a\ntype assertion\nA type assertion takes an interface value and extracts from it a value of the specified explicit type.\nThe syntax borrows from the clause opening a type switch, but with an explicit\ntype rather than the\nvalue.(typeName)\nand the result is a new value with the static type\nThat type must either be the concrete type held by the interface, or a second interface\ntype that the value can be converted to.\nTo extract the string we know is in the value, we could write:\nstr := value.(string)\nBut if it turns out that the value does not contain a string, the program will crash with a run-time error.\nTo guard against that, use the \"comma, ok\" idiom to test, safely, whether the value is a string:\nIf the type assertion fails,\nwill still exist and be of type string, but it will have\nthe zero value, an empty string.\nAs an illustration of the capability, here's an\nstatement that's equivalent to the type switch that opened this section.\nIf a type exists only to implement an interface and will\nnever have exported methods beyond that interface, there is\nno need to export the type itself.\nExporting just the interface makes it clear the value has no\ninteresting behavior beyond what is described in the\nIt also avoids the need to repeat the documentation\non every instance of a common method.\nIn such cases, the constructor should return an interface value\nrather than the implementing type.\nAs an example, in the hash libraries\ncrc32.NewIEEE\nadler32.New\nreturn the interface type\nhash.Hash32\nSubstituting the CRC-32 algorithm for Adler-32 in a Go program\nrequires only changing the constructor call;\nthe rest of the code is unaffected by the change of algorithm.\nA similar approach allows the streaming cipher algorithms\nin the various\npackages to be\nseparated from the block ciphers they chain together.\ncrypto/cipher\npackage specifies the\nbehavior of a block cipher, which provides encryption\nof a single block of data.\nThen, by analogy with the\ncipher packages that implement this interface\ncan be used to construct streaming ciphers, represented\ninterface, without\nknowing the details of the block encryption.\ncrypto/cipher\ninterfaces look like this:\nHere's the definition of the counter mode (CTR) stream,\nwhich turns a block cipher into a streaming cipher; notice\nthat the block cipher's details are abstracted away:\napplies not\njust to one specific encryption algorithm and data source but to any\nimplementation of the\ninterface and any\n.  Because they return\ninterface values, replacing CTR\nencryption with other encryption modes is a localized change.  The constructor\ncalls must be edited, but because the surrounding code must treat the result only\n, it won't notice the difference.\nInterfaces and methods\nSince almost anything can have methods attached, almost anything can\nsatisfy an interface.  One illustrative example is in the\npackage, which defines the\ninterface.  Any object\nthat implements\ncan serve HTTP requests.\ntype Handler interface {\nServeHTTP(ResponseWriter, *Request)\nResponseWriter\nis itself an interface that provides access\nto the methods needed to return the response to the client.\nThose methods include the standard\nmethod, so an\nhttp.ResponseWriter\ncan be used wherever an\ncan be used.\nis a struct containing a parsed representation\nof the request from the client.\nFor brevity, let's ignore POSTs and assume HTTP requests are always\nGETs; that simplification does not affect the way the handlers are set up.\nHere's a trivial implementation of a handler to count the number of times\nthe page is visited.\n(Keeping with our theme, note how\ncan print to an\nhttp.ResponseWriter\nIn a real server, access to\nwould need protection from\nconcurrent access.\npackages for suggestions.\nFor reference, here's how to attach such a server to a node on the URL tree.\nimport \"net/http\"\nctr := new(Counter)\nhttp.Handle(\"/counter\", ctr)\nBut why make\na struct?  An integer is all that's needed.\n(The receiver needs to be a pointer so the increment is visible to the caller.)\nWhat if your program has some internal state that needs to be notified that a page\nhas been visited?  Tie a channel to the web page.\nFinally, let's say we wanted to present on\nthe arguments\nused when invoking the server binary.\nIt's easy to write a function to print the arguments.\nfunc ArgServer() {\nfmt.Println(os.Args)\nHow do we turn that into an HTTP server?  We could make\na method of some type whose value we ignore, but there's a cleaner way.\nSince we can define a method for any type except pointers and interfaces,\nwe can write a method for a function.\npackage contains this code:\nHandlerFunc\nis a type with a method,\nso values of that type can serve HTTP requests.  Look at the implementation\nof the method: the receiver is a function,\n, and the method\n.  That may seem odd but it's not that different from, say,\nthe receiver being a channel and the method sending on the channel.\ninto an HTTP server, we first modify it\nto have the right signature.\nnow has the same signature as\nHandlerFunc\nso it can be converted to that type to access its methods,\njust as we converted\nIntSlice.Sort\nThe code to set it up is concise:\nhttp.Handle(\"/args\", http.HandlerFunc(ArgServer))\nWhen someone visits the page\nthe handler installed at that page has value\nHandlerFunc\nThe HTTP server will invoke the method\nof that type, with\nas the receiver, which will in turn call\n(via the invocation\nHandlerFunc.ServeHTTP\nThe arguments will then be displayed.\nIn this section we have made an HTTP server from a struct, an integer,\na channel, and a function, all because interfaces are just sets of\nmethods, which can be defined for (almost) any type.\nThe blank identifier\nWe've mentioned the blank identifier a couple of times now, in the context of\nThe blank identifier can be assigned or declared with any value of any type, with the\nvalue discarded harmlessly.\nIt's a bit like writing to the Unix\nit represents a write-only value\nto be used as a place-holder\nwhere a variable is needed but the actual value is irrelevant.\nIt has uses beyond those we've seen already.\nThe blank identifier in multiple assignment\nThe use of a blank identifier in a\nspecial case of a general situation: multiple assignment.\nIf an assignment requires multiple values on the left side,\nbut one of the values will not be used by the program,\na blank identifier on the left-hand-side of\nthe assignment avoids the need\nto create a dummy variable and makes it clear that the\nvalue is to be discarded.\nFor instance, when calling a function that returns\na value and an error, but only the error is important,\nuse the blank identifier to discard the irrelevant value.\nif _, err := os.Stat(path); os.IsNotExist(err) {\nfmt.Printf(\"%s does not exist\\n\", path)\nOccasionally you'll see code that discards the error value in order\nto ignore the error; this is terrible practice. Always check error returns;\nthey're provided for a reason.\nUnused imports and variables\nIt is an error to import a package or to declare a variable without using it.\nUnused imports bloat the program and slow compilation,\nwhile a variable that is initialized but not used is at least\na wasted computation and perhaps indicative of a\nlarger bug.\nWhen a program is under active development, however,\nunused imports and variables often arise and it can\nbe annoying to delete them just to have the compilation proceed,\nonly to have them be needed again later.\nThe blank identifier provides a workaround.\nThis half-written program has two unused imports\nand an unused variable (\nso it will not compile, but it would be nice to see if the\ncode so far is correct.\nTo silence complaints about the unused imports, use a\nblank identifier to refer to a symbol from the imported package.\nSimilarly, assigning the unused variable\nto the blank identifier will silence the unused variable error.\nThis version of the program does compile.\nBy convention, the global declarations to silence import errors\nshould come right after the imports and be commented,\nboth to make them easy to find and as a reminder to clean things up later.\nImport for side effect\nAn unused import like\nprevious example should eventually be used or removed:\nblank assignments identify code as a work in progress.\nBut sometimes it is useful to import a package only for its\nside effects, without any explicit use.\nFor example, during its\nnet/http/pprof\npackage registers HTTP handlers that provide\ndebugging information. It has an exported API, but\nmost clients need only the handler registration and\naccess the data through a web page.\nTo import the package only for its side effects, rename the package\nto the blank identifier:\nimport _ \"net/http/pprof\"\nThis form of import makes clear that the package is being\nimported for its side effects, because there is no other possible\nuse of the package: in this file, it doesn't have a name.\n(If it did, and we didn't use that name, the compiler would reject the program.)\nInterface checks\nAs we saw in the discussion of\na type need not declare explicitly that it implements an interface.\nInstead, a type implements the interface just by implementing the interface's methods.\nIn practice, most interface conversions are static and therefore checked at compile time.\nFor example, passing an\nto a function\nexpecting an\nwill not compile unless\nimplements the\nSome interface checks do happen at run-time, though.\nOne instance is in the\nencoding/json\npackage, which defines a\ninterface. When the JSON encoder receives a value that implements that interface,\nthe encoder invokes the value's marshaling method to convert it to JSON\ninstead of doing the standard conversion.\nThe encoder checks this property at run time with a\ntype assertion\nm, ok := val.(json.Marshaler)\nIf it's necessary only to ask whether a type implements an interface, without\nactually using the interface itself, perhaps as part of an error check, use the blank\nidentifier to ignore the type-asserted value:\nOne place this situation arises is when it is necessary to guarantee within the package implementing the type that\nit actually satisfies the interface.\nIf a type—for example,\njson.RawMessage\na custom JSON representation, it should implement\njson.Marshaler\n, but there are no static conversions that would\ncause the compiler to verify this automatically.\nIf the type inadvertently fails to satisfy the interface, the JSON encoder will still work,\nbut will not use the custom implementation.\nTo guarantee that the implementation is correct,\na global declaration using the blank identifier can be used in the package:\nvar _ json.Marshaler = (*RawMessage)(nil)\nIn this declaration, the assignment involving a conversion of a\n*RawMessage\nrequires that\n*RawMessage\nand that property will be checked at compile time.\njson.Marshaler\ninterface change, this package\nwill no longer compile and we will be on notice that it needs to be updated.\nThe appearance of the blank identifier in this construct indicates that\nthe declaration exists only for the type checking,\nnot to create a variable.\nDon't do this for every type that satisfies an interface, though.\nBy convention, such declarations are only used\nwhen there are no static conversions already present in the code,\nwhich is a rare event.\nGo does not provide the typical, type-driven notion of subclassing,\nbut it does have the ability to “borrow” pieces of an\nimplementation by\ntypes within a struct or\nInterface embedding is very simple.\nWe've mentioned the\ninterfaces before;\nhere are their definitions.\npackage also exports several other interfaces\nthat specify objects that can implement several such methods.\nFor instance, there is\nio.ReadWriter\n, an interface\ncontaining both\nWe could specify\nio.ReadWriter\nby listing the\ntwo methods explicitly, but it's easier and more evocative\nto embed the two interfaces to form the new one, like this:\nThis says just what it looks like: A\ndoes; it is a union of the embedded interfaces.\nOnly interfaces can be embedded within interfaces.\nThe same basic idea applies to structs, but with more far-reaching\nimplications.  The\npackage has two struct types,\nbufio.Reader\nbufio.Writer\nwhich of course implements the analogous interfaces from package\nalso implements a buffered reader/writer,\nwhich it does by combining a reader and a writer into one struct\nusing embedding: it lists the types within the struct\nbut does not give them field names.\nThe embedded elements are pointers to structs and of course\nmust be initialized to point to valid structs before they\ncan be used.\nstruct could be written as\ntype ReadWriter struct {\nreader *Reader\nwriter *Writer\nbut then to promote the methods of the fields and to\nsatisfy the\ninterfaces, we would also need\nto provide forwarding methods, like this:\nfunc (rw *ReadWriter) Read(p []byte) (n int, err error) {\nreturn rw.reader.Read(p)\nBy embedding the structs directly, we avoid this bookkeeping.\nThe methods of embedded types come along for free, which means that\nbufio.ReadWriter\nnot only has the methods of\nbufio.Reader\nbufio.Writer\nit also satisfies all three interfaces:\nio.ReadWriter\nThere's an important way in which embedding differs from subclassing.  When we embed a type,\nthe methods of that type become methods of the outer type,\nbut when they are invoked the receiver of the method is the inner type, not the outer one.\nIn our example, when the\nmethod of a\nbufio.ReadWriter\ninvoked, it has exactly the same effect as the forwarding method written out above;\nthe receiver is the\nfield of the\nEmbedding can also be a simple convenience.\nThis example shows an embedded field alongside a regular, named field.\ntype Job struct {\nCommand string\n*log.Logger\ntype now has the\n*log.Logger\n.  We could have given the\na field name, of course, but it's not necessary to do so.  And now, once\ninitialized, we can\njob.Println(\"starting now...\")\nis a regular field of the\nso we can initialize it in the usual way inside the constructor for\n, like this,\nfunc NewJob(command string, logger *log.Logger) *Job {\nreturn &Job{command, logger}\nor with a composite literal,\njob := &Job{command, log.New(os.Stderr, \"Job: \", log.Ldate)}\nIf we need to refer to an embedded field directly, the type name of the field,\nignoring the package qualifier, serves as a field name, as it did\nmethod of our\nHere, if we needed to access the\n*log.Logger\nwe would write\nwhich would be useful if we wanted to refine the methods of\nEmbedding types introduces the problem of name conflicts but the rules to resolve\nthem are simple.\nFirst, a field or method\nhides any other item\nin a more deeply\nnested part of the type.\ncontained a field or method called\nwould dominate it.\nSecond, if the same name appears at the same nesting level, it is usually an error;\nit would be erroneous to embed\ncontained another field or method called\nHowever, if the duplicate name is never mentioned in the program outside the type definition, it is OK.\nThis qualification provides some protection against changes made to types embedded from outside; there\nis no problem if a field is added that conflicts with another field in another subtype if neither field\nis ever used.\nConcurrency\nShare by communicating\nConcurrent programming is a large topic and there is space only for some\nGo-specific highlights here.\nConcurrent programming in many environments is made difficult by the\nsubtleties required to implement correct access to shared variables.  Go encourages\na different approach in which shared values are passed around on channels\nand, in fact, never actively shared by separate threads of execution.\nOnly one goroutine has access to the value at any given time.\nData races cannot occur, by design.\nTo encourage this way of thinking we have reduced it to a slogan:\nDo not communicate by sharing memory;\ninstead, share memory by communicating.\nThis approach can be taken too far.  Reference counts may be best done\nby putting a mutex around an integer variable, for instance.  But as a\nhigh-level approach, using channels to control access makes it easier\nto write clear, correct programs.\nOne way to think about this model is to consider a typical single-threaded\nprogram running on one CPU. It has no need for synchronization primitives.\nNow run another such instance; it too needs no synchronization.  Now let those\ntwo communicate; if the communication is the synchronizer, there's still no need\nfor other synchronization.  Unix pipelines, for example, fit this model\nperfectly.  Although Go's approach to concurrency originates in Hoare's\nCommunicating Sequential Processes (CSP),\nit can also be seen as a type-safe generalization of Unix pipes.\nThey're called\nbecause the existing\nterms—threads, coroutines, processes, and so on—convey\ninaccurate connotations.  A goroutine has a simple model: it is a\nfunction executing concurrently with other goroutines in the same\naddress space.  It is lightweight, costing little more than the\nallocation of stack space.\nAnd the stacks start small, so they are cheap, and grow\nby allocating (and freeing) heap storage as required.\nGoroutines are multiplexed onto multiple OS threads so if one should\nblock, such as while waiting for I/O, others continue to run.  Their\ndesign hides many of the complexities of thread creation and\nmanagement.\nPrefix a function or method call with the\nkeyword to run the call in a new goroutine.\nWhen the call completes, the goroutine\nexits, silently.  (The effect is similar to the Unix shell's\nnotation for running a command in the\nbackground.)\ngo list.Sort()  // run list.Sort concurrently; don't wait for it.\nA function literal can be handy in a goroutine invocation.\nIn Go, function literals are closures: the implementation makes\nsure the variables referred to by the function survive as long as they are active.\nThese examples aren't too practical because the functions have no way of signaling\ncompletion.  For that, we need channels.\nLike maps, channels are allocated with\nthe resulting value acts as a reference to an underlying data structure.\nIf an optional integer parameter is provided, it sets the buffer size for the channel.\nThe default is zero, for an unbuffered or synchronous channel.\nUnbuffered channels combine communication—the exchange of a value—with\nsynchronization—guaranteeing that two calculations (goroutines) are in\na known state.\nThere are lots of nice idioms using channels.  Here's one to get us started.\nIn the previous section we launched a sort in the background. A channel\ncan allow the launching goroutine to wait for the sort to complete.\nReceivers always block until there is data to receive.\nIf the channel is unbuffered, the sender blocks until the receiver has\nreceived the value.\nIf the channel has a buffer, the sender blocks only until the\nvalue has been copied to the buffer; if the buffer is full, this\nmeans waiting until some receiver has retrieved a value.\nA buffered channel can be used like a semaphore, for instance to\nlimit throughput.  In this example, incoming requests are passed\n, which sends a value into the channel, processes\nthe request, and then receives a value from the channel\nto ready the “semaphore” for the next consumer.\nThe capacity of the channel buffer limits the number of\nsimultaneous calls to\nMaxOutstanding\nhandlers are executing\nany more will block trying to send into the filled channel buffer,\nuntil one of the existing handlers finishes and receives from the buffer.\nThis design has a problem, though:\ncreates a new goroutine for\nevery incoming request, even though only\nMaxOutstanding\nof them can run at any moment.\nAs a result, the program can consume unlimited resources if the requests come in too fast.\nWe can address that deficiency by changing\ngate the creation of the goroutines:\n(Note that in Go versions before 1.22 this code has a bug: the loop\nvariable is shared across all goroutines.\nfor details.)\nAnother approach that manages resources well is to start a fixed\ngoroutines all reading from the request\nThe number of goroutines limits the number of simultaneous\nfunction also accepts a channel on which\nit will be told to exit; after launching the goroutines it blocks\nreceiving from that channel.\nChannels of channels\nOne of the most important properties of Go is that\na channel is a first-class value that can be allocated and passed\naround like any other.  A common use of this property is\nto implement safe, parallel demultiplexing.\nIn the example in the previous section,\nan idealized handler for a request but we didn't define the\ntype it was handling.  If that type includes a channel on which\nto reply, each client can provide its own path for the answer.\nHere's a schematic definition of type\nThe client provides a function and its arguments, as well as\na channel inside the request object on which to receive the answer.\nOn the server side, the handler function is the only thing that changes.\nThere's clearly a lot more to do to make it realistic, but this\ncode is a framework for a rate-limited, parallel, non-blocking RPC\nsystem, and there's not a mutex in sight.\nParallelization\nAnother application of these ideas is to parallelize a calculation\nacross multiple CPU cores.  If the calculation can be broken into\nseparate pieces that can execute independently, it can be parallelized,\nwith a channel to signal when each piece completes.\nLet's say we have an expensive operation to perform on a vector of items,\nand that the value of the operation on each item is independent,\nas in this idealized example.\nWe launch the pieces independently in a loop, one per CPU.\nThey can complete in any order but it doesn't matter; we just\ncount the completion signals by draining the channel after\nlaunching all the goroutines.\nRather than create a constant value for numCPU, we can ask the runtime what\nvalue is appropriate.\nThe function\nruntime.NumCPU\nreturns the number of hardware CPU cores in the machine, so we could write\nvar numCPU = runtime.NumCPU()\nThere is also a function\nruntime.GOMAXPROCS\nwhich reports (or sets)\nthe user-specified number of cores that a Go program can have running\nsimultaneously.\nIt defaults to the value of\nruntime.NumCPU\noverridden by setting the similarly named shell environment variable\nor by calling the function with a positive number.  Calling it with\nzero just queries the value.\nTherefore if we want to honor the user's resource request, we should write\nvar numCPU = runtime.GOMAXPROCS(0)\nBe sure not to confuse the ideas of concurrency—structuring a program\nas independently executing components—and parallelism—executing\ncalculations in parallel for efficiency on multiple CPUs.\nAlthough the concurrency features of Go can make some problems easy\nto structure as parallel computations, Go is a concurrent language,\nnot a parallel one, and not all parallelization problems fit Go's model.\nFor a discussion of the distinction, see the talk cited in\nA leaky buffer\nThe tools of concurrent programming can even make non-concurrent\nideas easier to express.  Here's an example abstracted from an RPC\npackage.  The client goroutine loops receiving data from some source,\nperhaps a network.  To avoid allocating and freeing buffers, it keeps\na free list, and uses a buffered channel to represent it.  If the\nchannel is empty, a new buffer gets allocated.\nOnce the message buffer is ready, it's sent to the server on\nThe server loop receives each message from the client, processes it,\nand returns the buffer to the free list.\nThe client attempts to retrieve a buffer from\nif none is available, it allocates a fresh one.\nThe server's send to\non the free list unless the list is full, in which case the\nbuffer is dropped on the floor to be reclaimed by\nthe garbage collector.\nclauses in the\nstatements execute when no other case is ready,\nmeaning that the\nnever block.)\nThis implementation builds a leaky bucket free list\nin just a few lines, relying on the buffered channel and\nthe garbage collector for bookkeeping.\nLibrary routines must often return some sort of error indication to\nthe caller.\nAs mentioned earlier, Go's multivalue return makes it\neasy to return a detailed error description alongside the normal\nreturn value.\nIt is good style to use this feature to provide detailed error information.\nFor example, as we'll see,\njust return a\npointer on failure, it also returns an\nerror value that describes what went wrong.\nBy convention, errors have type\na simple built-in interface.\ntype error interface {\nError() string\nA library writer is free to implement this interface with a\nricher model under the covers, making it possible not only\nto see the error but also to provide some context.\nAs mentioned, alongside the usual\nreturn value,\nalso returns an\nerror value.\nIf the file is opened successfully, the error will be\nbut when there is a problem, it will hold an\nos.PathError\na string like this:\nopen /etc/passwx: no such file or directory\nSuch an error, which includes the problematic file name, the\noperation, and the operating system error it triggered, is useful even\nif printed far from the call that caused it;\nit is much more informative than the plain\n\"no such file or directory\".\nWhen feasible, error strings should identify their origin, such as by having\na prefix naming the operation or package that generated the error.  For example, in package\n, the string representation for a decoding error due to an\nunknown format is \"image: unknown format\".\nCallers that care about the precise error details can\nuse a type switch or a type assertion to look for specific\nerrors and extract details.  For\nthis might include examining the internal\nfield for recoverable failures.\nstatement here is another\ntype assertion\nIf it fails,\nwill be false, and\nIf it succeeds,\nwill be true, which means the\nerror was of type\n*os.PathError\n, and then so is\nwhich we can examine for more information about the error.\nThe usual way to report an error to a caller is to return an\nas an extra return value.  The canonical\nmethod is a well-known instance; it returns a byte\ncount and an\n.  But what if the error is\nunrecoverable?  Sometimes the program simply cannot continue.\nFor this purpose, there is a built-in function\nthat in effect creates a run-time error that will stop the program\n(but see the next section).  The function takes a single argument\nof arbitrary type—often a string—to be printed as the\nprogram dies.  It's also a way to indicate that something impossible has\nhappened, such as exiting an infinite loop.\nThis is only an example but real library functions should\n.  If the problem can be masked or worked\naround, it's always better to let things continue to run rather\nthan taking down the whole program.  One possible counterexample\nis during initialization: if the library truly cannot set itself up,\nit might be reasonable to panic, so to speak.\nis called, including implicitly for run-time\nerrors such as indexing a slice out of bounds or failing a type\nassertion, it immediately stops execution of the current function\nand begins unwinding the stack of the goroutine, running any deferred\nfunctions along the way.  If that unwinding reaches the top of the\ngoroutine's stack, the program dies.  However, it is possible to\nuse the built-in function\nto regain control\nof the goroutine and resume normal execution.\nstops the unwinding and returns the\nargument passed to\n.  Because the only code that\nruns while unwinding is inside deferred functions,\nis only useful inside deferred functions.\nOne application of\nis to shut down a failing goroutine\ninside a server without killing the other executing goroutines.\nIn this example, if\npanics, the result will be\nlogged and the goroutine will exit cleanly without disturbing the\nothers.  There's no need to do anything else in the deferred closure;\nhandles the condition completely.\nalways returns\nunless called directly\nfrom a deferred function, deferred code can call library routines that themselves\nwithout failing.  As an example,\nthe deferred function in\nmight call a logging function before\n, and that logging code would run unaffected\nby the panicking state.\nWith our recovery pattern in place, the\nfunction (and anything it calls) can get out of any bad situation\ncleanly by calling\n.  We can use that idea to\nsimplify error handling in complex software.  Let's look at an\nidealized version of a\npackage, which reports\nparsing errors by calling\nwith a local\nerror type.  Here's the definition of\nmethod, and the\npanics, the recovery block will set the\nreturn value to\n—deferred functions can modify\nnamed return values.  It will then check, in the assignment\n, that the problem was a parse error by asserting\nthat it has the local type\nIf it does not, the type assertion will fail, causing a run-time error\nthat continues the stack unwinding as though nothing had interrupted\nThis check means that if something unexpected happens, such\nas an index out of bounds, the code will fail even though we\nparse errors.\nWith error handling in place, the\nmethod (because it's a\nmethod bound to a type, it's fine, even natural, for it to have the same name\nas the builtin\nmakes it easy to report parse errors without worrying about unwinding\nthe parse stack by hand:\nif pos == 0 {\nre.error(\"'*' illegal at start of expression\")\nUseful though this pattern is, it should be used only within a package.\nturns its internal\nvalues; it does not expose\nto its client.  That is a good rule to follow.\nBy the way, this re-panic idiom changes the panic value if an actual\nerror occurs.  However, both the original and new failures will be\npresented in the crash report, so the root cause of the problem will\nstill be visible.  Thus this simple re-panic approach is usually\nsufficient—it's a crash after all—but if you want to\ndisplay only the original value, you can write a little more code to\nfilter unexpected problems and re-panic with the original error.\nThat's left as an exercise for the reader.\nA web server\nLet's finish with a complete Go program, a web server.\nThis one is actually a kind of web re-server.\nGoogle provides a service at\nchart.apis.google.com\nthat does automatic formatting of data into charts and graphs.\nIt's hard to use interactively, though,\nbecause you need to put the data into the URL as a query.\nThe program here provides a nicer interface to one form of data: given a short piece of text,\nit calls on the chart server to produce a QR code, a matrix of boxes that encode the\nThat image can be grabbed with your cell phone's camera and interpreted as,\nfor instance, a URL, saving you typing the URL into the phone's tiny keyboard.\nHere's the complete program.\nAn explanation follows.\nThe pieces up to\nshould be easy to follow.\nThe one flag sets a default HTTP port for our server.  The template\nis where the fun happens. It builds an HTML template\nthat will be executed by the server to display the page; more about\nthat in a moment.\nfunction parses the flags and, using the mechanism\nwe talked about above, binds the function\nto the root path\nfor the server.  Then\nhttp.ListenAndServe\nis called to start the\nserver; it blocks while the server runs.\njust receives the request, which contains form data, and\nexecutes the template on the data in the form value named\nThe template package\nhtml/template\nis powerful;\nthis program just touches on its capabilities.\nIn essence, it rewrites a piece of HTML text on the fly by substituting elements derived\nfrom data items passed to\ntempl.Execute\n, in this case the\nform value.\nWithin the template text (\ntemplateStr\ndouble-brace-delimited pieces denote template actions.\nThe piece from\nexecutes only if the value of the current data item, called\nis non-empty.\nThat is, when the string is empty, this piece of the template is suppressed.\nThe two snippets\nsay to show the data presented to\nthe template—the query string—on the web page.\nThe HTML template package automatically provides appropriate escaping so the\ntext is safe to display.\nThe rest of the template string is just the HTML to show when the page loads.\nIf this is too quick an explanation, see the\ndocumentation\nfor the template package for a more thorough discussion.\nAnd there you have it: a useful web server in a few lines of code plus some\ndata-driven HTML text.\nGo is powerful enough to make a lot happen in a few lines.",
  "word_count": 12227,
  "key_terms": [
    "parameter",
    "return",
    "framework",
    "method",
    "function",
    "import",
    "implementation",
    "variable",
    "export",
    "object"
  ]
}