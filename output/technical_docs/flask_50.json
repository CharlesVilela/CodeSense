{
  "metadata": {
    "title": "Quickstart¶",
    "url": "https://flask.palletsprojects.com/en/stable/quickstart/",
    "technology": "flask",
    "category": "frameworks",
    "english_level": "B1",
    "professional_context": "development",
    "content_type": "technical_documentation",
    "last_updated": "1761765815.0419679"
  },
  "content": "Eager to get started? This page gives a good introduction to Flask.\nInstallation\nto set up a project and install Flask first.\nA Minimal Application\nA minimal Flask application looks something like this:\nSo what did that code do?\nFirst we imported the\nclass. An instance of\nthis class will be our WSGI application.\nNext we create an instance of this class. The first argument is the\nname of the application’s module or package.\nconvenient shortcut for this that is appropriate for most cases.\nThis is needed so that Flask knows where to look for resources such\nas templates and static files.\nWe then use the\ndecorator to tell Flask\nwhat URL should trigger our function.\nThe function returns the message we want to display in the user’s\nbrowser. The default content type is HTML, so HTML in the string\nwill be rendered by the browser.\nor something similar. Make sure to not call\nyour application\nbecause this would conflict with Flask\nTo run the application, use the\n. You need to tell the Flask where your application\nis with the\nApplication Discovery Behavior\nAs a shortcut, if the file is named\ndon’t have to use\nCommand Line Interface\nfor more details.\nThis launches a very simple builtin server, which is good enough for\ntesting but probably not what you want to use in production. For\ndeployment options see\nDeploying to Production\nNow head over to\nhttp://127.0.0.1:5000/\n, and you should see your hello\nworld greeting.\nIf another program is already using port 5000, you’ll see\nserver tries to start. See\nAddress already in use\nhandle that.\nExternally Visible Server\nIf you run the server you will notice that the server is only accessible\nfrom your own computer, not from any other in the network.  This is the\ndefault because in debugging mode a user of the application can execute\narbitrary Python code on your computer.\nIf you have the debugger disabled or trust the users on your network,\nyou can make the server publicly available simply by adding\n--host=0.0.0.0\nto the command line:\n$ flask run --host=0.0.0.0\nThis tells your operating system to listen on all public IPs.\ncommand can do more than just start the development\nserver. By enabling debug mode, the server will automatically reload if\ncode changes, and will show an interactive debugger in the browser if an\nerror occurs during a request.\nThe debugger allows executing arbitrary Python code from the\nbrowser. It is protected by a pin, but still represents a major\nsecurity risk. Do not run the development server or debugger in a\nproduction environment.\nTo enable debug mode, use the\nDevelopment Server\nCommand Line Interface\nfor information about running in debug mode.\nDebugging Application Errors\nfor information about using the built-in debugger\nand other debuggers.\nHandling Application Errors\nto log errors and display\nnice error pages.\nHTML Escaping\nWhen returning HTML (the default response type in Flask), any\nuser-provided values rendered in the output must be escaped to protect\nfrom injection attacks. HTML templates rendered with Jinja, introduced\nlater, will do this automatically.\n, shown here, can be used manually. It is\nomitted in most examples for brevity, but you should always be aware of\nhow you’re using untrusted data.\nIf a user submits\n/hello?name=<script>alert(\"bad\")</script>\n, escaping causes\nit to be rendered as text, rather than running the script in the user’s browser.\nModern web applications use meaningful URLs to help users. Users are more\nlikely to like a page and come back if the page uses a meaningful URL they can\nremember and use to directly visit a page.\ndecorator to bind a function to a URL.\nYou can do more! You can make parts of the URL dynamic and attach multiple\nrules to a function.\nVariable Rules\nYou can add variable sections to a URL by marking sections with\n<variable_name>\n. Your function then receives the\n<variable_name>\nas a keyword argument. Optionally, you can use a converter to specify the type\nof the argument like\n<converter:variable_name>\nConverter types:\n(default) accepts any text without a slash\naccepts positive integers\naccepts positive floating point values\nbut also accepts slashes\naccepts UUID strings\nUnique URLs / Redirection Behavior\nThe following two rules differ in their use of a trailing slash.\nThe canonical URL for the\nendpoint has a trailing slash.\nIt’s similar to a folder in a file system. If you access the URL without\na trailing slash (\n), Flask redirects you to the canonical URL\nwith the trailing slash (\nThe canonical URL for the\nendpoint does not have a trailing\nslash. It’s similar to the pathname of a file. Accessing the URL with a\ntrailing slash (\n) produces a 404 “Not Found” error. This helps\nkeep URLs unique for these resources, which helps search engines avoid\nindexing the same page twice.\nURL Building\nTo build a URL to a specific function, use the\nIt accepts the name of the function as its first argument and any number of\nkeyword arguments, each corresponding to a variable part of the URL rule.\nUnknown variable parts are appended to the URL as query parameters.\nWhy would you want to build URLs using the URL reversing function\ninstead of hard-coding them into your templates?\nReversing is often more descriptive than hard-coding the URLs.\nYou can change your URLs in one go instead of needing to remember to\nmanually change hard-coded URLs.\nURL building handles escaping of special characters transparently.\nThe generated paths are always absolute, avoiding unexpected behavior\nof relative paths in browsers.\nIf your application is placed outside the URL root, for example, in\n/myapplication\nhandles that for you.\nFor example, here we use the\ntest_request_context()\ntest_request_context()\ntells Flask to behave as though it’s handling a request even while we use a\nPython shell. See\nContext Locals\n/login?next=/\n/user/John%20Doe\nHTTP Methods\nWeb applications use different HTTP methods when accessing URLs. You should\nfamiliarize yourself with the HTTP methods as you work with Flask. By default,\na route only answers to\nrequests. You can use the\ndecorator to handle different HTTP methods.\nThe example above keeps all methods for the route within one function,\nwhich can be useful if each part uses some common data.\nYou can also separate views for different methods into different\nfunctions. Flask provides a shortcut for decorating such routes with\n, etc. for each\ncommon HTTP method.\nis present, Flask automatically adds support for the\nand handles\nrequests according to the\n. Likewise,\nis automatically implemented for you.\nStatic Files\nDynamic web applications also need static files.  That’s usually where\nthe CSS and JavaScript files are coming from.  Ideally your web server is\nconfigured to serve them for you, but during development Flask can do that\nas well.  Just create a folder called\nin your package or next to\nyour module and it will be available at\non the application.\nTo generate URLs for static files, use the special\nendpoint name:\n'style.css'\nThe file has to be stored on the filesystem as\nstatic/style.css\nRendering Templates\nGenerating HTML from within Python is not fun, and actually pretty\ncumbersome because you have to do the HTML escaping on your own to keep\nthe application secure.  Because of that Flask configures the\ntemplate engine for you automatically.\nTemplates can be used to generate any type of text file. For web applications, you’ll\nprimarily be generating HTML pages, but you can also generate markdown, plain text for\nemails, and anything else.\nFor a reference to HTML, CSS, and other web APIs, use the\nMDN Web Docs\nTo render a template you can use the\nrender_template()\nmethod.  All you have to do is provide the name of the template and the\nvariables you want to pass to the template engine as keyword arguments.\nHere’s a simple example of how to render a template:\nFlask will look for templates in the\nfolder.  So if your\napplication is a module, this folder is next to that module, if it’s a\npackage it’s actually inside your package:\n: a module:\napplication\n: a package:\napplication\nFor templates you can use the full power of Jinja templates.  Head over\nto the official\nJinja Template Documentation\nfor more information.\nHere is an example template:\nInside templates you also have access to the\nas well as the\nget_flashed_messages()\nTemplates are especially useful if inheritance is used.  If you want to\nknow how that works, see\nTemplate Inheritance\n. Basically\ntemplate inheritance makes it possible to keep certain elements on each\npage (like header, navigation and footer).\nAutomatic escaping is enabled, so if\ncontains HTML it will be escaped\nautomatically.  If you can trust a variable and you know that it will be\nsafe HTML (for example because it came from a module that converts wiki\nmarkup to HTML) you can mark it as safe by using the\nclass or by using the\nfilter in the\ntemplate.  Head over to the Jinja 2 documentation for more examples.\nHere is a basic introduction to how the\nclass works:\nChanged in version 0.5:\nAutoescaping is no longer enabled for all templates.  The following\nextensions for templates trigger autoescaping:\n.  Templates loaded from a string will have\nautoescaping disabled.\nUnsure what that\nobject is? It’s something in which\nyou can store information for your own needs. See the documentation\nUsing SQLite 3 with Flask\nAccessing Request Data\nFor web applications it’s crucial to react to the data a client sends to\nthe server.  In Flask this information is provided by the global\nobject.  If you have some experience with Python\nyou might be wondering how that object can be global and how Flask\nmanages to still be threadsafe.  The answer is context locals:\nContext Locals\nInsider Information\nIf you want to understand how that works and how you can implement\ntests with context locals, read this section, otherwise just skip it.\nCertain objects in Flask are global objects, but not of the usual kind.\nThese objects are actually proxies to objects that are local to a specific\ncontext.  What a mouthful.  But that is actually quite easy to understand.\nImagine the context being the handling thread.  A request comes in and the\nweb server decides to spawn a new thread (or something else, the\nunderlying object is capable of dealing with concurrency systems other\nthan threads).  When Flask starts its internal request handling it\nfigures out that the current thread is the active context and binds the\ncurrent application and the WSGI environments to that context (thread).\nIt does that in an intelligent way so that one application can invoke another\napplication without breaking.\nSo what does this mean to you?  Basically you can completely ignore that\nthis is the case unless you are doing something like unit testing.  You\nwill notice that code which depends on a request object will suddenly break\nbecause there is no request object.  The solution is creating a request\nobject yourself and binding it to the context.  The easiest solution for\nunit testing is to use the\ntest_request_context()\ncontext manager.  In combination with the\nstatement it will bind a\ntest request so that you can interact with it.  Here is an example:\nThe other possibility is passing a whole WSGI environment to the\nrequest_context()\nrequest_context\nThe Request Object\nThe request object is documented in the API section and we will not cover\nit here in detail (see\n). Here is a broad overview of\nsome of the most common operations.  First of all you have to import it from\nThe current request method is available by using the\nattribute.  To access form data (data\ntransmitted in a\nrequest) you can use the\nattribute.  Here is a full example of the two\nattributes mentioned above:\nWhat happens if the key does not exist in the\nattribute?  In that\ncase a special\nis raised.  You can catch it like a\nbut if you don’t do that, a HTTP 400 Bad Request\nerror page is shown instead.  So for many situations you don’t have to\ndeal with that problem.\nTo access parameters submitted in the URL (\n) you can use the\nWe recommend accessing URL parameters with\nor by catching the\nbecause users might change the URL and presenting them a 400\nbad request page in that case is not user friendly.\nFor a full list of methods and attributes of the request object, head over\ndocumentation.\nFile Uploads\nYou can handle uploaded files with Flask easily.  Just make sure not to\nforget to set the\nenctype=\"multipart/form-data\"\nattribute on your HTML\nform, otherwise the browser will not transmit your files at all.\nUploaded files are stored in memory or at a temporary location on the\nfilesystem.  You can access those files by looking at the\nattribute on the request object.  Each\nuploaded file is stored in that dictionary.  It behaves just like a\nstandard Python\nobject, but it also has a\nmethod that\nallows you to store that file on the filesystem of the server.\nHere is a simple example showing how that works:\nIf you want to know how the file was named on the client before it was\nuploaded to your application, you can access the\nHowever please keep in mind that this value can be forged\nso never ever trust that value.  If you want to use the filename\nof the client to store the file on the server, pass it through the\nsecure_filename()\nfunction that\nWerkzeug provides for you:\nFor some better examples, see\nUploading Files\nTo access cookies you can use the\nattribute.  To set cookies you can use the\nmethod of response objects.  The\nattribute of request objects is a\ndictionary with all the cookies the client transmits.  If you want to use\nsessions, do not use the cookies directly but instead use the\nin Flask that add some security on top of cookies for you.\nReading cookies:\nStoring cookies:\nNote that cookies are set on response objects.  Since you normally\njust return strings from the view functions Flask will convert them into\nresponse objects for you.  If you explicitly want to do that you can use\nmake_response()\nfunction and then modify it.\nSometimes you might want to set a cookie at a point where the response\nobject does not exist yet.  This is possible by utilizing the\nDeferred Request Callbacks\nFor this also see\nAbout Responses\nRedirects and Errors\nTo redirect a user to another endpoint, use the\nfunction; to abort a request early with an error code, use the\nThis is a rather pointless example because a user will be redirected from\nthe index to a page they cannot access (401 means access denied) but it\nshows how that works.\nBy default a black and white error page is shown for each error code.  If\nyou want to customize the error page, you can use the\nerrorhandler()\nrender_template()\ncall.  This\ntells Flask that the status code of that page should be 404 which means\nnot found.  By default 200 is assumed which translates to: all went well.\nHandling Application Errors\nfor more details.\nAbout Responses\nThe return value from a view function is automatically converted into\na response object for you. If the return value is a string it’s\nconverted into a response object with the string as response body, a\nstatus code and a\nmimetype. If the\nreturn value is a dict or list,\nis called to produce a\nresponse. The logic that Flask applies to converting return values into\nresponse objects is as follows:\nIf a response object of the correct type is returned it’s directly\nreturned from the view.\nIf it’s a string, a response object is created with that data and\nthe default parameters.\nIf it’s an iterator or generator returning strings or bytes, it is\ntreated as a streaming response.\nIf it’s a dict or list, a response object is created using\nIf a tuple is returned the items in the tuple can provide extra\ninformation. Such tuples have to be in the form\nvalue will override\nthe status code and\ncan be a list or dictionary of\nadditional header values.\nIf none of that works, Flask will assume the return value is a\nvalid WSGI application and convert that into a response object.\nIf you want to get hold of the resulting response object inside the view\nyou can use the\nmake_response()\nImagine you have a view like this:\nYou just need to wrap the return expression with\nmake_response()\nand get the response object to modify it, then\nAPIs with JSON\nA common response format when writing an API is JSON. It’s easy to get\nstarted writing such an API with Flask. If you return a\nfrom a view, it will be converted to a JSON response.\nThis is a shortcut to passing the data to the\nfunction, which will serialize any supported\nJSON data type. That means that all the data in the dict or list must be\nJSON serializable.\nFor complex types such as database models, you’ll want to use a\nserialization library to convert the data to valid JSON types first.\nThere are many serialization libraries and Flask API extensions\nmaintained by the community that support more complex applications.\nIn addition to the request object there is also a second object called\nwhich allows you to store information specific to a\nuser from one request to the next.  This is implemented on top of cookies\nfor you and signs the cookies cryptographically.  What this means is that\nthe user could look at the contents of your cookie but not modify it,\nunless they know the secret key used for signing.\nIn order to use sessions you have to set a secret key.  Here is how\nsessions work:\nHow to generate good secret keys\nA secret key should be as random as possible. Your operating system has\nways to generate pretty random data based on a cryptographic random\ngenerator. Use the following command to quickly generate a value for\nFlask.secret_key\nA note on cookie-based sessions: Flask will take the values you put into the\nsession object and serialize them into a cookie.  If you are finding some\nvalues do not persist across requests, cookies are indeed enabled, and you are\nnot getting a clear error message, check the size of the cookie in your page\nresponses compared to the size supported by web browsers.\nBesides the default client-side based sessions, if you want to handle\nsessions on the server-side instead, there are several\nFlask extensions that support this.\nMessage Flashing\nGood applications and user interfaces are all about feedback.  If the user\ndoes not get enough feedback they will probably end up hating the\napplication.  Flask provides a really simple way to give feedback to a\nuser with the flashing system.  The flashing system basically makes it\npossible to record a message at the end of a request and access it on the next\n(and only the next) request.  This is usually combined with a layout\ntemplate to expose the message.\nTo flash a message use the\nmethod, to get hold of the\nmessages you can use\nget_flashed_messages()\nwhich is also\navailable in the templates. See\nMessage Flashing\nAdded in version 0.3.\nSometimes you might be in a situation where you deal with data that\nshould be correct, but actually is not.  For example you may have\nsome client-side code that sends an HTTP request to the server\nbut it’s obviously malformed.  This might be caused by a user tampering\nwith the data, or the client code failing.  Most of the time it’s okay\nto reply with\nin that situation, but sometimes\nthat won’t do and the code has to continue working.\nYou may still want to log that something fishy happened.  This is where\nloggers come in handy.  As of Flask 0.3 a logger is preconfigured for you\nHere are some example log calls:\nThe attached\nis a standard logging\n, so head over to the official\ndocs for more information.\nHandling Application Errors\nHooking in WSGI Middleware\nTo add WSGI middleware to your Flask application, wrap the application’s\nattribute. For example, to apply Werkzeug’s\nmiddleware for running\nbehind Nginx:\nwerkzeug.middleware.proxy_fix\napp.wsgi_app\npoints at your Flask application, not at the middleware, so you can\ncontinue to use and configure\nUsing Flask Extensions\nExtensions are packages that help you accomplish common tasks. For\nexample, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple\nand easy to use with Flask.\nFor more on Flask extensions, see\nDeploying to a Web Server\nReady to deploy your new Flask app? See\nDeploying to Production",
  "word_count": 3417,
  "key_terms": [
    "return",
    "middleware",
    "method",
    "function",
    "class",
    "import",
    "endpoint",
    "variable",
    "deployment",
    "database"
  ]
}