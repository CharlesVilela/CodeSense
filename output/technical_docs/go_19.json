{
  "metadata": {
    "title": "The Go Programming Language Specification",
    "url": "https://go.dev/ref/spec",
    "technology": "go",
    "category": "programming_languages",
    "english_level": "B1",
    "professional_context": "development",
    "content_type": "technical_documentation",
    "last_updated": "1761765723.1530764"
  },
  "content": "The Go Programming Language Specification\nLanguage version go1.25 (Aug 12, 2025)\nIntroduction\nThis is the reference manual for the Go programming language.\nFor more information and other documents, see\nGo is a general-purpose language designed with systems programming\nin mind. It is strongly typed and garbage-collected and has explicit\nsupport for concurrent programming.  Programs are constructed from\n, whose properties allow efficient management of\ndependencies.\nThe syntax is compact and simple to parse, allowing for easy analysis\nby automatic tools such as integrated development environments.\nThe syntax is specified using a\nof Extended Backus-Naur Form (EBNF):\nProductions are expressions constructed from terms and the following\noperators, in increasing precedence:\n|   alternation\n()  grouping\n[]  option (0 or 1 times)\n{}  repetition (0 to n times)\nLowercase production names are used to identify lexical (terminal) tokens.\nNon-terminals are in CamelCase. Lexical tokens are enclosed in\ndouble quotes\nor back quotes\nrepresents the set of characters from\nas alternatives. The horizontal\nis also used elsewhere in the spec to informally denote various\nenumerations or code snippets that are not further specified. The character\n(as opposed to the three characters\n) is not a token of the Go\nA link of the form [\n] indicates that a described\nlanguage feature (or some aspect of it) was changed or added with language version 1.xx and\nthus requires at minimum that language version to build.\nFor details, see the\nlinked section\nSource code representation\nSource code is Unicode text encoded in\n. The text is not\ncanonicalized, so a single accented code point is distinct from the\nsame character constructed from combining an accent and a letter;\nthose are treated as two code points.  For simplicity, this document\nwill use the unqualified term\nto refer to a Unicode code point\nin the source text.\nEach code point is distinct; for instance, uppercase and lowercase letters\nare different characters.\nImplementation restriction: For compatibility with other tools, a\ncompiler may disallow the NUL character (U+0000) in the source text.\nImplementation restriction: For compatibility with other tools, a\ncompiler may ignore a UTF-8-encoded byte order mark\n(U+FEFF) if it is the first Unicode code point in the source text.\nA byte order mark may be disallowed anywhere else in the source.\nThe following terms are used to denote specific Unicode character categories:\nThe Unicode Standard 8.0\nSection 4.5 \"General Category\" defines a set of character categories.\nGo treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo\nas Unicode letters, and those in the Number category Nd as Unicode digits.\nLetters and digits\nThe underscore character\n(U+005F) is considered a lowercase letter.\nLexical elements\nComments serve as program documentation. There are two forms:\nLine comments\nstart with the character sequence\nand stop at the end of the line.\nGeneral comments\nstart with the character sequence\nand stop with the first subsequent character sequence\nA comment cannot start inside a\nstring literal\n, or inside a comment.\nA general comment containing no newlines acts like a space.\nAny other comment acts like a newline.\nTokens form the vocabulary of the Go language.\nThere are four classes:\nidentifiers\nand punctuation\nWhite space\n, formed from\nspaces (U+0020), horizontal tabs (U+0009),\ncarriage returns (U+000D), and newlines (U+000A),\nis ignored except as it separates tokens\nthat would otherwise combine into a single token. Also, a newline or end of file\nmay trigger the insertion of a\nWhile breaking the input into tokens,\nthe next token is the longest sequence of characters that form a\nvalid token.\nThe formal syntax uses semicolons\nas terminators in\na number of productions. Go programs may omit most of these semicolons\nusing the following two rules:\nWhen the input is broken into tokens, a semicolon is automatically inserted\ninto the token stream immediately after a line's final token if that token is\nfloating-point\nfallthrough\noperators and punctuation\nTo allow complex statements to occupy a single line, a semicolon\nmay be omitted before a closing\nTo reflect idiomatic use, code examples in this document elide semicolons\nusing these rules.\nIdentifiers\nIdentifiers name program entities such as variables and types.\nAn identifier is a sequence of one or more letters and digits.\nThe first character in an identifier must be a letter.\nunicode_digit\nThisVariableIsExported\nSome identifiers are\npredeclared\nThe following keywords are reserved and may not be used as identifiers.\nOperators and punctuation\nThe following character sequences represent\nassignment operators\n) and punctuation\nInteger literals\nAn integer literal is a sequence of digits representing an\ninteger constant\nAn optional prefix sets a non-decimal base:\nfor binary,\nfor hexadecimal\nis considered a decimal zero.\nIn hexadecimal literals, letters\nrepresent values 10 through 15.\nFor readability, an underscore character\nmay appear after\na base prefix or between successive digits; such underscores do not change\nthe literal's value.\nFloating-point literals\nA floating-point literal is a decimal or hexadecimal representation of a\nfloating-point constant\nA decimal floating-point literal consists of an integer part (decimal digits),\na decimal point, a fractional part (decimal digits), and an exponent part\nfollowed by an optional sign and decimal digits).\nOne of the integer part or the fractional part may be elided; one of the decimal point\nor the exponent part may be elided.\nAn exponent value exp scales the mantissa (integer and fractional part) by 10\nA hexadecimal floating-point literal consists of a\nprefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits),\nand an exponent part (\nfollowed by an optional sign and decimal digits).\nOne of the integer part or the fractional part may be elided; the radix point may be elided as well,\nbut the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.)\nAn exponent value exp scales the mantissa (integer and fractional part) by 2\nFor readability, an underscore character\nmay appear after\na base prefix or between successive digits; such underscores do not change\nthe literal value.\nImaginary literals\nAn imaginary literal represents the imaginary part of a\ncomplex constant\nIt consists of an\nfloating-point\nfollowed by the lowercase letter\nThe value of an imaginary literal is the value of the respective\ninteger or floating-point literal multiplied by the imaginary unit\nimaginary_lit\ndecimal_digits\nFor backward compatibility, an imaginary literal's integer part consisting\nentirely of decimal digits (and possibly underscores) is considered a decimal\ninteger, even if it starts with a leading\nRune literals\nA rune literal represents a\nrune constant\nan integer value identifying a Unicode code point.\nA rune literal is expressed as one or more characters enclosed in single quotes,\nWithin the quotes, any character may appear except newline and unescaped single\nquote. A single quoted character represents the Unicode value\nof the character itself,\nwhile multi-character sequences beginning with a backslash encode\nvalues in various formats.\nThe simplest form represents the single character within the quotes;\nsince Go source text is Unicode characters encoded in UTF-8, multiple\nUTF-8-encoded bytes may represent a single integer value.  For\ninstance, the literal\nholds a single byte representing\n, Unicode U+0061, value\nholds two bytes (\n) representing\n-dieresis, U+00E4, value\nSeveral backslash escapes allow arbitrary values to be encoded as\nASCII text.  There are four ways to represent the integer value\nas a numeric constant:\nfollowed by exactly two hexadecimal\nfollowed by exactly four hexadecimal digits;\nfollowed by exactly eight hexadecimal digits, and a\nplain backslash\nfollowed by exactly three octal digits.\nIn each case the value of the literal is the value represented by\nthe digits in the corresponding base.\nAlthough these representations all result in an integer, they have\ndifferent valid ranges.  Octal escapes must represent a value between\n0 and 255 inclusive.  Hexadecimal escapes satisfy this condition\nby construction. The escapes\nrepresent Unicode code points so within them some values are illegal,\nin particular those above\nand surrogate halves.\nAfter a backslash, certain single-character escapes represent special values:\nAn unrecognized character following a backslash in a rune literal is illegal.\nString literals\nA string literal represents a\nstring constant\nobtained from concatenating a sequence of characters. There are two forms:\nraw string literals and interpreted string literals.\nRaw string literals are character sequences between back quotes, as in\n.  Within the quotes, any character may appear except\nback quote. The value of a raw string literal is the\nstring composed of the uninterpreted (implicitly UTF-8-encoded) characters\nbetween the quotes;\nin particular, backslashes have no special meaning and the string may\ncontain newlines.\nCarriage return characters ('\\r') inside raw string literals\nare discarded from the raw string value.\nInterpreted string literals are character sequences between double\nquotes, as in\nWithin the quotes, any character may appear except newline and unescaped double quote.\nThe text between the quotes forms the\nvalue of the literal, with backslash escapes interpreted as they\nrune literals\n(except that\nis illegal and\nis legal), with the same restrictions.\nThe three-digit octal (\nand two-digit hexadecimal (\n) escapes represent individual\nof the resulting string; all other escapes represent\nthe (possibly multi-byte) UTF-8 encoding of individual\nThus inside a string literal\na single byte of value\n=255, while\nthe two bytes\nof the UTF-8 encoding of character\nThese examples all represent the same string:\nIf the source code represents a character as two code points, such as\na combining form involving an accent and a letter, the result will be\nan error if placed in a rune literal (it is not a single code\npoint), and will appear as two code points if placed in a string\nboolean constants\nrune constants\ninteger constants\nfloating-point constants\ncomplex constants\nstring constants\n. Rune, integer, floating-point,\nand complex constants are\ncollectively called\nnumeric constants\nA constant value is represented by a\nfloating-point\nan identifier denoting a constant,\nconstant expression\nwith a result that is a constant, or\nthe result value of some built-in functions such as\napplied to constant arguments,\nunsafe.Sizeof\ncertain values\nsome expressions\napplied to a complex constant\napplied to numeric constants.\nThe boolean truth values are represented by the predeclared constants\n. The predeclared identifier\ndenotes an integer constant.\nIn general, complex constants are a form of\nconstant expression\nand are discussed in that section.\nNumeric constants represent exact values of arbitrary precision and do not overflow.\nConsequently, there are no constants denoting the IEEE 754 negative zero, infinity,\nand not-a-number values.\nConstants may be\nLiteral constants,\nand certain\nconstant expressions\ncontaining only untyped constant operands are untyped.\nA constant may be given a type explicitly by a\nconstant declaration\n, or implicitly when used in a\nvariable declaration\nassignment statement\noperand in an\nIt is an error if the constant value\nrepresented\nas a value of the respective type.\nIf the type is a type parameter, the constant is converted into a non-constant\nvalue of the type parameter.\nAn untyped constant has a\ndefault type\nwhich is the type to which the\nconstant is implicitly converted in contexts where a typed value is required,\nfor instance, in a\nshort variable declaration\nwhere there is no explicit type.\nThe default type of an untyped constant is\nrespectively, depending on whether it is a boolean, rune, integer, floating-point,\ncomplex, or string constant.\nImplementation restriction: Although numeric constants have arbitrary\nprecision in the language, a compiler may implement them using an\ninternal representation with limited precision.  That said, every\nimplementation must:\nRepresent integer constants with at least 256 bits.\nRepresent floating-point constants, including the parts of\na complex constant, with a mantissa of at least 256 bits\nand a signed binary exponent of at least 16 bits.\nGive an error if unable to represent an integer constant\nGive an error if unable to represent a floating-point or\ncomplex constant due to overflow.\nRound to the nearest representable constant if unable to\nrepresent a floating-point or complex constant due to limits\non precision.\nThese requirements apply both to literal constants and to the result\nof evaluating\nexpressions\nA variable is a storage location for holding a\nThe set of permissible values is determined by the\nvariable declaration\nor, for function parameters and results, the signature\nfunction declaration\nfunction literal\nstorage for a named variable.\nCalling the built-in function\nor taking the address of a\ncomposite literal\nallocates storage for a variable at run time.\nSuch an anonymous variable is referred to via a (possibly implicit)\npointer indirection\nvariables of\ntypes have elements and fields that may\nindividually. Each such element\nacts like a variable.\nstatic type\n) of a variable is the\ntype given in its declaration, the type provided in the\ncall or composite literal, or the type of\nan element of a structured variable.\nVariables of interface type also have a distinct\ndynamic type\nwhich is the (non-interface) type of the value assigned to the variable at run time\n(unless the value is the predeclared identifier\nwhich has no type).\nThe dynamic type may vary during execution but values stored in interface\nvariables are always\nto the static type of the variable.\nA variable's value is retrieved by referring to the variable in an\n; it is the most recent value\nto the variable.\nIf a variable has not yet been assigned a value, its value is the\nfor its type.\nA type determines a set of values together with operations and methods specific\nto those values. A type may be denoted by a\n, if it has one, which must be\nfollowed by\ntype arguments\nif the type is generic.\nA type may also be specified using a\ntype literal\n, which composes a type\nfrom existing types.\nThe language\npredeclares\ncertain type names.\nOthers are introduced with\ntype declarations\ntype parameter lists\nComposite types\n—array, struct, pointer, function,\ninterface, slice, map, and channel types—may be constructed using\ntype literals.\nPredeclared types, defined types, and type parameters are called\nnamed types\nAn alias denotes a named type if the type given in the alias declaration is a named type.\nBoolean types\nboolean type\nrepresents the set of Boolean truth values\ndenoted by the predeclared constants\n. The predeclared boolean type is\ndefined type\nNumeric types\nfloating-point\nrepresents the set of integer, floating-point, or complex values, respectively.\nThey are collectively called\nnumeric types\nThe predeclared architecture-independent numeric types are:\nThe value of an\n-bit integer is\nbits wide and represented using\ntwo's complement arithmetic\nThere is also a set of predeclared integer types with implementation-specific sizes:\nTo avoid portability issues all numeric types are\nand thus distinct except\n, which is an\n, which is an alias for\nExplicit conversions\nare required when different numeric types are mixed in an expression\nor assignment. For instance,\nare not the same type even though they may have the same size on a\nparticular architecture.\nString types\nstring type\nrepresents the set of string values.\nA string value is a (possibly empty) sequence of bytes.\nThe number of bytes is called the length of the string and is never negative.\nStrings are immutable: once created,\nit is impossible to change the contents of a string.\nThe predeclared string type is\ndefined type\nThe length of a string\ncan be discovered using\nthe built-in function\nThe length is a compile-time constant if the string is a constant.\nA string's bytes can be accessed by integer\nIt is illegal to take the address of such an element; if\n'th byte of a\nis invalid.\nArray types\nAn array is a numbered sequence of elements of a single\ntype, called the element type.\nThe number of elements is called the length of the array and is never negative.\nArrayLength\nElementType\nArrayLength\nElementType\nThe length is part of the array's type; it must evaluate to a\nnon-negative\nrepresentable\nThe length of array\ncan be discovered\nusing the built-in function\nThe elements can be addressed by integer\nArray types are always one-dimensional but may be composed to form\nmulti-dimensional types.\nAn array type\nmay not have an element of type\nor of a type containing\nas a component, directly or indirectly,\nif those containing types are only array or struct types.\nSlice types\nA slice is a descriptor for a contiguous segment of an\nunderlying array\nprovides access to a numbered sequence of elements from that array.\nA slice type denotes the set of all slices of arrays of its element type.\nThe number of elements is called the length of the slice and is never negative.\nThe value of an uninitialized slice is\nElementType\nThe length of a slice\ncan be discovered by the built-in function\n; unlike with arrays it may change during\nexecution.  The elements can be addressed by integer\n.  The slice index of a\ngiven element may be less than the index of the same element in the\nunderlying array.\nA slice, once initialized, is always associated with an underlying\narray that holds its elements.  A slice therefore shares storage\nwith its array and with other slices of the same array; by contrast,\ndistinct arrays always represent distinct storage.\nThe array underlying a slice may extend past the end of the slice.\nis a measure of that extent: it is the sum of\nthe length of the slice and the length of the array beyond the slice;\na slice of length up to that capacity can be created by\na new one from the original slice.\nThe capacity of a slice\ncan be discovered using the\nbuilt-in function\nA new, initialized slice value for a given element type\nmade using the built-in function\nwhich takes a slice type\nand parameters specifying the length and optionally the capacity.\nA slice created with\nalways allocates a new, hidden array\nto which the returned slice value refers. That is, executing\nmake([]T, length, capacity)\nproduces the same slice as allocating an array and\nit, so these two expressions are equivalent:\nmake([]int, 50, 100)\nnew([100]int)[0:50]\nLike arrays, slices are always one-dimensional but may be composed to construct\nhigher-dimensional objects.\nWith arrays of arrays, the inner arrays are, by construction, always the same length;\nhowever with slices of slices (or arrays of slices), the inner lengths may vary dynamically.\nMoreover, the inner slices must be initialized individually.\nStruct types\nA struct is a sequence of named elements, called fields, each of which has a\nname and a type. Field names may be specified explicitly (IdentifierList) or\nimplicitly (EmbeddedField).\nWithin a struct, non-\nfield names must\nA field declared with a type but no explicit field name is called an\nembedded field\nAn embedded field must be specified as\na type name\nor as a pointer to a non-interface type name\nitself may not be\na pointer type or type parameter. The unqualified type name acts as the field name.\nThe following declaration is illegal because field names must be unique\nin a struct type:\nembedded field in a struct\nthat denotes\nthat field or method\nPromoted fields act like ordinary fields\nof a struct except that they cannot be used as field names in\ncomposite literals\nof the struct.\nGiven a struct type\nand a type name\n, promoted methods are included in the method set of the struct as follows:\ncontains an embedded field\nmethod sets\nboth include promoted methods with receiver\n. The method set of\nincludes promoted methods with receiver\ncontains an embedded field\nthe method sets of\ninclude promoted methods with receiver\nA field declaration may be followed by an optional string literal\nwhich becomes an attribute for all the fields in the corresponding\nfield declaration. An empty tag string is equivalent to an absent tag.\nThe tags are made visible through a\nreflection interface\nand take part in\ntype identity\nfor structs\nbut are otherwise ignored.\nA struct type\nmay not contain a field of type\nor of a type containing\nas a component, directly or indirectly,\nif those containing types are only array or struct types.\nPointer types\nA pointer type denotes the set of all pointers to\ntype, called the\nof the pointer.\nof an uninitialized pointer is\nPointerType\nFunction types\nA function type denotes the set of all functions with the same parameter and result types.\nof an uninitialized variable of function\nWithin a list of parameters or results, the names (IdentifierList)\nmust either all be present or all be absent. If present, each name\nstands for one item (parameter or result) of the specified type and\nnames in the signature\nIf absent, each type stands for one item of that type.\nParameter and result\nlists are always parenthesized except that if there is exactly\none unnamed result it may be written as an unparenthesized type.\nThe final incoming parameter in a function signature may have\na type prefixed with\nA function with such a parameter is called\nmay be invoked with zero or more arguments for that parameter.\nInterface types\nAn interface type defines a\nA variable of interface type can store a value of any type that is in the type\nset of the interface. Such a type is said to\nimplement the interface\nof an uninitialized variable of\ninterface type is\nAn interface type is specified by a list of\ninterface elements\nAn interface element is either a\ntype element\nwhere a type element is a union of one or more\nA type term is either a single type or a single underlying type.\nBasic interfaces\nIn its most basic form an interface specifies a (possibly empty) list of methods.\nThe type set defined by such an interface is the set of types which implement all of\nthose methods, and the corresponding\nexactly of the methods specified by the interface.\nInterfaces whose type sets can be defined entirely by a list of methods are called\nbasic interfaces.\nThe name of each explicitly specified method must be\nMore than one type may implement an interface.\nFor instance, if two types\nhave the method set\nstands for either\ninterface is implemented by both\n, regardless of what other methods\nmay have or share.\nEvery type that is a member of the type set of an interface implements that interface.\nAny given type may implement several distinct interfaces.\nFor instance, all types implement the\nempty interface\nwhich stands for the set\nof all (non-interface) types:\ninterface{}\nFor convenience, the predeclared type\nis an alias for the empty interface.\nSimilarly, consider this interface specification,\nwhich appears within a\ntype declaration\nto define an interface called\ntype Locker interface {\nalso implement\nfunc (p T) Lock() { … }\nfunc (p T) Unlock() { … }\nthey implement the\ninterface as well\nEmbedded interfaces\nIn a slightly more general form\nan interface\nmay use a (possibly qualified) interface type\nas an interface element. This is called\nThe type set of\nintersection\nof the type sets\n's explicitly declared methods and the type sets\n’s embedded interfaces.\nIn other words, the type set of\nis the set of all types that implement all the\nexplicitly declared methods of\nand also all the methods of\nWhen embedding interfaces, methods with the\nsignatures.\nGeneral interfaces\nIn their most general form, an interface element may also be an arbitrary type term\n, or a term of the form\nspecifying the underlying type\nor a union of terms\nTogether with method specifications, these elements enable the precise\ndefinition of an interface's type set as follows:\nThe type set of the empty interface is the set of all non-interface types.\nThe type set of a non-empty interface is the intersection of the type sets\nof its interface elements.\nThe type set of a method specification is the set of all non-interface types\nwhose method sets include that method.\nThe type set of a non-interface type term is the set consisting\nof just that type.\nThe type set of a term of the form\nis the set of all types whose underlying type is\nThe type set of a\nis the union of the type sets of the terms.\nThe quantification \"the set of all non-interface types\" refers not just to all (non-interface)\ntypes declared in the program at hand, but all possible types in all possible programs, and\nhence is infinite.\nSimilarly, given the set of all non-interface types that implement a particular method, the\nintersection of the method sets of those types will contain exactly that method, even if all\ntypes in the program at hand always pair that method with another method.\nBy construction, an interface's type set never contains an interface type.\nIn a term of the form\n, the underlying type of\nmust be itself, and\ncannot be an interface.\nUnion elements denote unions of type sets:\nin a term of the form\ntype parameter\n, and the type sets of all\nnon-interface terms must be pairwise disjoint (the pairwise intersection of the type sets must be empty).\nGiven a type parameter\nImplementation restriction:\nA union (with more than one term) cannot contain the\npredeclared identifier\nor interfaces that specify methods, or embed\nor interfaces\nthat specify methods.\nInterfaces that are not\nmay only be used as type\nconstraints, or as elements of other interfaces used as constraints.\nThey cannot be the types of values or variables, or components of other,\nnon-interface types.\nAn interface type\nmay not embed a type element\nthat is, contains, or embeds\n, directly or indirectly.\nImplementing an interface\nimplements an interface\nis not an interface and is an element of the type set of\nis an interface and the type set of\nis a subset of the\ntype set of\nA value of type\nimplements an interface if\nimplements the interface.\nA map is an unordered group of elements of one type, called the\nelement type, indexed by a set of unique\nof another type,\ncalled the key type.\nof an uninitialized map is\n= \"map\" \"[\"\nElementType\ncomparison operators\nmust be fully defined\nfor operands of the key type; thus the key type must not be a function, map, or\nIf the key type is an interface type, these\ncomparison operators must be defined for the dynamic key values;\nfailure will cause a\nrun-time panic\nmap[string]int\nmap[*T]struct{ x, y float64 }\nmap[string]interface{}\nThe number of map elements is called its length.\n, it can be discovered using the\nbuilt-in function\nand may change during execution. Elements may be added during execution\nassignments\nand retrieved with\nindex expressions\n; they may be removed with the\nbuilt-in function.\nA new, empty map value is made using the built-in\nwhich takes the map type and an optional capacity hint as arguments:\nmake(map[string]int)\nmake(map[string]int, 100)\nThe initial capacity does not bound its size:\nmaps grow to accommodate the number of items\nstored in them, with the exception of\nmap is equivalent to an empty map except that no elements\nmay be added.\nChannel types\nA channel provides a mechanism for\nconcurrently executing functions\nto communicate by\nvalues of a specified element type.\nof an uninitialized channel is\nChannelType\n= ( \"chan\" | \"chan\" \"<-\" | \"<-\" \"chan\" )\nElementType\nThe optional\noperator specifies the channel\n. If a direction is given, the channel is\ndirectional\notherwise it is\nbidirectional\nA channel may be constrained only to send or only to receive by\noperator associates with the leftmost\nA new, initialized channel\nvalue can be made using the built-in function\nwhich takes the channel type and an optional\nas arguments:\nmake(chan int, 100)\nThe capacity, in number of elements, sets the size of the buffer in the channel.\nIf the capacity is zero or absent, the channel is unbuffered and communication\nsucceeds only when both a sender and receiver are ready. Otherwise, the channel\nis buffered and communication succeeds without blocking if the buffer\nis not full (sends) or not empty (receives).\nchannel is never ready for communication.\nA channel may be closed with the built-in function\nThe multi-valued assignment form of the\nreceive operator\nreports whether a received value was sent before\nthe channel was closed.\nA single channel may be used in\nsend statements\nreceive operations\nand calls to the built-in functions\nby any number of goroutines without further synchronization.\nChannels act as first-in-first-out queues.\nFor example, if one goroutine sends values on a channel\nand a second goroutine receives them, the values are\nreceived in the order sent.\nProperties of types and values\nRepresentation of values\nValues of predeclared types (see below for the interfaces\n), arrays, and structs are self-contained:\nEach such value contains a complete copy of all its data,\nof such types store the entire value.\nFor instance, an array variable provides the storage (the variables)\nfor all elements of the array.\nThe respective\nzero values\nare specific to the\nvalue's types; they are never\nNon-nil pointer, function, slice, map, and channel values contain references\nto underlying data which may be shared by multiple values:\nA pointer value is a reference to the variable holding\nthe pointer base type value.\nA function value contains references to the (possibly\nand enclosed variables.\nA slice value contains the slice length, capacity, and\na reference to its\nunderlying array\nA map or channel value is a reference to the implementation-specific\ndata structure of the map or channel.\nAn interface value may be self-contained or contain references to underlying data\ndepending on the interface's\ndynamic type\nThe predeclared identifier\nis the zero value for types whose values\ncan contain references.\nWhen multiple values share underlying data, changing one value may change another.\nFor instance, changing an element of a\nwill change\nthat element in the underlying array for all slices that share the array.\nUnderlying types\nunderlying type\nis one of the predeclared boolean, numeric, or string types, or a type literal,\nthe corresponding underlying type is\n's underlying type is the underlying type of the\ntype to which\nrefers in its declaration.\nFor a type parameter that is the underlying type of its\ntype constraint\n, which is always an interface.\nThe underlying type of\nThe underlying type of\nThe underlying type of\ninterface{}\nType identity\nTwo types are either\n(\"the same\") or\nis always different from any other type.\nOtherwise, two types are identical if their\ntype literals are\nstructurally equivalent; that is, they have the same literal structure and corresponding\ncomponents have identical types. In detail:\nTwo array types are identical if they have identical element types and\nthe same array length.\nTwo slice types are identical if they have identical element types.\nTwo struct types are identical if they have the same sequence of fields,\nand if corresponding pairs of fields have the same names, identical types,\nand identical tags, and are either both embedded or both not embedded.\nNon-exported\nfield names from different\npackages are always different.\nTwo pointer types are identical if they have identical base types.\nTwo function types are identical if they have the same number of parameters\nand result values, corresponding parameter and result types are\nidentical, and either both functions are variadic or neither is.\nParameter and result names are not required to match.\nTwo interface types are identical if they define the same type set.\nTwo map types are identical if they have identical key and element types.\nTwo channel types are identical if they have identical element types and\nthe same direction.\ninstantiated\ntypes are identical if\ntheir defined types and all type arguments are identical.\nGiven the declarations\nthese types are identical:\nare different because they are new types\ncreated by distinct\ntype definitions\nfunc(int, float64) *B0\nfunc(x int, y float64) *[]string\nare different because\nis different from\nare different because they are different\ntype parameters.\nD0[int, string]\nstruct{ x int; y string }\ndifferent because the former is an\ninstantiated\ndefined type while the latter is a type literal\n(but they are still\nAssignability\nis assignable to\n\") if one of the following conditions applies:\nare identical.\nhave identical\nunderlying types\nbut are not type parameters and at least one of\nare channel types with\nidentical element types,\nis a bidirectional channel,\nand at least one of\nis an interface type, but not a type parameter, and\nis the predeclared identifier\nis a pointer, function, slice, map, channel, or interface type,\nbut not a type parameter.\nis an untyped\nrepresentable\nby a value of type\nAdditionally, if\nare type parameters,\nis assignable to a variable of type\nif one of the following conditions applies:\nis the predeclared identifier\na type parameter, and\nis assignable to each type in\n's type set.\na type parameter, and\nis assignable to each type in\n's type set.\nis a type parameter and\nis not a named type,\nand values of each type in\n's type set are assignable\nRepresentability\nrepresentable\nby a value of type\ntype parameter\nif one of the following conditions applies:\nis in the set of values\nfloating-point type\ncan be rounded to\nprecision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE\nnegative zero further simplified to an unsigned zero. Note that constant values never result\nin an IEEE negative zero, NaN, or infinity.\nis a complex type, and\nare representable by values of\n's component type (\nis a type parameter,\nis representable by a value of type\nis representable\nby a value of each type in\n's type set.\nMethod sets\nof a type determines the methods that can be\nof that type.\nEvery type has a (possibly empty) method set associated with it:\nThe method set of a\ndefined type\nconsists of all\ndeclared with receiver type\nThe method set of a pointer to a defined type\nis neither a pointer nor an interface)\nis the set of all methods declared with receiver\nThe method set of an\ninterface type\nis the intersection\nof the method sets of each type in the interface's\n(the resulting method set is usually just the set of declared methods in the interface).\nFurther rules apply to structs (and pointer to structs) containing embedded fields,\nas described in the section on\nstruct types\nAny other type has an empty method set.\nIn a method set, each method must have a\nmethod name\nis a possibly empty sequence of declarations and statements\nwithin matching brace brackets.\nStatementList\nStatementList\nIn addition to explicit blocks in the source code, there are implicit blocks:\nuniverse block\nencompasses all Go source text.\npackage block\ncontaining all\nGo source text for that package.\nEach file has a\ncontaining all Go source text\nin that file.\nstatement is considered to be in its own implicit block.\nEach clause in a\nacts as an implicit block.\nBlocks nest and influence\nDeclarations and scope\ndeclaration\nbinds a non-\nidentifier to a\ntype parameter\nEvery identifier in a program must be declared.\nNo identifier may be declared twice in the same block, and\nno identifier may be declared in both the file and package block.\nblank identifier\nmay be used like any other identifier\nin a declaration, but it does not introduce a binding and thus is not declared.\nIn the package block, the identifier\nmay only be used for\ndeclarations,\nand like the blank identifier it does not introduce a new binding.\nof a declared identifier is the extent of source text in which\nthe identifier denotes the specified constant, type, variable, function, label, or package.\nGo is lexically scoped using\nThe scope of a\npredeclared identifier\nis the universe block.\nThe scope of an identifier denoting a constant, type, variable,\nor function (but not method) declared at top level (outside any\nfunction) is the package block.\nThe scope of the package name of an imported package is the file block\nof the file containing the import declaration.\nThe scope of an identifier denoting a method receiver, function parameter,\nor result variable is the function body.\nThe scope of an identifier denoting a type parameter of a function\nor declared by a method receiver begins after the name of the function\nand ends at the end of the function body.\nThe scope of an identifier denoting a type parameter of a type\nbegins after the name of the type and ends at the end\nof the TypeSpec.\nThe scope of a constant or variable identifier declared\ninside a function begins at the end of the ConstSpec or VarSpec\n(ShortVarDecl for short variable declarations)\nand ends at the end of the innermost containing block.\nThe scope of a type identifier declared inside a function\nbegins at the identifier in the TypeSpec\nand ends at the end of the innermost containing block.\nAn identifier declared in a block may be redeclared in an inner block.\nWhile the identifier of the inner declaration is in scope, it denotes\nthe entity declared by the inner declaration.\npackage clause\nis not a declaration; the package name\ndoes not appear in any scope. Its purpose is to identify the files belonging\nto the same\nand to specify the default package name for import\ndeclarations.\nLabel scopes\nLabels are declared by\nlabeled statements\nused in the\nstatements.\nIt is illegal to define a label that is never used.\nIn contrast to other identifiers, labels are not block scoped and do\nnot conflict with identifiers that are not labels. The scope of a label\nis the body of the function in which it is declared and excludes\nthe body of any nested function.\nBlank identifier\nblank identifier\nis represented by the underscore character\nIt serves as an anonymous placeholder instead of a regular (non-blank)\nidentifier and has special meaning in\ndeclarations\nassignment statements\nPredeclared identifiers\nThe following identifiers are implicitly declared in the\nuniverse block\nExported identifiers\nAn identifier may be\nto permit access to it from another package.\nAn identifier is exported if both:\nthe first character of the identifier's name is a Unicode uppercase\nletter (Unicode character category Lu); and\nthe identifier is declared in the\npackage block\nmethod name\nAll other identifiers are not exported.\nUniqueness of identifiers\nGiven a set of identifiers, an identifier is called\nfrom every other in the set.\nTwo identifiers are different if they are spelled differently, or if they\nappear in different\nand are not\n. Otherwise, they are the same.\nConstant declarations\nA constant declaration binds a list of identifiers (the names of\nthe constants) to the values of a list of\nconstant expressions\nThe number of identifiers must be equal\nto the number of expressions, and the\nth identifier on\nthe left is bound to the value of the\nth expression on the\nIf the type is present, all constants take the type specified, and\nthe expressions must be\nto that type,\nwhich must not be a type parameter.\nIf the type is omitted, the constants take the\nindividual types of the corresponding expressions.\nIf the expression values are untyped\nthe declared constants remain untyped and the constant identifiers\ndenote the constant values. For instance, if the expression is a\nfloating-point literal, the constant identifier denotes a floating-point\nconstant, even if the literal's fractional part is zero.\nWithin a parenthesized\ndeclaration list the\nexpression list may be omitted from any but the first ConstSpec.\nSuch an empty list is equivalent to the textual substitution of the\nfirst preceding non-empty expression list and its type if any.\nOmitting the list of expressions is therefore equivalent to\nrepeating the previous list.  The number of identifiers must be equal\nto the number of expressions in the previous list.\nTogether with the\nconstant generator\nthis mechanism permits light-weight declaration of sequential values:\nconstant declaration\n, the predeclared identifier\nrepresents successive untyped integer\n. Its value is the index of the respective\nin that constant declaration, starting at zero.\nIt can be used to construct a set of related constants:\nBy definition, multiple uses of\nin the same ConstSpec all have the same value:\nThis last example exploits the\nimplicit repetition\nof the last non-empty expression list.\nType declarations\nA type declaration binds an identifier, the\nType declarations come in two forms: alias declarations and type definitions.\n\";\" } \")\" ) .\nAlias declarations\nAn alias declaration binds an identifier to the given type\nTypeParameters\nthe identifier, it serves as an\nfor the given type.\nIf the alias declaration specifies\ntype parameters\n], the type name denotes a\ngeneric alias\nGeneric aliases must be\ninstantiated\ntype set[P comparable] = map[P]bool\nIn an alias declaration the given type cannot be a type parameter.\ntype A[P any] = P    // illegal: P is a type parameter\nType definitions\nA type definition creates a new, distinct type with the same\nunderlying type\nand operations as the given type\nand binds an identifier, the\nTypeParameters\nThe new type is called a\ndefined type\nfrom any other type,\nincluding the type it is created from.\nA defined type may have\nassociated with it.\nIt does not inherit any methods bound to the given type,\nof an interface type or of elements of a composite type remains unchanged:\nType definitions may be used to define different boolean, numeric,\nor string types and associate methods with them:\nIf the type definition specifies\ntype parameters\nthe type name denotes a\ngeneric type\nGeneric types must be\ninstantiated\ntype List[T any] struct {\nnext  *List[T]\nIn a type definition the given type cannot be a type parameter.\nA generic type may also have\nassociated with it.\nIn this case, the method receivers must declare the same number of type parameters as\npresent in the generic type definition.\nType parameter declarations\nA type parameter list declares the\ntype parameters\nof a generic function or type declaration.\nThe type parameter list looks like an ordinary\nfunction parameter list\nexcept that the type parameter names must all be present and the list is enclosed\nin square brackets rather than parentheses\nAll non-blank names in the list must be unique.\nEach name declares a type parameter, which is a new and different\nthat acts as a placeholder for an (as of yet) unknown type in the declaration.\nThe type parameter is replaced with a\ntype argument\ninstantiation\nof the generic function or type.\n[S interface{ ~[]byte|string }]\n[S ~[]E, E any]\n[P Constraint[int]]\nJust as each ordinary function parameter has a parameter type, each type parameter\nhas a corresponding (meta-)type which is called its\ntype constraint\nA parsing ambiguity arises when the type parameter list for a generic type\ndeclares a single type parameter\nwith a constraint\nsuch that the text\nforms a valid expression:\ntype T[P *C] …\ntype T[P (C)] …\ntype T[P *C|Q] …\nIn these rare cases, the type parameter list is indistinguishable from an\nexpression and the type declaration is parsed as an array type declaration.\nTo resolve the ambiguity, embed the constraint in an\nor use a trailing comma:\ntype T[P interface{*C}] …\ntype T[P *C,] …\nType parameters may also be declared by the receiver specification\nmethod declaration\nwith a generic type.\nWithin a type parameter list of a generic type\n, a type constraint\nmay not (directly, or indirectly through the type parameter list of another\ngeneric type) refer to\nType constraints\ntype constraint\nthat defines the\nset of permissible type arguments for the respective type parameter and controls the\noperations supported by values of that type parameter\nTypeConstraint\nIf the constraint is an interface literal of the form\ninterface{E}\nis an embedded\ntype element\n(not a method), in a type parameter list\nthe enclosing\ninterface{ … }\nmay be omitted for convenience:\npredeclared\ninterface type\ndenotes the set of all non-interface types that are\nstrictly comparable\nEven though interfaces that are not type parameters are\nthey are not strictly comparable and therefore they do not implement\nHowever, they\ninterface and interfaces that (directly or indirectly) embed\nmay only be used as type constraints. They cannot be the types of\nvalues or variables, or components of other, non-interface types.\nSatisfying a type constraint\nA type argument\na type constraint\nis an element of the type set defined by\n; in other words,\nAs an exception, a\nstrictly comparable\ntype constraint may also be satisfied by a\n(not necessarily strictly comparable) type argument\nMore precisely:\na constraint\ncan be written in the form\ninterface{ comparable; E }\nbasic interface\nand implements\nBecause of the exception in the constraint satisfaction rule, comparing operands of type parameter type\nmay panic at run-time (even though comparable type parameters are always strictly comparable).\nVariable declarations\nA variable declaration creates one or more\nbinds corresponding identifiers to them, and gives each a type and an initial value.\nIf a list of expressions is given, the variables are initialized\nwith the expressions following the rules for\nassignment statements\nOtherwise, each variable is initialized to its\nIf a type is present, each variable is given that type.\nOtherwise, each variable is given the type of the corresponding\ninitialization value in the assignment.\nIf that value is an untyped constant, it is first implicitly\ndefault type\nif it is an untyped boolean value, it is first implicitly converted to type\nThe predeclared identifier\ncannot be used to initialize a variable\nwith no explicit type.\nImplementation restriction: A compiler may make it illegal to declare a variable\nfunction body\nif the variable is\nnever used.\nShort variable declarations\nshort variable declaration\nuses the syntax:\nShortVarDecl\nIdentifierList\nExpressionList\nIt is shorthand for a regular\nvariable declaration\nwith initializer expressions but no types:\n\"var\" IdentifierList \"=\" ExpressionList .\nUnlike regular variable declarations, a short variable declaration may\nvariables provided they were originally declared earlier in the same block\n(or the parameter lists if the block is the function body) with the same type,\nand at least one of the non-\nvariables is new.\nAs a consequence, redeclaration can only appear in a multi-variable short declaration.\nRedeclaration does not introduce a new variable; it just assigns a new value to the original.\nThe non-blank variable names on the left side of\nShort variable declarations may appear only inside functions.\nIn some contexts such as the initializers for\nstatements,\nthey can be used to declare local temporary variables.\nFunction declarations\nA function declaration binds an identifier, the\nfunction name\nto a function.\nIf the function's\nresult parameters, the function body's statement list must end in\nterminating statement\nIf the function declaration specifies\ntype parameters\nthe function name denotes a\ngeneric function\nA generic function must be\ninstantiated\nbefore it can be\ncalled or used as a value.\nfunc min[T ~int|~float64](x, y T) T {\nA function declaration without type parameters may omit the body.\nSuch a declaration provides the signature for a function implemented outside Go,\nsuch as an assembly routine.\nfunc flushICache(begin, end uintptr)  // implemented externally\nMethod declarations\nA method is a\nA method declaration binds an identifier, the\nmethod name\n, to a method,\nand associates the method with the receiver's\nFunctionBody\nThe receiver is specified via an extra parameter section preceding the method\nname. That parameter section must declare a single non-variadic parameter, the receiver.\nIts type must be a\npointer to a defined type\n, possibly followed by a list of type parameter\nenclosed in square brackets.\nis called the receiver\n. A receiver base type cannot be\na pointer or interface type and it must be defined in the same package as the method.\nThe method is said to be\nto its receiver base type and the method name\nis visible only within\nreceiver identifier must be\nin the method signature.\nIf the receiver's value is not referenced inside the body of the method,\nits identifier may be omitted in the declaration. The same applies in\ngeneral to parameters of functions and methods.\nFor a base type, the non-blank names of methods bound to it must be unique.\nIf the base type is a\nstruct type\nthe non-blank method and field names must be distinct.\nGiven defined type\nthe declarations\nbind the methods\nwith receiver type\nto the base type\nIf the receiver base type is a\ngeneric type\nreceiver specification must declare corresponding type parameters for the method\nto use. This makes the receiver type parameters available to the method.\nSyntactically, this type parameter declaration looks like an\ninstantiation\nof the receiver base type: the type\narguments must be identifiers denoting the type parameters being declared, one\nfor each type parameter of the receiver base type.\nThe type parameter names do not need to match their corresponding parameter names in the\nreceiver base type definition, and all non-blank parameter names must be unique in the\nreceiver parameter section and the method signature.\nThe receiver type parameter constraints are implied by the receiver base type definition:\ncorresponding type parameters have corresponding constraints.\nIf the receiver type is denoted by (a pointer to) an\nthe alias must not be generic and it must not denote an instantiated generic type, neither\ndirectly nor indirectly via another alias, and irrespective of pointer indirections.\nExpressions\nAn expression specifies the computation of a value by applying\noperators and functions to operands.\nOperands denote the elementary values in an expression. An operand may be a\nliteral, a (possibly\nidentifier denoting a\nor a parenthesized expression.\nAn operand name denoting a\ngeneric function\nmay be followed by a list of\ntype arguments\nresulting operand is an\ninstantiated\nblank identifier\nmay appear as an\noperand only on the left-hand side of an\nassignment statement\nImplementation restriction: A compiler need not report an error if an operand's\ntype parameter\nwith an empty\n. Functions with such type parameters\ninstantiated\n; any attempt will lead\nto an error at the instantiation site.\nQualified identifiers\nqualified identifier\nis an identifier qualified with a package name prefix.\nBoth the package name and the identifier must not be\nQualifiedIdent\nPackageName\nA qualified identifier accesses an identifier in a different package, which\nThe identifier must be\ndeclared in the\npackage block\nof that package.\nmath.Sin // denotes the Sin function in package math\nComposite literals\nComposite literals construct new values for structs, arrays, slices, and maps\neach time they are evaluated.\nThey consist of the type of the literal followed by a brace-bound list of elements.\nEach element may optionally be preceded by a corresponding key.\nUnless the LiteralType is a type parameter,\nunderlying type\nmust be a struct, array, slice, or map type\n(the syntax enforces this constraint except when the type is given\nas a TypeName).\nIf the LiteralType is a type parameter, all types in its type set\nmust have the same underlying type which must be\na valid composite literal type.\nThe types of the elements and keys must be\nto the respective field, element, and key types of type\nthere is no additional conversion.\nThe key is interpreted as a field name for struct literals,\nan index for array and slice literals, and a key for map literals.\nFor map literals, all elements must have a key. It is an error\nto specify multiple elements with the same field name or\nconstant key value. For non-constant map keys, see the section on\nevaluation order\nFor struct literals the following rules apply:\nA key must be a field name declared in the struct type.\nAn element list that does not contain any keys must\nlist an element for each struct field in the\norder in which the fields are declared.\nIf any element has a key, every element must have a key.\nAn element list that contains keys does not need to\nhave an element for each struct field. Omitted fields\nget the zero value for that field.\nA literal may omit the element list; such a literal evaluates\nto the zero value for its type.\nIt is an error to specify an element for a non-exported\nfield of a struct belonging to a different package.\nGiven the declarations\ntype Point3D struct { x, y, z float64 }\ntype Line struct { p, q Point3D }\none may write\nFor array and slice literals the following rules apply:\nEach element has an associated integer index marking\nits position in the array.\nAn element with a key uses the key as its index. The\nkey must be a non-negative constant\nrepresentable\na value of type\n; and if it is typed\nit must be of\ninteger type\nAn element without a key uses the previous element's index plus one.\nIf the first element has no key, its index is zero.\nTaking the address\nof a composite literal\ngenerates a pointer to a unique\ninitialized\nwith the literal's value.\nvar pointer *Point3D = &Point3D{y: 1000}\nNote that the\nfor a slice or map\ntype is not the same as an initialized but empty value of the same type.\nConsequently, taking the address of an empty slice or map composite literal\ndoes not have the same effect as allocating a new slice or map value with\nThe length of an array literal is the length specified in the literal type.\nIf fewer elements than the length are provided in the literal, the missing\nelements are set to the zero value for the array element type.\nIt is an error to provide elements with index values outside the index range\nof the array. The notation\nspecifies an array length equal\nto the maximum element index plus one.\nA slice literal describes the entire underlying array literal.\nThus the length and capacity of a slice literal are the maximum\nelement index plus one. A slice literal has the form\n[]T{x1, x2, … xn}\nand is shorthand for a slice operation applied to an array:\ntmp := [n]T{x1, x2, … xn}\nWithin a composite literal of array, slice, or map type\nelements or map keys that are themselves composite literals may elide the respective\nliteral type if it is identical to the element or key type of\nSimilarly, elements or keys that are addresses of composite literals may elide\nwhen the element or key type is\nA parsing ambiguity arises when a composite literal using the\nTypeName form of the LiteralType appears as an operand between the\nand the opening brace of the block\nof an \"if\", \"for\", or \"switch\" statement, and the composite literal\nis not enclosed in parentheses, square brackets, or curly braces.\nIn this rare case, the opening brace of the literal is erroneously parsed\nas the one introducing the block of statements. To resolve the ambiguity,\nthe composite literal must appear within parentheses.\nif x == (T{a,b,c}[i]) { … }\nif (x == T{a,b,c}[i]) { … }\nExamples of valid array, slice, and map literals:\nFunction literals\nA function literal represents an anonymous\nFunction literals cannot declare type parameters.\nFunctionLit\nFunctionBody\nfunc(a, b int, z float64) bool { return a*b < int(z) }\nA function literal can be assigned to a variable or invoked directly.\nf := func(x, y int) int { return x + y }\nfunc(ch chan int) { ch <- ACK }(replyChan)\nFunction literals are\n: they may refer to variables\ndefined in a surrounding function. Those variables are then shared between\nthe surrounding function and the function literal, and they survive as long\nas they are accessible.\nPrimary expressions\nPrimary expressions are the operands for unary and binary expressions.\n(s + \".txt\")\nf(3.1415, true)\nPoint{1, 2}\ns[i : j + 1]\nprimary expression\nthat is not a\npackage name\nselector expression\ndenotes the field or method\nof the value\n(or sometimes\n; see below).\nThe identifier\nis called the (field or method)\nit must not be the\nblank identifier\nThe type of the selector expression is the type of\nis a package name, see the section on\nqualified identifiers\nmay denote a field or method\n, or it may refer\nto a field or method\nof a nested\nembedded field\nThe number of embedded fields traversed\nis called its\nThe depth of a field or method\ndeclared in\nThe depth of a field or method\ndeclared in\nan embedded field\nThe following rules apply to selectors:\nFor a value\nis not a pointer or interface type,\ndenotes the field or method at the shallowest depth\nwhere there is such an\nIf there is not exactly\nwith shallowest depth, the selector expression is illegal.\nFor a value\nis an interface type,\ndenotes the actual method with name\nof the dynamic value of\nIf there is no method with name\n, the selector\nexpression is illegal.\nAs an exception, if the type of\npointer type and\nis a valid selector expression denoting a field\n(but not a method),\nis shorthand for\nIn all other cases,\nis illegal.\nis of pointer type and has the value\ndenotes a struct field,\nassigning to or evaluating\nrun-time panic\nis of interface type and has the value\nrun-time panic\nFor example, given the declarations:\none may write:\nbut the following is invalid:\nq.M0()       // (*q).M0 is valid but not a field selector\nMethod expressions\nis a function that is callable as a regular function\nwith the same arguments as\nprefixed by an additional\nargument that is the receiver of the method.\nReceiverType\nReceiverType\nConsider a struct type\nwith two methods,\n, whose receiver is of type\n, whose receiver is of type\nThe expression\nyields a function equivalent to\nwith an explicit receiver as its first argument; it has signature\nfunc(tv T, a int) int\nThat function may be called normally with an explicit receiver, so\nthese five invocations are equivalent:\n(T).Mv(t, 7)\nf1 := T.Mv; f1(t, 7)\nf2 := (T).Mv; f2(t, 7)\nSimilarly, the expression\nyields a function value representing\nwith signature\nfunc(tp *T, f float32) float32\nFor a method with a value receiver, one can derive a function\nwith an explicit pointer receiver, so\nyields a function value representing\nwith signature\nfunc(tv *T, a int) int\nSuch a function indirects through the receiver to create a value\nto pass as the receiver to the underlying method;\nthe method does not overwrite the value whose address is passed in\nthe function call.\nThe final case, a value-receiver function for a pointer-receiver method,\nis illegal because pointer-receiver methods are not in the method set\nof the value type.\nFunction values derived from methods are called with function call syntax;\nthe receiver is provided as the first argument to the call.\nThat is, given\nTo construct a function that binds the receiver, use a\nfunction literal\nmethod value\nIt is legal to derive a function value from a method of an interface type.\nThe resulting function takes an explicit receiver of that interface type.\nMethod values\nIf the expression\nhas static type\nis called a\nmethod value\nThe method value\nis a function value that is callable\nwith the same arguments as a method call of\nThe expression\nis evaluated and saved during the evaluation of the\nmethod value; the saved copy is then used as the receiver in any calls,\nwhich may be executed later.\nmay be an interface or non-interface type.\nAs in the discussion of\nmethod expressions\nconsider a struct type\nwith two methods,\n, whose receiver is of type\n, whose receiver is of type\nThe expression\nyields a function value of type\nfunc(int) int\nThese two invocations are equivalent:\nf := t.Mv; f(7)\nSimilarly, the expression\nyields a function value of type\nfunc(float32) float32\n, a reference to a non-interface method with a value receiver\nusing a pointer will automatically dereference that pointer:\nis equivalent to\nmethod calls\n, a reference to a non-interface method with a pointer receiver\nusing an addressable value will automatically take the address of that value:\nis equivalent to\nAlthough the examples above use non-interface types, it is also legal to create a method value\nfrom a value of interface type.\nvar i interface { M(int) } = myVal\nf := i.M; f(7)  // like i.M(7)\nIndex expressions\nA primary expression of the form\ndenotes the element of the array, pointer to array, slice, string or map\nis called the\n, respectively.\nThe following rules apply:\nis neither a map nor a\ntype parameter\nmust be an untyped constant, or its type must be\nor a type parameter whose type set\ncontains only integer types\na constant index must be non-negative and\nrepresentable\nby a value of type\na constant index that is untyped is given type\n0 <= x < len(a)\notherwise it is\nout of range\nindex must be in range\nis out of range at run time,\nrun-time panic\nis the array element at index\nand the type of\nis the element type of\nto array type:\nis shorthand for\nis out of range at run time,\nrun-time panic\nis the slice element at index\nand the type of\nis the element type of\nstring type\nindex must be in range\nif the string\nis also constant\nis out of range at run time,\nrun-time panic\nis the non-constant byte value at index\nand the type of\nmay not be assigned to\n's type must be\nto the key type of\nif the map contains an entry with key\nis the map element with key\nand the type of\nis the element type of\nif the map is\nor does not contain such an entry,\nfor the element type of\ntype parameter type\nThe index expression\nmust be valid for values\nof all types in\n's type set.\nThe element types of all types in\n's type set must be identical.\nIn this context, the element type of a string type is\nIf there is a map type in the type set of\nall types in that type set must be map types, and the respective key types\nmust be all identical.\nis the array, slice, or string element at index\nor the map element with key\nof the type argument\nis instantiated with, and the type of\nthe type of the (identical) element types.\nmay not be assigned to if\n's type set\nincludes string types.\nis illegal.\nAn index expression on a map\nassignment statement\nor initialization of the special form\nv, ok = a[x]\nv, ok := a[x]\nvar v, ok = a[x]\nyields an additional untyped boolean value. The value of\nis present in the map, and\nAssigning to an element of a\nmap causes a\nrun-time panic\nSlice expressions\nSlice expressions construct a substring or slice from a string, array, pointer\nto array, or slice operand.\nThere are two variants: a simple form that specifies a low\nand high bound, and a full form that also specifies a bound on the capacity.\nIf the operand type is a\ntype parameter\nunless its type set contains string types,\nall types in the type set must have the same underlying type, and the slice expression\nmust be valid for an operand of that type.\nIf the type set contains string types it may also contain byte slices with underlying\nIn this case, the slice expression must be valid for an operand of\nSimple slice expressions\nFor a string, array, pointer to array, or slice\n, the primary expression\na[low : high]\nconstructs a substring or slice.\nselect which elements of operand\nin the result. The result has indices starting at 0 and length equal to\nAfter slicing the array\na := [5]int{1, 2, 3, 4, 5}\ns := a[1:4]\n, length 3, capacity 4, and elements\nFor convenience, any of the indices may be omitted. A missing\nindex defaults to zero; a missing\nindex defaults to the length of the\nsliced operand:\na[2:]  // same as a[2 : len(a)]\na[:3]  // same as a[0 : 3]\na[:]   // same as a[0 : len(a)]\nis a pointer to an array,\na[low : high]\nis shorthand for\n(*a)[low : high]\nFor arrays or strings, the indices are\notherwise they are\nout of range\nFor slices, the upper index bound is the slice capacity\nrather than the length.\nindex must be non-negative and\nrepresentable\nby a value of type\n; for arrays or constant strings, constant indices must also be in range.\nIf both indices are constant, they must satisfy\nlow <= high\nIf the indices are out of range at run time, a\nrun-time panic\nuntyped strings\n, if the sliced operand is a string or slice,\nthe result of the slice operation is a non-constant value of the same type as the operand.\nFor untyped string operands the result is a non-constant value of type\nIf the sliced operand is an array, it must be\naddressable\nand the result of the slice operation is a slice with the same element type as the array.\nIf the sliced operand of a valid slice expression is a\nslice, the result\nslice. Otherwise, if the result is a slice, it shares its underlying\narray with the operand.\nFull slice expressions\nFor an array, pointer to array, or slice\n(but not a string), the primary expression\na[low : high : max]\nconstructs a slice of the same type, and with the same length and elements as the simple slice\na[low : high]\n. Additionally, it controls the resulting slice's capacity\nby setting it to\n. Only the first index may be omitted; it defaults to 0.\nAfter slicing the array\na := [5]int{1, 2, 3, 4, 5}\nt := a[1:3:5]\n, length 2, capacity 4, and elements\nAs for simple slice expressions, if\nis a pointer to an array,\na[low : high : max]\nis shorthand for\n(*a)[low : high : max]\nIf the sliced operand is an array, it must be\naddressable\nThe indices are\n0 <= low <= high <= max <= cap(a)\notherwise they are\nout of range\nindex must be non-negative and\nrepresentable\nby a value of type\n; for arrays, constant indices must also be in range.\nIf multiple indices are constant, the constants that are present must be in range relative to each\nIf the indices are out of range at run time, a\nrun-time panic\nType assertions\nFor an expression\ninterface type\ntype parameter\n, and a type\nthe primary expression\nasserts that\nand that the value stored in\nThe notation\nis called a\ntype assertion\nMore precisely, if\nis not an interface type,\nthat the dynamic type of\nto the type\nIn this case,\nthe (interface) type of\notherwise the type assertion is invalid since it is not possible for\nto store a value of type\nis an interface type,\nasserts that the dynamic type\nthe interface\nIf the type assertion holds, the value of the expression is the value\nand its type is\n. If the type assertion is false,\nrun-time panic\nIn other words, even though the dynamic type of\nis known only at run time, the type of\nknown to be\nin a correct program.\nA type assertion used in an\nassignment statement\nor initialization of the special form\nyields an additional untyped boolean value. The value of\nif the assertion holds. Otherwise it is\nand the value of\nrun-time panic\noccurs in this case.\nGiven an expression\nfunction type\nf(a1, a2, … an)\nwith arguments\na1, a2, … an\nExcept for one special case, arguments must be single-valued expressions\nto the parameter types of\nand are evaluated before the function is called.\nThe type of the expression is the result type of\nA method invocation is similar but the method itself\nis specified as a selector upon a value of the receiver type for\nthe method.\nmath.Atan2(x, y)  // function call\nvar pt *Point\npt.Scale(3.5)     // method call with receiver pt\ndenotes a generic function, it must be\ninstantiated\nbefore it can be called\nor used as a function value.\nIf the type of\ntype parameter\nall types in its type set must have the same underlying type, which must be a function type,\nand the function call must be valid for that type.\nIn a function call, the function value and arguments are evaluated in\nthe usual order\nAfter they are evaluated, new storage is allocated for the function's\n, which includes its parameters\nand results.\nThen, the arguments of the call are\nto the function,\nwhich means that they are\nto their corresponding function parameters,\nand the called function begins execution.\nThe return parameters of the function are passed\nback to the caller when the function returns.\nfunction value\nrun-time panic\nAs a special case, if the return values of a function or method\nare equal in number and individually\nassignable to the parameters of another function or method\n, then the call\nparameters_of_g\nwill invoke\nafter passing the return values of\nto the parameters of\nThe call of\nmust contain no parameters other than the call of\nmust have at least one return value.\nhas a final\nparameter, it is\nassigned the return values of\nthat remain after\nassignment of regular parameters.\nA method call\nis valid if the\nof (the type of)\nargument list can be assigned to the parameter list of\naddressable\nset contains\nis shorthand\nvar p Point\np.Scale(3.5)\nThere is no distinct method type and there are no method literals.\nPassing arguments to\nwith a final\n, then within\nthe type of\nis equivalent to type\nis invoked with no actual arguments for\nOtherwise, the value passed is a new slice\nwith a new underlying array whose successive elements\nare the actual arguments, which all must be\n. The length and capacity of the slice is therefore\nthe number of arguments bound to\nand may differ for each\nGiven the function and calls\nwill have the value\nin the first call, and\n[]string{\"Joe\", \"Anna\", \"Eileen\"}\nin the second.\nIf the final argument is assignable to a slice type\nis followed by\n, it is passed unchanged as the value\nparameter. In this case no new slice is created.\nGiven the slice\ns := []string{\"James\", \"Jasmine\"}\nGreeting(\"goodbye:\", s...)\nwill have the same value as\nwith the same underlying array.\nInstantiations\nA generic function or type is\ninstantiated\nby substituting\ntype arguments\nfor the type parameters [\nInstantiation proceeds in two steps:\nEach type argument is substituted for its corresponding type parameter in the generic\ndeclaration.\nThis substitution happens across the entire function or type declaration,\nincluding the type parameter list itself and any types in that list.\nAfter substitution, each type argument must\n(instantiated, if necessary)\nof the corresponding type parameter. Otherwise instantiation fails.\nInstantiating a type results in a new non-generic\ninstantiating a function produces a new non-generic function.\nWhen using a generic function, type arguments may be provided explicitly,\nor they may be partially or completely\nfrom the context in which the function is used.\nProvided that they can be inferred, type argument lists may be omitted entirely if the function is:\nwith ordinary arguments,\nto a variable with a known type\npassed as an argument\nto another function, or\nreturned as a result\nIn all other cases, a (possibly partial) type argument list must be present.\nIf a type argument list is absent or partial, all missing type arguments\nmust be inferrable from the context in which the function is used.\nA partial type argument list cannot be empty; at least the first argument must be present.\nThe list is a prefix of the full list of type arguments, leaving the remaining arguments\nto be inferred. Loosely speaking, type arguments may be omitted from \"right to left\".\nFor a generic type, all type arguments must always be provided explicitly.\nType inference\nA use of a generic function may omit some or all type arguments if they can be\nfrom the context within which the function is used, including\nthe constraints of the function's type parameters.\nType inference succeeds if it can infer the missing type arguments\ninstantiation\nsucceeds with the\ninferred type arguments.\nOtherwise, type inference fails and the program is invalid.\nType inference uses the type relationships between pairs of types for inference:\nFor instance, a function argument must be\nto its respective function parameter; this establishes a relationship between the\ntype of the argument and the type of the parameter.\nIf either of these two types contains type parameters, type inference looks for the\ntype arguments to substitute the type parameters with such that the assignability\nrelationship is satisfied.\nSimilarly, type inference uses the fact that a type argument must\nthe constraint of its respective\ntype parameter.\nEach such pair of matched types corresponds to a\ntype equation\none or multiple type parameters, from one or possibly multiple generic functions.\nInferring the missing type arguments means solving the resulting set of type\nequations for the respective type parameters.\nFor example, given\nthe variable\nmust be assignable to\nthe function parameter type\nfor the program to be valid.\nTo reduce complexity, type inference ignores the directionality of assignments,\nso the type relationship between\nexpressed via the (symmetric) type equation\nfor that matter),\nindicates that the LHS and RHS types must match per assignability rules\n(see the section on\ntype unification\nSimilarly, the type parameter\nmust satisfy its constraint\n. This can be expressed as\nsatisfies constraint\nThese observations lead to a set of two equations\nwhich now can be solved for the type parameters\nFrom (1) a compiler can infer that the type argument for\nSimilarly, because the underlying type of\nof the constraint,\na compiler can infer that\nThus, for these two equations, type inference infers\nGiven a set of type equations, the type parameters to solve for are\nthe type parameters of the functions that need to be instantiated\nand for which no explicit type arguments is provided.\nThese type parameters are called\ntype parameters.\nFor instance, in the\nexample above, the type parameters\nare bound to\nAn argument to a generic function call may be a generic function itself.\nThe type parameters of that function are included in the set of bound\ntype parameters.\nThe types of function arguments may contain type parameters from other\nfunctions (such as a generic function enclosing a function call).\nThose type parameters may also appear in type equations but they are\nnot bound in that context.\nType equations are always solved for the bound type parameters only.\nType inference supports calls of generic functions and assignments\nof generic functions to (explicitly function-typed) variables.\nThis includes passing generic functions as arguments to other\n(possibly also generic) functions, and returning generic functions\nas results.\nType inference operates on a set of equations specific to each of\nthese cases.\nThe equations are as follows (type argument lists are omitted for clarity):\nFor a function call\nor a function argument\na generic function:\nof corresponding\nfunction arguments and parameters where\nuntyped constant\nyields an equation\nis an untyped constant\nis a bound type parameter\nis collected separately from\nthe type equations.\nFor an assignment\nof a generic function\n(non-generic) variable\nof function type:\ntypeof(v) ≡\nFor a return statement\nreturn …, f, …\ngeneric function returned as a result to a (non-generic) result variable\nof function type:\ntypeof(r) ≡\nAdditionally, each type parameter\nand corresponding type constraint\nyields the type equation\nType inference gives precedence to type information obtained from typed operands\nbefore considering untyped constants.\nTherefore, inference proceeds in two phases:\nThe type equations are solved for the bound\ntype parameters using\ntype unification\nIf unification fails, type inference fails.\nFor each bound type parameter\nfor which no type argument\nhas been inferred yet and for which one or more pairs\nwith that same type parameter\nwere collected, determine the\nconstant kind\nof the constants\nin all those pairs the same way as for\nconstant expressions\nThe type argument for\ndefault type\nfor the determined constant kind.\nIf a constant kind cannot be determined due to conflicting constant kinds,\ntype inference fails.\nIf not all type arguments have been found after these two phases, type inference fails.\nIf the two phases are successful, type inference determined a type argument for each\nbound type parameter:\nA type argument\nmay be a composite type,\ncontaining other bound type parameters\nas element types\n(or even be just another bound type parameter).\nIn a process of repeated simplification, the bound type parameters in each type\nargument are substituted with the respective type arguments for those type\nparameters until each type argument is free of bound type parameters.\nIf type arguments contain cyclic references to themselves\nthrough bound type parameters, simplification and thus type\ninference fails.\nOtherwise, type inference succeeds.\nType unification\nType inference solves type equations through\ntype unification\nType unification recursively compares the LHS and RHS types of an\nequation, where either or both types may be or contain bound type parameters,\nand looks for type arguments for those type parameters such that the LHS\nand RHS match (become identical or assignment-compatible, depending on\nTo that effect, type inference maintains a map of bound type parameters\nto inferred type arguments; this map is consulted and updated during type unification.\nInitially, the bound type parameters are known but the map is empty.\nDuring type unification, if a new type argument\nis inferred,\nthe respective mapping\nfrom type parameter to argument\nis added to the map.\nConversely, when comparing types, a known type argument\n(a type argument for which a map entry already exists)\ntakes the place of its corresponding type parameter.\nAs type inference progresses, the map is populated more and more\nuntil all equations have been considered, or until unification fails.\nType inference succeeds if no unification step fails and the map has\nan entry for each type parameter.\nFor example, given the type equation with the bound type parameter\n[10]struct{ elem P, list []P } ≡\n[10]struct{ elem string; list []string }\ntype inference starts with an empty map.\nUnification first compares the top-level structure of the LHS and RHS\nBoth are arrays of the same length; they unify if the element types unify.\nBoth element types are structs; they unify if they have\nthe same number of fields with the same names and if the\nfield types unify.\nThe type argument for\nis not known yet (there is no map entry),\nso unifying\nthe mapping\nto the map.\nUnifying the types of the\nfield requires\nSince the type argument for\nis known at this point\n(there is a map entry for\n), its type argument\ntakes the place of\nis identical to\nthis unification step succeeds as well.\nUnification of the LHS and RHS of the equation is now finished.\nType inference succeeds because there is only one type equation,\nno unification step failed, and the map is fully populated.\nUnification uses a combination of\nunification depending on whether two types have to be\nassignment-compatible\nonly structurally equal.\nThe respective\ntype unification rules\nare spelled out in detail in the\nFor an equation of the form\nare types involved\nin an assignment (including parameter passing and return statements),\nthe top-level type structures may unify loosely but element types\nmust unify exactly, matching the rules for assignments.\nFor an equation of the form\nis a type parameter and\nits corresponding constraint, the unification rules are bit\nmore complicated:\nIf all types in\n's type set have the same\nunderlying type\nhas a known type argument\nmust unify loosely.\nSimilarly, if all types in\n's type set are\nchannel types with the same element type and non-conflicting\nchannel directions,\nhas a known type argument\nthe most restrictive channel type in\nmust unify loosely.\ndoes not have a known type argument\ncontains exactly one type term\nthat is not an underlying (tilde) type, unification adds the\nto the map.\ndoes not have a type\nas described above\nhas a known type argument\nmust have all methods of\nand corresponding method types must unify exactly.\nWhen solving type equations from type constraints,\nsolving one equation may infer additional type arguments,\nwhich in turn may enable solving other equations that depend\non those type arguments.\nType inference repeats type unification as long as new type\narguments are inferred.\nOperators combine operands into expressions.\nComparisons are discussed\nFor other binary operators, the operand types must be\nunless the operation involves shifts or untyped\nFor operations involving constants only, see the section on\nconstant expressions\nExcept for shift operations, if one operand is an untyped\nand the other operand is not, the constant is implicitly\nto the type of the other operand.\nThe right operand in a shift expression must have\ninteger type\nor be an untyped constant\nrepresentable\nvalue of type\nIf the left operand of a non-constant shift expression is an untyped constant,\nit is first implicitly converted to the type it would assume if the shift expression were\nreplaced by its left operand alone.\nOperator precedence\nUnary operators have the highest precedence.\noperators form\nstatements, not expressions, they fall\noutside the operator hierarchy.\nAs a consequence, statement\nis the same as\nThere are five precedence levels for binary operators.\nMultiplication operators bind strongest, followed by addition\noperators, comparison operators,\n(logical AND),\nand finally\n(logical OR):\nBinary operators of the same precedence associate from left to right.\nFor instance,\nis the same as\n(x / y) * z\nArithmetic operators\nArithmetic operators apply to numeric values and yield a result of the same\ntype as the first operand. The four standard arithmetic operators (\nfloating-point\nalso applies to\nThe bitwise logical and shift operators apply to integers only.\nIf the operand type is a\ntype parameter\nthe operator must apply to each type in that type set.\nThe operands are represented as values of the type argument that the type parameter\ninstantiated\nwith, and the operation is computed\nwith the precision of that type argument. For example, given the function:\nthe product\nand the addition\nare computed with\nrespectively, depending on the type argument for\nInteger operators\nFor two integer values\n, the integer quotient\nand remainder\nsatisfy the following\nrelationships:\nx = q*y + r  and  |r| < |y|\ntruncated towards zero\n\"truncated division\"\nThe one exception to this rule is that if the dividend\nthe most negative value for the int type of\n, the quotient\nis equal to\ndue to two's-complement\ninteger overflow\nIf the divisor is a\n, it must not be zero.\nIf the divisor is zero at run time, a\nrun-time panic\nIf the dividend is non-negative and the divisor is a constant power of 2,\nthe division may be replaced by a right shift, and computing the remainder may\nbe replaced by a bitwise AND operation:\nThe shift operators shift the left operand by the shift count specified by the\nright operand, which must be non-negative. If the shift count is negative at run time,\nrun-time panic\nThe shift operators implement arithmetic shifts if the left operand is a signed\ninteger and logical shifts if it is an unsigned integer.\nThere is no upper limit on the shift count. Shifts behave\nas if the left operand is shifted\ntimes by 1 for a shift\nAs a result,\nis the same as\nis the same as\nbut truncated towards negative infinity.\nFor integer operands, the unary operators\nare defined as\nInteger overflow\nunsigned integer\nvalues, the operations\ncomputed modulo 2\nis the bit width of\nthe unsigned integer's type.\nLoosely speaking, these unsigned integer operations\ndiscard high bits upon overflow, and programs may rely on \"wrap around\".\nFor signed integers, the operations\nmay legally\noverflow and the resulting value exists and is deterministically defined\nby the signed integer representation, the operation, and its operands.\nOverflow does not cause a\nrun-time panic\nA compiler may not optimize code under the assumption that overflow does\nnot occur. For instance, it may not assume that\nis always true.\nFloating-point operators\nFor floating-point and complex numbers,\nis the same as\nis the negation of\nThe result of a floating-point or complex division by zero is not specified beyond the\nIEEE 754 standard; whether a\nrun-time panic\noccurs is implementation-specific.\nAn implementation may combine multiple floating-point operations into a single\nfused operation, possibly across statements, and produce a result that differs\nfrom the value obtained by executing and rounding the instructions individually.\nAn explicit\nfloating-point type\nthe precision of the target type, preventing fusion that would discard that rounding.\nFor instance, some architectures provide a \"fused multiply and add\" (FMA) instruction\nthat computes\nwithout rounding the intermediate result\nThese examples show when a Go implementation can use that instruction:\nString concatenation\nStrings can be concatenated using the\nassignment operator:\ns := \"hi\" + string(c)\ns += \" and good bye\"\nString addition creates a new string by concatenating the operands.\nComparison operators\nComparison operators compare two operands and yield an untyped boolean value.\n==    equal\n!=    not equal\n<=    less or equal\n>     greater\n>=    greater or equal\nIn any comparison, the first operand\nto the type of the second operand, or vice versa.\nThe equality operators\nto operands of\nThe ordering operators\napply to operands of\nThese terms and the result of the comparisons are defined as follows:\nBoolean types are comparable.\nTwo boolean values are equal if they are either both\nInteger types are comparable and ordered.\nTwo integer values are compared in the usual way.\nFloating-point types are comparable and ordered.\nTwo floating-point values are compared as defined by the IEEE 754 standard.\nComplex types are comparable.\nTwo complex values\nequal if both\nreal(u) == real(v)\nimag(u) == imag(v)\nString types are comparable and ordered.\nTwo string values are compared lexically byte-wise.\nPointer types are comparable.\nTwo pointer values are equal if they point to the same variable or if both have value\nPointers to distinct\nvariables may or may not be equal.\nChannel types are comparable.\nTwo channel values are equal if they were created by the same call to\nor if both have value\nInterface types that are not type parameters are comparable.\nTwo interface values are equal if they have\ndynamic types\nand equal dynamic values or if both have value\nof non-interface type\nof interface type\ncan be compared\nis comparable and\nThey are equal if\n's dynamic type is identical to\n's dynamic value is equal to\nStruct types are comparable if all their field types are comparable.\nTwo struct values are equal if their corresponding\nfield values are equal.\nThe fields are compared in source order, and comparison stops as\nsoon as two field values differ (or all fields have been compared).\nArray types are comparable if their array element types are comparable.\nTwo array values are equal if their corresponding element values are equal.\nThe elements are compared in ascending index order, and comparison stops\nas soon as two element values differ (or all elements have been compared).\nType parameters are comparable if they are strictly comparable (see below).\nA comparison of two interface values with identical dynamic types\nrun-time panic\nif that type\nis not comparable.  This behavior applies not only to direct interface\nvalue comparisons but also when comparing arrays of interface values\nor structs with interface-valued fields.\nSlice, map, and function types are not comparable.\nHowever, as a special case, a slice, map, or function value may\nbe compared to the predeclared identifier\nComparison of pointer, channel, and interface values to\nis also allowed and follows from the general rules above.\nstrictly comparable\nif it is comparable and not an interface\ntype nor composed of interface types.\nSpecifically:\nBoolean, numeric, string, pointer, and channel types are strictly comparable.\nStruct types are strictly comparable if all their field types are strictly comparable.\nArray types are strictly comparable if their array element types are strictly comparable.\nType parameters are strictly comparable if all types in their type set are strictly comparable.\nLogical operators\nLogical operators apply to\nand yield a result of the same type as the operands.\nThe left operand is evaluated, and then the right if the condition requires it.\nAddress operators\nFor an operand\n, the address operation\ngenerates a pointer of type\nThe operand must be\naddressable\nthat is, either a variable, pointer indirection, or slice indexing\noperation; or a field selector of an addressable struct operand;\nor an array indexing operation of an addressable array.\nAs an exception to the addressability requirement,\nmay also be a\n(possibly parenthesized)\ncomposite literal\nIf the evaluation of\nwould cause a\nrun-time panic\nthen the evaluation of\nFor an operand\nof pointer type\n, the pointer\nindirection\ndenotes the\n, an attempt to evaluate\nwill cause a\nrun-time panic\nReceive operator\nFor an operand\nchannel type\nthe value of the receive operation\nis the value received\nfrom the channel\nThe channel direction must permit receive operations,\nand the type of the receive operation is the element type of the channel.\nThe expression blocks until a value is available.\nReceiving from a\nchannel blocks forever.\nA receive operation on a\nchannel can always proceed\nimmediately, yielding the element type's\nafter any previously sent values have been received.\n<-strobe  // wait until clock pulse and discard received value\nIf the operand type is a\ntype parameter\nall types in its type set must be channel types that permit receive operations, and\nthey must all have the same element type, which is the type of the receive operation.\nA receive expression used in an\nassignment statement\nor initialization of the special form\nx, ok = <-ch\nx, ok := <-ch\nvar x, ok = <-ch\nvar x, ok T = <-ch\nyields an additional untyped boolean result reporting whether the\ncommunication succeeded. The value of\nif the value received was delivered by a successful send operation to the\nchannel, or\nif it is a zero value generated because the\nchannel is closed and empty.\nConversions\nA conversion changes the\nof an expression\nto the type specified by the conversion.\nA conversion may appear literally in the source, or it may be\nby the context in which an expression appears.\nconversion is an expression of the form\nis a type and\nis an expression\nthat can be converted to type\n[ \",\" ] \")\" .\nIf the type starts with the operator\nor if the type starts with the keyword\nand has no result list, it must be parenthesized when\nnecessary to avoid ambiguity:\ncan be converted to\nrepresentable\nby a value of\nAs a special case, an integer constant\ncan be explicitly converted to a\nstring type\nas for non-constant\nConverting a constant to a type that is not a\ntype parameter\nyields a typed constant.\nConverting a constant to a type parameter yields a\nnon-constant\nvalue of that type,\nwith the value represented as a value of the type argument that the type parameter\ninstantiated\nFor example, given the function:\nfunc f[P ~float32|~float64]() {\nthe conversion\nresults in a non-constant value of type\nand the value\nis represented as a\ndepending on the type argument for\nAccordingly, if\nis instantiated with a\nthe numeric value of the expression\nwill be computed\nwith the same precision as the corresponding non-constant\nA non-constant value\ncan be converted to type\nin any of these cases:\nignoring struct tags (see below),\n's type and\ntype parameters\nunderlying types\nignoring struct tags (see below),\n's type and\nare pointer types\nthat are not\nnamed types\nand their pointer base types are not type parameters but\nhave identical underlying types.\n's type and\nare both integer or floating\npoint types.\n's type and\nare both complex types.\nis an integer or a slice of bytes or runes\nis a string type.\nis a string and\nis a slice of bytes or runes.\nis a slice,\nis an array [\nor a pointer to an array [\nand the slice and array types have\nelement types.\nAdditionally, if\nparameters,\ncan also be converted to type\nif one of the following conditions applies:\nare type parameters and a value of each\n's type set can be converted to each type in\nis a type parameter and a value of each\n's type set can be converted to\nis a type parameter and\ncan be converted to each\n's type set.\nStruct tags\nare ignored when comparing struct types\nfor identity for the purpose of conversion:\nSpecific rules apply to (non-constant) conversions between numeric types or\nto and from a string type.\nThese conversions may change the representation of\nand incur a run-time cost.\nAll other conversions only change the type but not the representation\nThere is no linguistic mechanism to convert between pointers and integers.\nThe package\nimplements this functionality under restricted circumstances.\nConversions between numeric types\nFor the conversion of non-constant numeric values, the following rules apply:\nWhen converting between\ninteger types\n, if the value is a signed integer, it is\nsign extended to implicit infinite precision; otherwise it is zero extended.\nIt is then truncated to fit in the result type's size.\nFor example, if\nv := uint16(0x10F0)\nuint32(int8(v)) == 0xFFFFFFF0\nThe conversion always yields a valid value; there is no indication of overflow.\nWhen converting a\nfloating-point number\nto an integer, the fraction is discarded\n(truncation towards zero).\nWhen converting an integer or floating-point number to a floating-point type,\ncomplex number\nto another complex type, the result value is rounded\nto the precision specified by the destination type.\nFor instance, the value of a variable\nmay be stored using additional precision beyond that of an IEEE 754 32-bit number,\nbut float32(x) represents the result of rounding\n's value to\n32-bit precision. Similarly,\nmay use more than 32 bits\nof precision, but\nfloat32(x + 0.1)\nIn all non-constant conversions involving floating-point or complex values,\nif the result type cannot represent the value the conversion\nsucceeds but the result value is implementation-dependent.\nConversions to and from a string type\nConverting a slice of bytes to a string type yields\na string whose successive bytes are the elements of the slice.\nConverting a slice of runes to a string type yields\na string that is the concatenation of the individual rune values\nconverted to strings.\nConverting a value of a string type to a slice of bytes type\nyields a non-nil slice whose successive elements are the bytes of the string.\nof the resulting slice is\nimplementation-specific and may be larger than the slice length.\nConverting a value of a string type to a slice of runes type\nyields a slice containing the individual Unicode code points of the string.\nof the resulting slice is\nimplementation-specific and may be larger than the slice length.\nFinally, for historical reasons, an integer value may be converted to a string type.\nThis form of conversion yields a string containing the (possibly multi-byte) UTF-8\nrepresentation of the Unicode code point with the given integer value.\nValues outside the range of valid Unicode code points are converted to\nNote: This form of conversion may eventually be removed from the language.\ntool flags certain\ninteger-to-string conversions as potential errors.\nLibrary functions such as\nutf8.AppendRune\nutf8.EncodeRune\nshould be used instead.\nConversions from slice to array or array pointer\nConverting a slice to an array yields an array containing the elements of the underlying array of the slice.\nSimilarly, converting a slice to an array pointer yields a pointer to the underlying array of the slice.\nIn both cases, if the\nof the slice is less than the length of the array,\nrun-time panic\nConstant expressions\nConstant expressions may contain only\noperands and are evaluated at compile time.\nUntyped boolean, numeric, and string constants may be used as operands\nwherever it is legal to use an operand of boolean, numeric, or string type,\nrespectively.\nalways yields\nan untyped boolean constant.  If the left operand of a constant\nshift expression\nis an untyped constant, the\nresult is an integer constant; otherwise it is a constant of the same\ntype as the left operand, which must be of\ninteger type\nAny other operation on untyped constants results in an untyped constant of the\nsame kind; that is, a boolean, integer, floating-point, complex, or string\nIf the untyped operands of a binary operation (other than a shift) are of\ndifferent kinds, the result is of the operand's kind that appears later in this\nlist: integer, rune, floating-point, complex.\nFor example, an untyped integer constant divided by an\nuntyped complex constant yields an untyped complex constant.\nApplying the built-in function\ninteger, rune, or floating-point constants yields\nan untyped complex constant.\nConstant expressions are always evaluated exactly; intermediate values and the\nconstants themselves may require precision significantly larger than supported\nby any predeclared type in the language. The following are legal declarations:\nThe divisor of a constant division or remainder operation must not be zero:\n3.14 / 0.0   // illegal: division by zero\nThe values of\nconstants must always be accurately\nrepresentable\nof the constant type. The following constant expressions are illegal:\nThe mask used by the unary bitwise complement operator\nthe rule for non-constants: the mask is all 1s for unsigned constants\nand -1 for signed and untyped constants.\nImplementation restriction: A compiler may use rounding while\ncomputing untyped floating-point or complex constant expressions; see\nthe implementation restriction in the section\n.  This rounding may cause a\nfloating-point constant expression to be invalid in an integer\ncontext, even if it would be integral when calculated using infinite\nprecision, and vice versa.\nOrder of evaluation\nAt package level,\ninitialization dependencies\ndetermine the evaluation order of individual initialization expressions in\nvariable declarations\nOtherwise, when evaluating the\nexpression, assignment, or\nreturn statement\nall function calls, method calls,\nreceive operations\nbinary logical operations\nare evaluated in lexical left-to-right order.\nFor example, in the (function-local) assignment\ny[f()], ok = g(z || h(), i()+x[j()], <-c), k()\nthe function calls and communication happen in the order\nevaluates to false),\nHowever, the order of those events compared to the evaluation\nand indexing of\nand the evaluation\nis not specified,\nexcept as required lexically. For instance,\ncannot be called before its arguments are evaluated.\nAt package level, initialization dependencies override the left-to-right rule\nfor individual initialization expressions, but not for operands within each\nexpression:\nThe function calls happen in the order\nFloating-point operations within a single expression are evaluated according to\nthe associativity of the operators.  Explicit parentheses affect the evaluation\nby overriding the default associativity.\nIn the expression\nx + (y + z)\nthe addition\nis performed before adding\nStatements control execution.\nTerminating statements\nterminating statement\ninterrupts the regular flow of control in\n. The following statements are terminating:\nA call to the built-in function\nin which the statement list ends in a terminating statement.\n\"if\" statement\nthe \"else\" branch is present, and\nboth branches are terminating statements.\n\"for\" statement\nthere are no \"break\" statements referring to the \"for\" statement, and\nthe loop condition is absent, and\nthe \"for\" statement does not use a range clause.\n\"switch\" statement\nthere are no \"break\" statements referring to the \"switch\" statement,\nthere is a default case, and\nthe statement lists in each case, including the default, end in a terminating\nstatement, or a possibly labeled\n\"fallthrough\"\n\"select\" statement\nthere are no \"break\" statements referring to the \"select\" statement, and\nthe statement lists in each case, including the default if present,\nend in a terminating statement.\nlabeled statement\na terminating statement.\nAll other statements are not terminating.\nstatement list\nends in a terminating statement if the list\nis not empty and its final non-empty statement is terminating.\nEmpty statements\nThe empty statement does nothing.\nLabeled statements\nA labeled statement may be the target of a\nLabeledStmt\nError: log.Panic(\"error encountered\")\nExpression statements\nWith the exception of specific built-in functions,\nfunction and method\nreceive operations\ncan appear in statement context. Such statements may be parenthesized.\nExpressionStmt\nThe following built-in functions are not permitted in statement context:\nlen(\"foo\")  // illegal if len is the built-in function\nSend statements\nA send statement sends a value on a channel.\nThe channel expression must be of\nchannel type\nthe channel direction must permit send operations,\nand the type of the value to be sent must be\nto the channel's element type.\nBoth the channel and the value expression are evaluated before communication\nbegins. Communication blocks until the send can proceed.\nA send on an unbuffered channel can proceed if a receiver is ready.\nA send on a buffered channel can proceed if there is room in the buffer.\nA send on a closed channel proceeds by causing a\nrun-time panic\nA send on a\nchannel blocks forever.\nch <- 3  // send value 3 to channel ch\nIf the type of the channel expression is a\ntype parameter\nall types in its type set must be channel types that permit send operations,\nthey must all have the same element type,\nand the type of the value to be sent must be assignable to that element type.\nIncDec statements\nThe \"++\" and \"--\" statements increment or decrement their operands\nby the untyped\nAs with an assignment, the operand must be\naddressable\nor a map index expression.\n( \"++\" | \"--\" ) .\nThe following\nassignment statements\nare semantically\nequivalent:\nIncDec statement    Assignment\nx++                 x += 1\nx--                 x -= 1\nAssignment statements\nreplaces the current value stored in a\nwith a new value specified by an\nAn assignment statement may assign a single value to a single variable, or multiple values to a\nmatching number of variables.\nExpressionList\nExpressionList\nEach left-hand side operand must be\naddressable\na map index expression, or (for\nassignments only) the\nblank identifier\nOperands may be parenthesized.\n(k) = <-ch  // same as: k = <-ch\nassignment operation\nis a binary\narithmetic operator\nis equivalent to\nbut evaluates\nonly once.  The\nconstruct is a single token.\nIn assignment operations, both the left- and right-hand expression lists\nmust contain exactly one single-valued expression, and the left-hand\nexpression must not be the blank identifier.\nA tuple assignment assigns the individual elements of a multi-valued\noperation to a list of variables.  There are two forms.  In the\nfirst, the right hand operand is a single multi-valued expression\nsuch as a function call, a\noperation, or a\ntype assertion\nThe number of operands on the left\nhand side must match the number of values.  For instance, if\nis a function returning two values,\nassigns the first value to\nand the second to\nIn the second form, the number of operands on the left must equal the number\nof expressions on the right, each of which must be single-valued, and the\nth expression on the right is assigned to the\noperand on the left:\none, two, three = '一', '二', '三'\nblank identifier\nprovides a way to\nignore right-hand side values in an assignment:\n_ = x       // evaluate x but ignore it\nx, _ = f()  // evaluate f() but ignore second result value\nThe assignment proceeds in two phases.\nFirst, the operands of\nindex expressions\npointer indirections\n(including implicit pointer indirections in\non the left and the expressions on the right are all\nevaluated in the usual order\nSecond, the assignments are carried out in left-to-right order.\nIn assignments, each value must be\nto the type of the operand to which it is assigned, with the following special cases:\nAny typed value may be assigned to the blank identifier.\nIf an untyped constant\nis assigned to a variable of interface type or the blank identifier,\nthe constant is first implicitly\ndefault type\nIf an untyped boolean value is assigned to a variable of interface type or\nthe blank identifier, it is first implicitly converted to type\nWhen a value is assigned to a variable, only the data that is stored in the variable\nis replaced. If the value contains a\nthe assignment copies the reference but does not make a copy of the referenced data\n(such as the underlying array of a slice).\nIf statements\n\"If\" statements specify the conditional execution of two branches\naccording to the value of a boolean expression.  If the expression\nevaluates to true, the \"if\" branch is executed, otherwise, if\npresent, the \"else\" branch is executed.\nif x > max {\nThe expression may be preceded by a simple statement, which\nexecutes before the expression is evaluated.\nif x := f(); x < y {\n} else if x > z {\nSwitch statements\n\"Switch\" statements provide multi-way execution.\nAn expression or type is compared to the \"cases\"\ninside the \"switch\" to determine which branch\nto execute.\nExprSwitchStmt\nTypeSwitchStmt\nThere are two forms: expression switches and type switches.\nIn an expression switch, the cases contain expressions that are compared\nagainst the value of the switch expression.\nIn a type switch, the cases contain types that are compared against the\ntype of a specially annotated switch expression.\nThe switch expression is evaluated exactly once in a switch statement.\nExpression switches\nIn an expression switch,\nthe switch expression is evaluated and\nthe case expressions, which need not be constants,\nare evaluated left-to-right and top-to-bottom; the first one that equals the\nswitch expression\ntriggers execution of the statements of the associated case;\nthe other cases are skipped.\nIf no case matches and there is a \"default\" case,\nits statements are executed.\nThere can be at most one default case and it may appear anywhere in the\n\"switch\" statement.\nA missing switch expression is equivalent to the boolean value\nIf the switch expression evaluates to an untyped constant, it is first implicitly\ndefault type\nThe predeclared untyped value\ncannot be used as a switch expression.\nThe switch expression type must be\nIf a case expression is untyped, it is first implicitly\nto the type of the switch expression.\nFor each (possibly converted) case expression\nand the value\nof the switch expression,\nmust be a valid\nIn other words, the switch expression is treated as if it were used to declare and\ninitialize a temporary variable\nwithout explicit type; it is that\nagainst which each case expression\nfor equality.\nIn a case or default clause, the last non-empty statement\nmay be a (possibly\n\"fallthrough\" statement\nindicate that control should flow from the end of this clause to\nthe first statement of the next clause.\nOtherwise control flows to the end of the \"switch\" statement.\nA \"fallthrough\" statement may appear as the last statement of all\nbut the last clause of an expression switch.\nThe switch expression may be preceded by a simple statement, which\nexecutes before the expression is evaluated.\nImplementation restriction: A compiler may disallow multiple case\nexpressions evaluating to the same constant.\nFor instance, the current compilers disallow duplicate integer,\nfloating point, or string constants in case expressions.\nType switches\nA type switch compares types rather than values. It is otherwise similar\nto an expression switch. It is marked by a special switch expression that\nhas the form of a\ntype assertion\nusing the keyword\nrather than an actual type:\nswitch x.(type) {\nCases then match actual types\nagainst the dynamic type of the\n. As with type assertions,\ninterface type\n, but not a\ntype parameter\n, and each non-interface type\nlisted in a case must implement the type of\nThe types listed in the cases of a type switch must all be\nThe TypeSwitchGuard may include a\nshort variable declaration\nWhen that form is used, the variable is declared at the end of the\nTypeSwitchCase in the\nimplicit block\nof each clause.\nIn clauses with a case listing exactly one type, the variable\nhas that type; otherwise, the variable has the type of the expression\nin the TypeSwitchGuard.\nInstead of a type, a case may use the predeclared identifier\nthat case is selected when the expression in the TypeSwitchGuard\ninterface value.\nThere may be at most one\nGiven an expression\ninterface{}\nthe following type switch:\ncould be rewritten:\ntype parameter\ngeneric type\nmay be used as a type in a case. If upon\ninstantiation\nthat type turns\nout to duplicate another entry in the switch, the first matching case is chosen.\nThe type switch guard may be preceded by a simple statement, which\nexecutes before the guard is evaluated.\nThe \"fallthrough\" statement is not permitted in a type switch.\nFor statements\nA \"for\" statement specifies repeated execution of a block. There are three forms:\nThe iteration may be controlled by a single condition, a \"for\" clause, or a \"range\" clause.\nRangeClause\nFor statements with single condition\nIn its simplest form, a \"for\" statement specifies the repeated execution of\na block as long as a boolean condition evaluates to true.\nThe condition is evaluated before each iteration.\nIf the condition is absent, it is equivalent to the boolean value\nfor a < b {\nFor statements with\nA \"for\" statement with a ForClause is also controlled by its condition, but\nadditionally it may specify an\nstatement, such as an assignment,\nan increment or decrement statement. The init statement may be a\nshort variable declaration\n, but the post statement must not.\nfor i := 0; i < 10; i++ {\nIf non-empty, the init statement is executed once before evaluating the\ncondition for the first iteration;\nthe post statement is executed after each execution of the block (and\nonly if the block was executed).\nAny element of the ForClause may be empty but the\nrequired unless there is only a condition.\nIf the condition is absent, it is equivalent to the boolean value\nEach iteration has its own separate declared variable (or variables)\nThe variable used by the first iteration is declared by the init statement.\nThe variable used by each subsequent iteration is declared implicitly before\nexecuting the post statement and initialized to the value of the previous\niteration's variable at that moment.\n], iterations share one set of variables\ninstead of having their own separate variables.\nIn that case, the example above prints\nFor statements with\nA \"for\" statement with a \"range\" clause\niterates through all entries of an array, slice, string or map, values received on\na channel, integer values from zero to an upper limit [\nor values passed to an iterator function's yield function [\nFor each entry it assigns\niteration values\nto corresponding\niteration variables\nif present and then executes the block.\nRangeClause\nExpressionList\nIdentifierList\n\":=\" ] \"range\"\nThe expression on the right in the \"range\" clause is called the\nrange expression\nwhich may be an array, pointer to an array, slice, string, map, channel permitting\nreceive operations\n, an integer, or\na function with specific signature (see below).\nAs with an assignment, if present the operands on the left must be\naddressable\nor map index expressions; they\ndenote the iteration variables.\nIf the range expression is a function, the maximum number of iteration variables depends on\nthe function signature.\nIf the range expression is a channel or integer, at most one iteration variable is permitted;\notherwise there may be up to two.\nIf the last iteration variable is the\nblank identifier\nthe range clause is equivalent to the same clause without that identifier.\nThe range expression\nis evaluated before beginning the loop,\nwith one exception: if at most one iteration variable is present and\nthe range expression is not evaluated.\nFunction calls on the left are evaluated once per iteration.\nFor each iteration, iteration values are produced as follows\nif the respective iteration variables are present:\nFor an array, pointer to array, or slice value\n, the index iteration\nvalues are produced in increasing order, starting at element index 0.\nIf at most one iteration variable is present, the range loop produces\niteration values from 0 up to\nand does not index into the array\nor slice itself. For a\nslice, the number of iterations is 0.\nFor a string value, the \"range\" clause iterates over the Unicode code points\nin the string starting at byte index 0.  On successive iterations, the index value will be the\nindex of the first byte of successive UTF-8-encoded code points in the string,\nand the second value, of type\n, will be the value of\nthe corresponding code point. If the iteration encounters an invalid\nUTF-8 sequence, the second value will be\nthe Unicode replacement character, and the next iteration will advance\na single byte in the string.\nThe iteration order over maps is not specified\nand is not guaranteed to be the same from one iteration to the next.\nIf a map entry that has not yet been reached is removed during iteration,\nthe corresponding iteration value will not be produced. If a map entry is\ncreated during iteration, that entry may be produced during the iteration or\nmay be skipped. The choice may vary for each entry created and from one\niteration to the next.\nIf the map is\n, the number of iterations is 0.\nFor channels, the iteration values produced are the successive values sent on\nthe channel until the channel is\n. If the channel\n, the range expression blocks forever.\nFor an integer value\ninteger type\nor an untyped\ninteger constant\n, the iteration values 0 through\nare produced in increasing order.\nis of integer type, the iteration values have that same type.\nOtherwise, the type of\nis determined as if it were assigned to the\niteration variable.\nSpecifically:\nif the iteration variable is preexisting, the type of the iteration values is the type of the iteration\nvariable, which must be of integer type.\nOtherwise, if the iteration variable is declared by the \"range\" clause or is absent,\nthe type of the iteration values is the\ndefault type\n<= 0, the loop does not run any iterations.\nFor a function\n, the iteration proceeds by calling\nwith a new, synthesized\nfunction as its argument.\nis called before\nthe arguments to\nbecome the iteration values\nfor executing the loop body once.\nAfter each successive loop iteration,\nreturns true\nand may be called again to continue the loop.\nAs long as the loop body does not terminate, the \"range\" clause will continue\nto generate iteration values this way for each\nIf the loop body terminates (such as by a\nstatement),\nreturns false and must not be called again.\nThe iteration variables may be declared by the \"range\" clause using a form of\nshort variable declaration\nIn this case their\nis the block of the \"for\" statement\nand each iteration has its own new variables [\n\"for\" statements with a ForClause\nThe variables have the types of their respective iteration values.\nIf the iteration variables are not explicitly declared by the \"range\" clause,\nthey must be preexisting.\nIn this case, the iteration values are assigned to the respective variables\nassignment statement\nIf the type of the range expression is a\ntype parameter\nall types in its type set must have the same underlying type and the range expression must be valid\nfor that type, or, if the type set contains channel types, it must only contain channel types with\nidentical element types, and all channel types must permit receive operations.\nGo statements\nA \"go\" statement starts the execution of a function call\nas an independent concurrent thread of control, or\nwithin the same address space.\nThe expression must be a function or method call; it cannot be parenthesized.\nCalls of built-in functions are restricted as for\nexpression statements\nThe function value and parameters are\nevaluated as usual\nin the calling goroutine, but\nunlike with a regular call, program execution does not wait\nfor the invoked function to complete.\nInstead, the function begins executing independently\nin a new goroutine.\nWhen the function terminates, its goroutine also terminates.\nIf the function has any return values, they are discarded when the\nfunction completes.\ngo Server()\ngo func(ch chan<- bool) { for { sleep(10); ch <- true }} (c)\nSelect statements\nA \"select\" statement chooses which of a set of possible\noperations will proceed.\nIt looks similar to a\nstatement but with the\ncases all referring to communication operations.\nA case with a RecvStmt may assign the result of a RecvExpr to one or\ntwo variables, which may be declared using a\nshort variable declaration\nThe RecvExpr must be a (possibly parenthesized) receive operation.\nThere can be at most one default case and it may appear anywhere\nin the list of cases.\nExecution of a \"select\" statement proceeds in several steps:\nFor all the cases in the statement, the channel operands of receive operations\nand the channel and right-hand-side expressions of send statements are\nevaluated exactly once, in source order, upon entering the \"select\" statement.\nThe result is a set of channels to receive from or send to,\nand the corresponding values to send.\nAny side effects in that evaluation will occur irrespective of which (if any)\ncommunication operation is selected to proceed.\nExpressions on the left-hand side of a RecvStmt with a short variable declaration\nor assignment are not yet evaluated.\nIf one or more of the communications can proceed,\na single one that can proceed is chosen via a uniform pseudo-random selection.\nOtherwise, if there is a default case, that case is chosen.\nIf there is no default case, the \"select\" statement blocks until\nat least one of the communications can proceed.\nUnless the selected case is the default case, the respective communication\noperation is executed.\nIf the selected case is a RecvStmt with a short variable declaration or\nan assignment, the left-hand side expressions are evaluated and the\nreceived value (or values) are assigned.\nThe statement list of the selected case is executed.\nSince communication on\nchannels can never proceed,\na select with only\nchannels and no default case blocks forever.\nReturn statements\nA \"return\" statement in a function\nterminates the execution\n, and optionally provides one or more result values.\nAny functions\nare executed before\nreturns to its caller.\n= \"return\" [\nExpressionList\nIn a function without a result type, a \"return\" statement must not\nspecify any result values.\nfunc noResult() {\nThere are three ways to return values from a function with a result\nThe return value or values may be explicitly listed\nin the \"return\" statement. Each expression must be single-valued\nto the corresponding element of the function's result type.\nfunc simpleF() int {\nfunc complexF1() (re float64, im float64) {\nreturn -7.0, -4.0\nThe expression list in the \"return\" statement may be a single\ncall to a multi-valued function. The effect is as if each value\nreturned from that function were assigned to a temporary\nvariable with the type of the respective value, followed by a\n\"return\" statement listing these variables, at which point the\nrules of the previous case apply.\nfunc complexF2() (re float64, im float64) {\nreturn complexF1()\nThe expression list may be empty if the function's result\ntype specifies names for its\nresult parameters\nThe result parameters act as ordinary local variables\nand the function may assign values to them as necessary.\nThe \"return\" statement returns the values of these variables.\nRegardless of how they are declared, all the result values are initialized to\nzero values\nfor their type upon entry to the\nfunction. A \"return\" statement that specifies results sets the result parameters before\nany deferred functions are executed.\nImplementation restriction: A compiler may disallow an empty expression list\nin a \"return\" statement if a different entity (constant, type, or variable)\nwith the same name as a result parameter is in\nat the place of the return.\nBreak statements\nA \"break\" statement terminates execution of the innermost\nwithin the same function.\n= \"break\" [\nIf there is a label, it must be that of an enclosing\n\"for\", \"switch\", or \"select\" statement,\nand that is the one whose execution terminates.\nContinue statements\nA \"continue\" statement begins the next iteration of the\ninnermost enclosing\nby advancing control to the end of the loop block.\nThe \"for\" loop must be within the same function.\nContinueStmt\n= \"continue\" [\nIf there is a label, it must be that of an enclosing\n\"for\" statement, and that is the one whose execution\nGoto statements\nA \"goto\" statement transfers control to the statement with the corresponding label\nwithin the same function.\nExecuting the \"goto\" statement must not cause any variables to come into\nthat were not already in scope at the point of the goto.\nFor instance, this example:\ngoto L  // BAD\nis erroneous because the jump to label\nthe creation of\nA \"goto\" statement outside a\ncannot jump to a label inside that block.\nFor instance, this example:\nif n%2 == 1 {\nfor n > 0 {\nis erroneous because the label\nthe \"for\" statement's block but the\nFallthrough statements\nA \"fallthrough\" statement transfers control to the first statement of the\nnext case clause in an\nexpression \"switch\" statement\nIt may be used only as the final non-empty statement in such a clause.\nFallthroughStmt\n= \"fallthrough\" .\nDefer statements\nA \"defer\" statement invokes a function whose execution is deferred\nto the moment the surrounding function returns, either because the\nsurrounding function executed a\nreturn statement\nreached the end of its\nfunction body\nor because the corresponding goroutine is\nThe expression must be a function or method call; it cannot be parenthesized.\nCalls of built-in functions are restricted as for\nexpression statements\nEach time a \"defer\" statement\nexecutes, the function value and parameters to the call are\nevaluated as usual\nand saved anew but the actual function is not invoked.\nInstead, deferred functions are invoked immediately before\nthe surrounding function returns, in the reverse order\nthey were deferred. That is, if the surrounding function\nreturns through an explicit\nreturn statement\ndeferred functions are executed\nany result parameters are set\nby that return statement but\nthe function returns to its caller.\nIf a deferred function value evaluates\n, execution\nwhen the function is invoked, not when the \"defer\" statement is executed.\nFor instance, if the deferred function is\nfunction literal\nand the surrounding\nfunction has\nnamed result parameters\nare in scope within the literal, the deferred function may access and modify\nthe result parameters before they are returned.\nIf the deferred function has any return values, they are discarded when\nthe function completes.\n(See also the section on\nhandling panics\nBuilt-in functions\nBuilt-in functions are\npredeclared\nThey are called like any other function but some of them\naccept a type instead of an expression as the first argument.\nThe built-in functions do not have standard Go types,\nso they can only appear in\ncall expressions\nthey cannot be used as function values.\nAppending to and copying slices\nThe built-in functions\ncommon slice operations.\nFor both functions, the result is independent of whether the memory referenced\nby the arguments overlaps.\nappends zero or more values\nand returns the resulting slice, also of type\nare passed to a parameter of type\nis the element type of\nand the respective\npassing rules\nAs a special case,\nalso accepts a first argument assignable\nwith a second argument of string type followed by\nThis form appends the bytes of the string.\nappend(s S, x ...E) S  // E is the element type of S\ntype parameter\nall types in its type set must have the same underlying slice type\nIf the capacity of\nis not large enough to fit the additional\na new, sufficiently large underlying\narray that fits both the existing slice elements and the additional values.\nre-uses the underlying array.\nThe function\ncopies slice elements from\nto a destination\nand returns the\nnumber of elements copied.\nBoth arguments must have\nelement type\nand must be assignable to a slice of type\nThe number of elements copied is the minimum of\nAs a special case,\nalso accepts a destination argument\nassignable to type\nwith a source argument of a\nThis form copies the bytes from the string into the byte slice.\ncopy(dst, src []T) int\ncopy(dst []byte, src string) int\nIf the type of one or both arguments is a\ntype parameter\nall types in their respective type sets must have the same underlying slice type\nThe built-in function\ntakes an argument of\ntype parameter\nand deletes or zeroes out all elements\nIf the type of the argument to\ntype parameter\nall types in its type set must be maps or slices, and\nperforms the operation corresponding to the actual type argument.\nIf the map or slice is\nis a no-op.\nFor a channel\n, the built-in function\nrecords that no more values will be sent on the channel.\nIt is an error if\nis a receive-only channel.\nSending to or closing a closed channel causes a\nrun-time panic\nClosing the nil channel also causes a\nrun-time panic\nAfter calling\n, and after any previously\nsent values have been received, receive operations will return\nthe zero value for the channel's type without blocking.\nThe multi-valued\nreceive operation\nreturns a received value along with an indication of whether the channel is closed.\nIf the type of the argument to\ntype parameter\nall types in its type set must be channels with the same element type.\nIt is an error if any of those channels is a receive-only channel.\nManipulating complex numbers\nThree functions assemble and disassemble complex numbers.\nThe built-in function\nconstructs a complex\nvalue from a floating-point real and imaginary part, while\nextract the real and imaginary parts of a complex value.\ncomplex(realPart, imaginaryPart floatT) complexT\nreal(complexT) floatT\nimag(complexT) floatT\nThe type of the arguments and return value correspond.\n, the two arguments must be of the same\nfloating-point type\nand the return type is the\ncomplex type\nwith the corresponding floating-point constituents:\narguments, and\nIf one of the arguments evaluates to an untyped constant, it is first implicitly\nto the type of the other argument.\nIf both arguments evaluate to untyped constants, they must be non-complex\nnumbers or their imaginary parts must be zero, and the return value of\nthe function is an untyped complex constant.\n, the argument must be\nof complex type, and the return type is the corresponding floating-point\nargument, and\nIf the argument evaluates to an untyped constant, it must be a number,\nand the return value of the function is an untyped floating-point constant.\nfunctions together form the inverse of\n, so for a value\nof a complex type\nz == Z(complex(real(z), imag(z)))\nIf the operands of these functions are all constants, the return\nvalue is a constant.\nArguments of type parameter type are not permitted.\nDeletion of map elements\nThe built-in function\nremoves the element with key\nto the key type of\ndelete(m, k)  // remove element m[k] from map m\nIf the type of\ntype parameter\nall types in that type set must be maps, and they must all have identical key types.\nor the element\ndoes not exist,\nis a no-op.\nLength and capacity\nThe built-in functions\ntake arguments\nof various types and return a result of type\nThe implementation guarantees that the result always fits into an\nIf the argument type is a\ntype parameter\nrespectively) must be valid for\neach type in\n's type set.\nThe result is the length (or capacity, respectively) of the argument whose type\ncorresponds to the type argument with which\ninstantiated\nThe capacity of a slice is the number of elements for which there is\nspace allocated in the underlying array.\nAt any time the following relationship holds:\n0 <= len(s) <= cap(s)\nThe length of a\nslice, map or channel is 0.\nThe capacity of a\nslice or channel is 0.\nThe expression\nis a string constant. The expressions\nare constants if the type of\nis an array\nor pointer to an array and the expression\ndoes not contain\nchannel receives\nor (non-constant)\nfunction calls\n; in this case\nis not evaluated.\nOtherwise, invocations of\nconstant and\nis evaluated.\nMaking slices, maps and channels\nThe built-in function\ntakes a type\nwhich must be a slice, map or channel type, or a type parameter,\noptionally followed by a type-specific list of expressions.\nIt returns a value of type\nThe memory is initialized as described in the section on\ninitial values\nIf the first argument is a\ntype parameter\nall types in its type set must have the same underlying type, which must be a slice\nor map type, or, if there are channel types, there must only be channel types, they\nmust all have the same element type, and the channel directions must not conflict.\nEach of the size arguments\ninteger type\ncontaining only integer types,\nor be an untyped\nA constant size argument must be non-negative and\nrepresentable\nby a value of type\n; if it is an untyped constant it is given type\nare provided and are constant, then\nmust be no larger than\nFor slices and channels, if\nis negative or larger than\nat run time,\nrun-time panic\nwith a map type and size hint\ncreate a map with initial space to hold\nmap elements.\nThe precise behavior is implementation-dependent.\nMin and max\nThe built-in functions\ncompute the\nsmallest—or largest, respectively—value of a fixed number of\narguments of\nordered types\nThere must be at least one argument\nThe same type rules as for\nis valid if\nand the type of\nis the type of\n(and similarly for\nIf all arguments are constant, the result is constant.\nFor numeric arguments, assuming all NaNs are equal,\ncommutative and associative:\nmin(x, y)    == min(y, x)\nmin(x, y, z) == min(min(x, y), z) == min(x, min(y, z))\nFor floating-point arguments negative zero, NaN, and infinity the following rules apply:\nFor string arguments the result for\nis the first argument\nwith the smallest (or for\n, largest) value,\ncompared lexically byte-wise:\nmin(x, y)    == if x <= y then x else y\nmin(x, y, z) == min(min(x, y), z)\nThe built-in function\ntakes a type\nallocates storage for a\nof that type\nat run time, and returns a value of type\nThe variable is initialized as described in the section on\ninitial values\nFor instance\ntype S struct { a int; b float64 }\nallocates storage for a variable of type\ninitializes it (\nand returns a value of type\ncontaining the address\nof the location.\nHandling panics\nTwo built-in functions,\nassist in reporting and handling\nrun-time panics\nand program-defined error conditions.\nfunc panic(interface{})\nfunc recover() interface{}\nWhile executing a function\nan explicit call to\nrun-time panic\nterminates the execution of\nAny functions\nare then executed as usual.\nNext, any deferred functions run by\n's caller are run,\nand so on up to any deferred by the top-level function in the executing goroutine.\nAt that point, the program is terminated and the error\ncondition is reported, including the value of the argument to\nThis termination sequence is called\npanic(\"unreachable\")\npanic(Error(\"cannot parse\"))\nfunction allows a program to manage behavior\nof a panicking goroutine.\nSuppose a function\ndefers a function\nand a panic occurs in a function on the same goroutine in which\nis executing.\nWhen the running of deferred functions reaches\nthe return value of\nwill be the value passed to the call of\nreturns normally, without starting a new\n, the panicking sequence stops. In that case,\nthe state of functions called between\nand the call to\nis discarded, and normal execution resumes.\nAny functions deferred by\nare then run and\nexecution terminates by returning to its caller.\nThe return value of\ngoroutine is not panicking or\nwas not called directly by a deferred function.\nConversely, if a goroutine is panicking and\nwas called directly by a deferred function,\nthe return value of\nis guaranteed not to be\nTo ensure this, calling\ninterface value (or an untyped\nrun-time panic\nfunction in the example below invokes\nthe function argument\nand protects callers from\nrun-time panics caused by\nBootstrapping\nCurrent implementations provide several built-in functions useful during\nbootstrapping. These functions are documented for completeness but are not\nguaranteed to stay in the language. They do not return a result.\nImplementation restriction:\naccept arbitrary argument types, but printing of boolean, numeric, and string\nmust be supported.\nGo programs are constructed by linking together\nA package in turn is constructed from one or more source files\nthat together declare constants, types, variables and functions\nbelonging to the package and which are accessible in all files\nof the same package. Those elements may be\nand used in another package.\nSource file organization\nEach source file consists of a package clause defining the package\nto which it belongs, followed by a possibly empty set of import\ndeclarations that declare packages whose contents it wishes to use,\nfollowed by a possibly empty set of declarations of functions,\ntypes, variables, and constants.\nPackageClause\nTopLevelDecl\nPackage clause\nA package clause begins each source file and defines the package\nto which the file belongs.\nPackageClause\n= \"package\"\nPackageName\nPackageName\nThe PackageName must not be the\nblank identifier\npackage math\nA set of files sharing the same PackageName form the implementation of a package.\nAn implementation may require that all source files for a package inhabit the same directory.\nImport declarations\nAn import declaration states that the source file containing the declaration\ndepends on functionality of the\n§Program initialization and execution\nand enables access to\nidentifiers\nof that package.\nThe import names an identifier (PackageName) to be used for access and an ImportPath\nthat specifies the package to be imported.\nThe PackageName is used in\nqualified identifiers\nto access exported identifiers of the package within the importing source file.\nIt is declared in the\nIf the PackageName is omitted, it defaults to the identifier specified in the\npackage clause\nof the imported package.\nIf an explicit period (\n) appears instead of a name, all the\npackage's exported identifiers declared in that package's\npackage block\nwill be declared in the importing source\nfile's file block and must be accessed without a qualifier.\nThe interpretation of the ImportPath is implementation-dependent but\nit is typically a substring of the full file name of the compiled\npackage and may be relative to a repository of installed packages.\nImplementation restriction: A compiler may restrict ImportPaths to\nnon-empty strings using only characters belonging to\nL, M, N, P, and S general categories (the Graphic characters without\nspaces) and may also exclude the characters\n!\"#$%&'()*,:;<=>?[\\]^`{|}\nand the Unicode replacement character U+FFFD.\nConsider a compiled a package containing the package clause\npackage math\n, which exports function\ninstalled the compiled package in the file identified by\nThis table illustrates how\nis accessed in files\nthat import the package after the\nvarious types of import declaration.\nAn import declaration declares a dependency relation between\nthe importing and imported package.\nIt is illegal for a package to import itself, directly or indirectly,\nor to directly import a package without\nreferring to any of its exported identifiers. To import a package solely for\nits side-effects (initialization), use the\nidentifier as explicit package name:\nimport _ \"lib/math\"\nAn example package\nHere is a complete Go package that implements a concurrent prime sieve.\nProgram initialization and execution\nThe zero value\nWhen storage is allocated for a\neither through a declaration or a call of\na new value is created, either through a composite literal or a call\nand no explicit initialization is provided, the variable or value is\ngiven a default value.  Each element of such a variable or value is\nfor its type:\nfor booleans,\nfor numeric types,\nfor strings, and\nfor pointers, functions, interfaces, slices, channels, and maps.\nThis initialization is done recursively, so for instance each element of an\narray of structs will have its fields zeroed if no value is specified.\nThese two simple declarations are equivalent:\nvar i int = 0\ntype T struct { i int; f float64; next *T }\nt := new(T)\nthe following holds:\nt.next == nil\nThe same would also be true after\nPackage initialization\nWithin a package, package-level variable initialization proceeds stepwise,\nwith each step selecting the variable earliest in\ndeclaration order\nwhich has no dependencies on uninitialized variables.\nMore precisely, a package-level variable is considered\ninitialization\nif it is not yet initialized and either has\ninitialization expression\nits initialization expression has no\ndependencies\non uninitialized variables.\nInitialization proceeds by repeatedly initializing the next package-level\nvariable that is earliest in declaration order and ready for initialization,\nuntil there are no variables ready for initialization.\nIf any variables are still uninitialized when this\nprocess ends, those variables are part of one or more initialization cycles,\nand the program is not valid.\nMultiple variables on the left-hand side of a variable declaration initialized\nby single (multi-valued) expression on the right-hand side are initialized\ntogether: If any of the variables on the left-hand side is initialized, all\nthose variables are initialized in the same step.\nvar a, b = f() // a and b are initialized together, before x is initialized\nFor the purpose of package initialization,\nvariables are treated like any other variables in declarations.\nThe declaration order of variables declared in multiple files is determined\nby the order in which the files are presented to the compiler: Variables\ndeclared in the first file are declared before any of the variables declared\nin the second file, and so on.\nTo ensure reproducible initialization behavior, build systems are encouraged\nto present multiple files belonging to the same package in lexical file name\norder to a compiler.\nDependency analysis does not rely on the actual values of the\nvariables, only on lexical\nto them in the source,\nanalyzed transitively. For instance, if a variable\ninitialization expression refers to a function whose body refers to\nSpecifically:\nA reference to a variable or function is an identifier denoting that\nvariable or function.\nA reference to a method\nmethod value\nmethod expression\nof the form\n, where the (static) type of\nnot an interface type, and the method\nIt is immaterial whether the resulting function value\nis invoked.\nA variable, function, or method\ndepends on a variable\n's initialization expression or body\n(for functions and methods) contains a reference to\nor to a function or method that depends on\nFor example, given the declarations\nthe initialization order is\nNote that the order of subexpressions in initialization expressions is irrelevant:\nresult in the same initialization\norder in this example.\nDependency analysis is performed per package; only references referring\nto variables, functions, and (non-interface) methods declared in the current\npackage are considered. If other, hidden, data dependencies exists between\nvariables, the initialization order between those variables is unspecified.\nFor instance, given the declarations\nthe variable\nwill be initialized after\nis initialized before\nthus also the moment at which\nsideEffect()\nis called (before\nis initialized) is not specified.\nVariables may also be initialized using functions named\ndeclared in the package block, with no arguments and no result parameters.\nfunc init() { … }\nMultiple such functions may be defined per package, even within a single\nsource file. In the package block, the\nidentifier can\nbe used only to declare\nfunctions, yet the identifier\nitself is not\nfunctions cannot be referred to from anywhere\nin a program.\nThe entire package is initialized by assigning initial values\nto all its package-level variables followed by calling\nfunctions in the order they appear\nin the source, possibly in multiple files, as presented\nto the compiler.\nProgram initialization\nThe packages of a complete program are initialized stepwise, one package at a time.\nIf a package has imports, the imported packages are initialized\nbefore initializing the package itself. If multiple packages import\na package, the imported package will be initialized only once.\nThe importing of packages, by construction, guarantees that there\ncan be no cyclic initialization dependencies.\nMore precisely:\nGiven the list of all packages, sorted by import path, in each step the first\nuninitialized package in the list for which all imported packages (if any) are\nalready initialized is\ninitialized\nThis step is repeated until all packages are initialized.\nPackage initialization—variable initialization and the invocation of\nfunctions—happens in a single goroutine,\nsequentially, one package at a time.\nfunction may launch other goroutines, which can run\nconcurrently with the initialization code. However, initialization\nalways sequences\nfunctions: it will not invoke the next one\nuntil the previous one has returned.\nProgram execution\nA complete program is created by linking a single, unimported package\nmain package\nwith all the packages it imports, transitively.\nThe main package must\nhave package name\ndeclare a function\nthat takes no\narguments and returns no value.\nfunc main() { … }\nProgram execution begins by\ninitializing the program\nand then invoking the function\nWhen that function invocation returns, the program exits.\nIt does not wait for other (non-\n) goroutines to complete.\nThe predeclared type\nis defined as\ntype error interface {\nError() string\nIt is the conventional interface for representing an error condition,\nwith the nil value representing no error.\nFor instance, a function to read data from a file might be defined:\nfunc Read(f *File, b []byte) (n int, err error)\nRun-time panics\nExecution errors such as attempting to index an array out\nof bounds trigger a\nrun-time panic\nequivalent to a call of\nthe built-in function\nwith a value of the implementation-defined interface type\nruntime.Error\nThat type satisfies the predeclared interface type\nThe exact error values that\nrepresent distinct run-time error conditions are unspecified.\npackage runtime\ntype Error interface {\nSystem considerations\nThe built-in package\n, known to the compiler\nand accessible through the\nimport path\nprovides facilities for low-level programming including operations\nthat violate the type system. A package using\nmust be vetted manually for type safety and may not be portable.\nThe package provides the following interface:\npointer type\nvalue may not be\ndereferenced\nAny pointer or value of\nunderlying type\nto a type of underlying type\nand vice versa.\nIf the respective types are\ntype parameters\n, all types in\ntheir respective type sets must have the same underlying type, which must be\n, respectively.\nThe effect of converting between\nis implementation-defined.\nThe functions\ntake an expression\nof any type and return the alignment or size, respectively, of a hypothetical variable\nwere declared via\nThe function\ntakes a (possibly parenthesized)\n, denoting a field\nof the struct denoted by\n, and returns the field offset in bytes relative to the struct's address.\nembedded field\n, it must be reachable\nwithout pointer indirections through fields of the struct.\nFor a struct\nuintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&s.f))\nComputer architectures may require memory addresses to be\nthat is, for addresses of a variable to be a multiple of a factor,\nthe variable's type's\n.  The function\ntakes an expression denoting a variable of any type and returns the\nalignment of the (type of the) variable in bytes.  For a variable\nuintptr(unsafe.Pointer(&x)) % unsafe.Alignof(x) == 0\nA (variable of) type\nvariable size\ntype parameter\n, or if it is an\narray or struct type containing elements\nor fields of variable size. Otherwise the size is\nare compile-time\nconstant expressions\nif their arguments (or the struct\nthe selector expression\n) are types\nof constant size.\nThe function\nand returns the updated pointer\nunsafe.Pointer(uintptr(ptr) + uintptr(len))\nargument must be of\ninteger type\nor an untyped\nargument must be\nrepresentable\nby a value of type\nif it is an untyped constant it is given type\nThe rules for\nstill apply.\nThe function\nreturns a slice whose underlying array starts at\nand whose length and capacity are\nSlice(ptr, len)\nis equivalent to\n(*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\nexcept that, as a special case, if\nargument must be of\ninteger type\nor an untyped\nargument must be non-negative and\nrepresentable\nby a value of type\nif it is an untyped constant it is given type\nAt run time, if\nis negative,\nis not zero,\nrun-time panic\nThe function\nreturns a pointer to the underlying array of the\nIf the slice's capacity\nis not zero, that pointer is\n&slice[:1][0]\n, the result is\nOtherwise it  is a non-\npointer to an unspecified memory address\nThe function\nvalue whose underlying bytes start at\nand whose length is\nThe same requirements apply to the\nargument as in the function\nis zero, the result is the empty string\nSince Go strings are immutable, the bytes passed to\nmust not be modified afterwards.\nThe function\nreturns a pointer to the underlying bytes of the\nFor an empty string the return value is unspecified, and may be\nSince Go strings are immutable, the bytes returned by\nmust not be modified\nSize and alignment guarantees\nnumeric types\n, the following sizes are guaranteed:\nThe following minimal alignment properties are guaranteed:\nFor a variable\nof any type:\nunsafe.Alignof(x)\nis at least 1.\nFor a variable\nof struct type:\nunsafe.Alignof(x)\nis the largest of\nall the values\nunsafe.Alignof(x.f)\nfor each field\n, but at least 1.\nFor a variable\nof array type:\nunsafe.Alignof(x)\nis the same as\nthe alignment of a variable of the array's element type.\nA struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.\nLanguage versions\nGo 1 compatibility guarantee\nensures that\nprograms written to the Go 1 specification will continue to compile and run\ncorrectly, unchanged, over the lifetime of that specification.\nMore generally, as adjustments are made and features added to the language,\nthe compatibility guarantee ensures that a Go program that works with a\nspecific Go language version will continue to work with any subsequent version.\nFor instance, the ability to use the prefix\ninteger literals was introduced with Go 1.13, indicated\n] in the section on\ninteger literals\nSource code containing an integer literal such as\nwill be rejected if the implied or required language version used by\nthe compiler is older than Go 1.13.\nThe following table describes the minimum language version required for\nfeatures introduced after Go 1.\nalias declaration\nmay be used to declare an alias name for a type.\nInteger literals\nmay use the prefixes\nfor binary, and octal literals, respectively.\nHexadecimal\nfloating-point literals\nmay be written using the prefixes\nimaginary suffix\nmay be used with any (binary, decimal, hexadecimal)\ninteger or floating-point literal, not just decimal literals.\nThe digits of any number literal may be\nusing underscores\nThe shift count in a\nshift operation\nmay be a signed integer type.\nEmdedding a method more than once through different\nembedded interfaces\nis not an error.\nA slice may be\nto an array pointer if the slice and array element\ntypes match, and the array is not longer than the slice.\nThe built-in\nincludes the new functions\nThe 1.18 release adds polymorphic functions and types (\"generics\") to the language.\nSpecifically:\noperators and punctuation\nincludes the new token\nFunction and type declarations may declare\ntype parameters\nInterface types may\nembed arbitrary types\n(not just type names of interfaces)\nas well as union and\ntype elements.\npredeclared\ntypes includes the new types\nA slice may be\nto an array if the slice and array element\ntypes match and the array is not longer than the slice.\nThe built-in\nincludes the new functions\nComparable types\n(such as ordinary interfaces) may satisfy\nconstraints, even if the type arguments are not strictly comparable.\npredeclared\nfunctions includes the new functions\nType inference\nuses the types of interface methods for inference.\nIt also infers type arguments for generic functions assigned to variables or\npassed as arguments to other (possibly generic) functions.\n\"for\" statement\n, each iteration has its own set of iteration\nvariables rather than sharing the same variables in each iteration.\nA \"for\" statement with\n\"range\" clause\nmay iterate over\ninteger values from zero to an upper limit.\nA \"for\" statement with\n\"range\" clause\naccepts an iterator\nfunction as range expression.\nalias declaration\nmay declare\ntype parameters\nType unification rules\nThe type unification rules describe if and how two types unify.\nThe precise details are relevant for Go implementations,\naffect the specifics of error messages (such as whether\na compiler reports a type inference or other error),\nand may explain why type inference fails in unusual code situations.\nBut by and large these rules can be ignored when writing Go code:\ntype inference is designed to mostly \"work as expected\",\nand the unification rules are fine-tuned accordingly.\nType unification is controlled by a\nmatching mode\n, which may\nAs unification recursively descends a composite type structure,\nthe matching mode used for elements of the type, the\nelement matching mode\nremains the same as the matching mode except when two types are unified for\nassignability\nin this case, the matching mode is\nat the top level but\nthen changes to\nfor element types, reflecting the fact\nthat types don't have to be identical to be assignable.\nTwo types that are not bound type parameters unify exactly if any of\nfollowing conditions is true:\nBoth types are\nBoth types have identical structure and their element types\nunify exactly.\nExactly one type is an\ntype parameter, and all the types in its type set unify with\nthe other type\nper the unification rules for\n(loose unification at the top level and exact unification\nfor element types).\nIf both types are bound type parameters, they unify per the given\nmatching modes if:\nBoth type parameters are identical.\nAt most one of the type parameters has a known type argument.\nIn this case, the type parameters are\nthey both stand for the same type argument.\nIf neither type parameter has a known type argument yet,\na future type argument inferred for one the type parameters\nis simultaneously inferred for both of them.\nBoth type parameters have a known type argument\nand the type arguments unify per the given matching modes.\nA single bound type parameter\nand another type\nper the given matching modes if:\ndoesn't have a known type argument.\nIn this case,\nis inferred as the type argument for\ndoes have a known type argument\nunify per the given matching modes,\nand one of the following conditions is true:\nare interface types:\nIn this case, if both\nthey must be\nOtherwise, if neither of them is a defined type, they must\nhave the same number of methods\n(unification of\nestablished that the methods match).\nare interface types:\nIn this case, if\nis a defined type,\nas the inferred type argument for\nFinally, two types that are not bound type parameters unify loosely\n(and per the element matching mode) if:\nBoth types unify exactly.\nOne type is a\ndefined type\nthe other type is a type literal, but not an interface,\nand their underlying types unify per the element matching mode.\nBoth types are interfaces (but not type parameters) with\nboth or neither embed the predeclared type\ncorresponding method types unify exactly,\nand the method set of one of the interfaces is a subset of\nthe method set of the other interface.\nOnly one type is an interface (but not a type parameter),\ncorresponding methods of the two types unify per the element matching mode,\nand the method set of the interface is a subset of\nthe method set of the other type.\nBoth types have the same structure and their element types\nunify per the element matching mode.",
  "word_count": 24993,
  "key_terms": [
    "parameter",
    "return",
    "function",
    "method",
    "import",
    "implementation",
    "variable",
    "interface"
  ]
}