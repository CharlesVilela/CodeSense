{
  "metadata": {
    "title": "Routing",
    "url": "https://expressjs.com/en/guide/routing.html",
    "technology": "express",
    "category": "frameworks",
    "english_level": "B1",
    "professional_context": "development",
    "content_type": "technical_documentation",
    "last_updated": "1761765811.187973"
  },
  "content": "refers to how an application’s endpoints (URIs) respond to client requests.\nFor an introduction to routing, see\nBasic routing\nYou define routing using methods of the Express\nobject that correspond to HTTP methods;\nfor example,\nto handle GET requests and\nto handle POST requests. For a full list,\n. You can also use\nto handle all HTTP methods and\nspecify middleware as the callback function (See\nUsing middleware\nfor details).\nThese routing methods specify a callback function (sometimes called “handler functions”) called when the application receives a request to the specified route (endpoint) and HTTP method. In other words, the application “listens” for requests that match the specified route(s) and method(s), and when it detects a match, it calls the specified callback function.\nIn fact, the routing methods can have more than one callback function as arguments.\nWith multiple callback functions, it is important to provide\nas an argument to the callback function and then call\nwithin the body of the function to hand off control\nto the next callback.\nThe following code is an example of a very basic route.\nRoute methods\nA route method is derived from one of the HTTP methods, and is attached to an instance of the\nThe following code is an example of routes that are defined for the\nmethods to the root of the app.\nExpress supports methods that correspond to all HTTP request methods:\n, and so on.\nFor a full list, see\nThere is a special routing method,\n, used to load middleware functions at a path for\nHTTP request methods. For example, the following handler is executed for requests to the route\nwhether using\n, or any other HTTP request method supported in the\nhttp module\nRoute paths\nRoute paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.\nIn express 5, the characters\nare handled differently than in version 4, please review the\nmigration guide\nfor more information.\nIn express 4, regular expression characters such as\nneed to be escaped with a\nExpress uses\npath-to-regexp\nfor matching the route paths; see the path-to-regexp documentation for all the possibilities in defining route paths.\nExpress Playground Router\nis a handy tool for testing basic Express routes, although it does not support pattern matching.\nQuery strings are not part of the route path.\nRoute paths based on strings\nThis route path will match requests to the root route,\nThis route path will match requests to\nThis route path will match requests to\n/random.text\n/random.text\nrandom.text\nRoute paths based on string patterns\nThe string patterns in Express 5 no longer work. Please refer to the\nmigration guide\nfor more information.\nThis route path will match\nThis route path will match\n, and so on.\nThis route path will match\n, and so on.\nThis route path will match\nRoute paths based on regular expressions\nThis route path will match anything with an “a” in it.\nThis route path will match\nbutterflyman\ndragonflyman\n, and so on.\nRoute parameters\nRoute parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the\nobject, with the name of the route parameter specified in the path as their respective keys.\nTo define routes with route parameters, simply specify the route parameters in the path of the route as shown below.\n/users/:userId/books/:bookId\nThe name of route parameters must be made up of “word characters” ([A-Za-z0-9_]).\nSince the hyphen (\n) and the dot (\n) are interpreted literally, they can be used along with route parameters for useful purposes.\nIn express 5, Regexp characters are not supported in route paths, for more information please refer to the\nmigration guide\nTo have more control over the exact string that can be matched by a route parameter, you can append a regular expression in parentheses (\nBecause the regular expression is usually part of a literal string, be sure to escape any\ncharacters with an additional backslash, for example\nIn Express 4.x,\ncharacter in regular expressions is not interpreted in the usual way\n. As a workaround, use\n. This will likely be fixed in Express 5.\nRoute handlers\nYou can provide multiple callback functions that behave like\nto handle a request. The only exception is that these callbacks might invoke\nnext('route')\nto bypass the remaining route callbacks. You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.\nRoute handlers can be in the form of a function, an array of functions, or combinations of both, as shown in the following examples.\nA single callback function can handle a route. For example:\nHello from A!\nMore than one callback function can handle a route (make sure you specify the\nobject). For example:\nAn array of callback functions can handle a route. For example:\nA combination of independent functions and arrays of functions can handle a route. For example:\nResponse methods\nThe methods on the response object (\n) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.\nDescription\nres.download()\nPrompt a file to be downloaded.\nEnd the response process.\nSend a JSON response.\nres.jsonp()\nSend a JSON response with JSONP support.\nres.redirect()\nRedirect a request.\nres.render()\nRender a view template.\nSend a response of various types.\nres.sendFile()\nSend a file as an octet stream.\nres.sendStatus()\nSet the response status code and send its string representation as the response body.\napp.route()\nYou can create chainable route handlers for a route path by using\napp.route()\nBecause the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see:\nRouter() documentation\nHere is an example of chained route handlers that are defined by using\napp.route()\nexpress.Router\nexpress.Router\nclass to create modular, mountable route handlers. A\ninstance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.\nThe following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.\nCreate a router file named\nin the app directory, with the following content:\nThen, load the router module in the app:\nThe app will now be able to handle requests to\n/birds/about\n, as well as call the\nmiddleware function that is specific to the route.\nBut if the parent route\nhas path parameters, it will not be accessible by default from the sub-routes. To make it accessible, you will need to pass the\nmergeParams\noption to the Router constructor\nmergeParams\nEdit this page",
  "word_count": 1151,
  "key_terms": [
    "parameter",
    "middleware",
    "class",
    "function",
    "method",
    "object"
  ]
}