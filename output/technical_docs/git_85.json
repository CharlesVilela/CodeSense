{
  "metadata": {
    "title": "Untitled",
    "url": "https://git-scm.com/docs/gittutorial",
    "technology": "git",
    "category": "tools_platforms",
    "english_level": "B1",
    "professional_context": "debugging",
    "content_type": "technical_documentation",
    "last_updated": "1761766029.5642464"
  },
  "content": "gittutorial - A tutorial introduction to Git\nThis tutorial explains how to import a new project into Git, make\nchanges to it, and share changes with other developers.\nIf you are instead primarily interested in using Git to fetch a project,\nfor example, to test the latest version, you may prefer to start with\nthe first two chapters of\nThe Git User’s Manual\nFirst, note that you can get documentation for a command such as\n$ man git-log\n$ git help log\nWith the latter, you can use the manual viewer of your choice; see\ngit-help[1]\nfor more information.\nIt is a good idea to introduce yourself to Git with your name and\npublic email address before doing any operation.  The easiest\nway to do so is:\nImporting a new project\nAssume you have a tarball\nproject.tar.gz\nwith your initial work.  You\ncan place it under Git revision control as follows.\n$ tar xzf project.tar.gz\n$ cd project\nGit will reply\nInitialized empty Git repository in .git/\nYou’ve now initialized the working directory—​you may notice a new\ndirectory created, named\nNext, tell Git to take a snapshot of the contents of all files under the\ncurrent directory (note the\n$ git add .\nThis snapshot is now stored in a temporary staging area which Git calls\nthe \"index\".  You can permanently store the contents of the index in the\nrepository with\n$ git commit\nThis will prompt you for a commit message.  You’ve now stored the first\nversion of your project in Git.\nMaking changes\nModify some files, then add their updated contents to the index:\n$ git add file1 file2 file3\nYou are now ready to commit.  You can see what is about to be committed\n$ git diff --cached\nwill show you any changes that\nyou’ve made but not yet added to the index.)  You can also get a brief\nsummary of the situation with\nIf you need to make any further adjustments, do so now, and then add any\nnewly modified content to the index.  Finally, commit your changes with:\n$ git commit\nThis will again prompt you for a message describing the change, and then\nrecord a new version of the project.\nAlternatively, instead of running\nbeforehand, you can use\n$ git commit -a\nwhich will automatically notice any modified (but not new) files, add\nthem to the index, and commit, all in one step.\nA note on commit messages: Though not required, it’s a good idea to\nbegin the commit message with a single short (no more than 50\ncharacters) line summarizing the change, followed by a blank line and\nthen a more thorough description. The text up to the first blank line in\na commit message is treated as the commit title, and that title is used\nthroughout Git.  For example,\ngit-format-patch[1]\ncommit into email, and it uses the title on the Subject line and the\nrest of the commit in the body.\nGit tracks content not files\nMany revision control systems provide an\ncommand that tells the\nsystem to start tracking changes to a new file.  Git’s\ndoes something simpler and more powerful:\nis used both for new\nand newly modified files, and in both cases it takes a snapshot of the\ngiven files and stages that content in the index, ready for inclusion in\nthe next commit.\nViewing project history\nAt any point you can view the history of your changes using\nIf you also want to see complete diffs at each step, use\n$ git log -p\nOften the overview of the change is useful to get a feel of\n$ git log --stat --summary\nManaging branches\nA single Git repository can maintain multiple branches of\ndevelopment.  To create a new branch named\nexperimental\n$ git branch experimental\nIf you now run\n$ git branch\nyou’ll get a list of all existing branches:\nexperimental\nexperimental\nbranch is the one you just created, and the\nbranch is a default branch that was created for you\nautomatically.  The asterisk marks the branch you are currently on;\n$ git switch experimental\nto switch to the\nexperimental\nbranch.  Now edit a file, commit the\nchange, and switch back to the\n(edit file)\n$ git commit -a\n$ git switch master\nCheck that the change you made is no longer visible, since it was\nmade on the\nexperimental\nbranch and you’re back on the\nYou can make a different change on the\n(edit file)\n$ git commit -a\nat this point the two branches have diverged, with different changes\nmade in each.  To merge the changes made in\nexperimental\n$ git merge experimental\nIf the changes don’t conflict, you’re done.  If there are conflicts,\nmarkers will be left in the problematic files showing the conflict;\nwill show this.  Once you’ve edited the files to resolve the\n$ git commit -a\nwill commit the result of the merge. Finally,\nwill show a nice graphical representation of the resulting history.\nAt this point you could delete the\nexperimental\nbranch with\n$ git branch -d experimental\nThis command ensures that the changes in the\nexperimental\nalready in the current branch.\nIf you develop on a branch\n, then regret it, you can always\ndelete the branch with\n$ git branch -D crazy-idea\nBranches are cheap and easy, so this is a good way to try something\nUsing Git for collaboration\nSuppose that Alice has started a new project with a Git repository in\n/home/alice/project\n, and that Bob, who has a home directory on the\nsame machine, wants to contribute.\nBob begins with:\nbob$ git clone /home/alice/project myrepo\nThis creates a new directory\ncontaining a clone of Alice’s\nrepository.  The clone is on an equal footing with the original\nproject, possessing its own copy of the original project’s history.\nBob then makes some changes and commits them:\n(edit files)\nbob$ git commit -a\n(repeat as necessary)\nWhen he’s ready, he tells Alice to pull changes from the repository\n/home/bob/myrepo\n.  She does this with:\nalice$ cd /home/alice/project\nalice$ git pull /home/bob/myrepo master\nThis merges the changes from Bob’s\nbranch into Alice’s\ncurrent branch.  If Alice has made her own changes in the meantime,\nthen she may need to manually fix any conflicts.\ncommand thus performs two operations: it fetches changes\nfrom a remote branch, then merges them into the current branch.\nNote that in general, Alice would want her local changes committed before\ninitiating this\n.  If Bob’s work conflicts with what Alice did since\ntheir histories forked, Alice will use her working tree and the index to\nresolve conflicts, and existing local changes will interfere with the\nconflict resolution process (Git will still perform the fetch but will\nrefuse to merge — Alice will have to get rid of her local changes in\nsome way and pull again when this happens).\nAlice can peek at what Bob did without merging first, using the\ncommand; this allows Alice to inspect what Bob did, using a special\n, in order to determine if he has anything worth\npulling, like this:\nalice$ git fetch /home/bob/myrepo master\nalice$ git log -p HEAD..FETCH_HEAD\nThis operation is safe even if Alice has uncommitted local changes.\nThe range notation\nmeans \"show everything that is reachable\nbut exclude anything that is reachable from\nAlice already knows everything that leads to her current state (\nand reviews what Bob has in his state (\n) that she has not\nseen with this command.\nIf Alice wants to visualize what Bob did since their histories forked\nshe can issue the following command:\n$ gitk HEAD..FETCH_HEAD\nThis uses the same two-dot range notation we saw earlier with\nAlice may want to view what both of them did since they forked.\nShe can use three-dot form instead of the two-dot form:\n$ gitk HEAD...FETCH_HEAD\nThis means \"show everything that is reachable from either one, but\nexclude anything that is reachable from both of them\".\nPlease note that these range notations can be used with both\nAfter inspecting what Bob did, if there is nothing urgent, Alice may\ndecide to continue working without pulling from Bob.  If Bob’s history\ndoes have something Alice would immediately need, Alice may choose to\nstash her work-in-progress first, do a\n, and then finally unstash\nher work-in-progress on top of the resulting history.\nWhen you are working in a small closely knit group, it is not\nunusual to interact with the same repository over and over\nagain.  By defining\nrepository shorthand, you can make\nalice$ git remote add bob /home/bob/myrepo\nWith this, Alice can perform the first part of the\nalone using the\ncommand without merging them with her own\nbranch, using:\nalice$ git fetch bob\nUnlike the longhand form, when Alice fetches from Bob using a\nremote repository shorthand set up with\nfetched is stored in a remote-tracking branch, in this case\n.  So after this:\nalice$ git log -p master..bob/master\nshows a list of all the changes that Bob made since he branched from\nAfter examining those changes, Alice\ncould merge the changes into her\nalice$ git merge bob/master\ncan also be done by\npulling from her own remote-tracking\n, like this:\nalice$ git pull . remotes/bob/master\nNote that git pull always merges into the current branch,\nregardless of what else is given on the command line.\nLater, Bob can update his repo with Alice’s latest changes using\nbob$ git pull\nNote that he doesn’t need to give the path to Alice’s repository;\nwhen Bob cloned Alice’s repository, Git stored the location of her\nrepository in the repository configuration, and that location is\nused for pulls:\nbob$ git config --get remote.origin.url\n/home/alice/project\n(The complete configuration created by\nis visible using\ngit-config[1]\nexplains the meaning of each option.)\nGit also keeps a pristine copy of Alice’s\nbranch under the\norigin/master\nbob$ git branch -r\norigin/master\nIf Bob later decides to work from a different host, he can still\nperform clones and pulls using the ssh protocol:\nbob$ git clone alice.org:/home/alice/project myrepo\nAlternatively, Git has a native protocol, or can use http;\ngit-pull[1]\nfor details.\nGit can also be used in a CVS-like mode, with a central repository\nthat various users push changes to; see\ngit-push[1]\ngitcvs-migration[7]\nExploring history\nGit history is represented as a series of interrelated commits.  We\nhave already seen that the\ncommand can list those commits.\nNote that first line of each\nentry also gives a name for the\nWe can give this name to\nto see the details about this\n$ git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7\nBut there are other ways to refer to commits.  You can use any initial\npart of the name that is long enough to uniquely identify the commit:\nEvery commit usually has one \"parent\" commit\nwhich points to the previous state of the project:\nNote that merge commits may have more than one parent:\nYou can also give commits names of your own; after running\n$ git tag v2.5 1b2e1d63ff\nyou can refer to\nby the name\n.  If you intend to\nshare this name with other people (for example, to identify a release\nversion), you should create a \"tag\" object, and perhaps sign it; see\nfor details.\nAny Git command that needs to know a commit can take any of these\nnames.  For example:\nBe careful with that last command: in addition to losing any changes\nin the working directory, it will also remove all later commits from\nthis branch.  If this branch is the only branch containing those\ncommits, they will be lost.  Also, don’t use\npublicly-visible branch that other developers pull from, as it will\nforce needless merges on other developers to clean up the history.\nIf you need to undo changes that you have pushed, use\ncommand can search for strings in any version of your\nproject, so\n$ git grep \"hello\" v2.5\nsearches for all occurrences of \"hello\" in\nIf you leave out the commit name,\nwill search any of the\nfiles it manages in your current directory.  So\n$ git grep \"hello\"\nis a quick way to search just the files that are tracked by Git.\nMany Git commands also take sets of commits, which can be specified\nin a number of ways.  Here are some examples with\nYou can also give\na \"range\" of commits where the first is not\nnecessarily an ancestor of the second; for example, if the tips of\nthe branches\ndiverged from a common\ncommit some time ago, then\n$ git log stable..master\nwill list commits made in the\nbranch but not in the\nstable branch, while\n$ git log master..stable\nwill show the list of commits made on the stable branch but not\ncommand has a weakness: it must present commits in a\nlist.  When the history has lines of development that diverged and\nthen merged back together, the order in which\nthose commits is meaningless.\nMost projects with multiple contributors (such as the Linux kernel,\nor Git itself) have frequent merges, and\ndoes a better job of\nvisualizing their history.  For example,\n$ gitk --since=\"2 weeks ago\" drivers/\nallows you to browse any commits from the last 2 weeks of commits\nthat modified files under the\ndirectory.  (Note: you can\nadjust gitk’s fonts by holding down the control key while pressing\n\"-\" or \"+\".)\nFinally, most commands that take filenames will optionally allow you\nto precede any filename by a commit, to specify a particular version\nof the file:\n$ git diff v2.5:Makefile HEAD:Makefile.in\nYou can also use\nto see any such file:\n$ git show v2.5:Makefile\nThis tutorial should be enough to perform basic distributed revision\ncontrol for your projects.  However, to fully understand the depth\nand power of Git you need to understand two simple ideas on which it\nThe object database is the rather elegant system used to\nstore the history of your project—​files, directories, and\nThe index file is a cache of the state of a directory tree,\nused to create commits, check out working directories, and\nhold the various trees involved in a merge.\nPart two of this tutorial explains the object\ndatabase, the index file, and a few other odds and ends that you’ll\nneed to make the most of Git. You can find it at\ngittutorial-2[7]\nIf you don’t want to continue with that right away, a few other\ndigressions that may be interesting at this point are:\ngit-format-patch[1]\n: These convert\nseries of git commits into emailed patches, and vice versa,\nuseful for projects such as the Linux kernel which rely heavily\non emailed patches.\ngit-bisect[1]\n: When there is a regression in your\nproject, one way to track down the bug is by searching through\nthe history to find the exact commit that’s to blame.\ncan help you perform a binary search for that commit.  It is\nsmart enough to perform a close-to-optimal search even in the\ncase of complex non-linear history with lots of merged branches.\ngitworkflows[7]\n: Gives an overview of recommended\ngiteveryday[7]\n: Everyday Git with 20 Commands Or So.\ngitcvs-migration[7]\n: Git for CVS users.\ngittutorial-2[7]\ngitcvs-migration[7]\ngitcore-tutorial[7]\ngitglossary[7]\ngit-help[1]\ngitworkflows[7]\ngiteveryday[7]\nThe Git User’s Manual\nPart of the\ngittutorial",
  "word_count": 2509,
  "key_terms": [
    "import",
    "database",
    "object",
    "configuration"
  ]
}