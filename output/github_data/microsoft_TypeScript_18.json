{
  "metadata": {
    "title": "publicApi.ts",
    "url": "https://github.com/microsoft/TypeScript/blob/main/src/testRunner/unittests/publicApi.ts",
    "repo": "microsoft/TypeScript",
    "file_path": "src/testRunner/unittests/publicApi.ts",
    "file_type": "code",
    "technology": "typescript",
    "professional_context": "api_reference",
    "english_level": "B1",
    "content_type": "github_documentation",
    "last_updated": "1761763046.324907"
  },
  "content": "import * as documents from \"../_namespaces/documents.js\";\r\nimport * as fakes from \"../_namespaces/fakes.js\";\r\nimport * as Harness from \"../_namespaces/Harness.js\";\r\nimport * as ts from \"../_namespaces/ts.js\";\r\nimport * as vfs from \"../_namespaces/vfs.js\";\r\nimport { jsonToReadableText } from \"./helpers.js\";\r\nimport { TestServerHost } from \"./helpers/virtualFileSystemWithWatch.js\";\r\n\r\ndescribe(\"unittests:: Public APIs\", () => {\r\n    function verifyApi(fileName: string) {\r\n        const builtFile = `built/local/${fileName}`;\r\n        const api = `api/${fileName}`;\r\n        let fileContent: string;\r\n        before(() => {\r\n            fileContent = Harness.IO.readFile(builtFile)!;\r\n            if (!fileContent) throw new Error(`File ${fileName} was not present in built/local`);\r\n            fileContent = fileContent.replace(/\\r\\n/g, \"\\n\");\r\n        });\r\n\r\n        it(\"should be acknowledged when they change\", () => {\r\n            Harness.Baseline.runBaseline(api, fileContent, { PrintDiff: true });\r\n        });\r\n    }\r\n\r\n    describe(\"for typescript.d.ts\", () => {\r\n        verifyApi(\"typescript.d.ts\");\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: token to string\", () => {\r\n    function assertDefinedTokenToString(initial: ts.SyntaxKind, last: ts.SyntaxKind) {\r\n        for (let t = initial; t <= last; t++) {\r\n            assert.isDefined(ts.tokenToString(t), `Expected tokenToString defined for ${ts.Debug.formatSyntaxKind(t)}`);\r\n        }\r\n    }\r\n\r\n    it(\"for punctuations\", () => {\r\n        assertDefinedTokenToString(ts.SyntaxKind.FirstPunctuation, ts.SyntaxKind.LastPunctuation);\r\n    });\r\n    it(\"for keywords\", () => {\r\n        assertDefinedTokenToString(ts.SyntaxKind.FirstKeyword, ts.SyntaxKind.LastKeyword);\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: createPrivateIdentifier\", () => {\r\n    it(\"throws when name doesn't start with #\", () => {\r\n        assert.throw(() => ts.factory.createPrivateIdentifier(\"not\"), \"Debug Failure. First character of private identifier must be #: not\");\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: JSDoc newlines\", () => {\r\n    it(\"are preserved verbatim\", () => {\r\n        const testFilePath = \"/file.ts\";\r\n        const testFileText = `\r\n/**\r\n* @example\r\n* Some\\n * text\\r\\n * with newlines.\r\n*/\r\nfunction test() {}`;\r\n\r\n        const testSourceFile = ts.createSourceFile(testFilePath, testFileText, ts.ScriptTarget.Latest, /*setParentNodes*/ true);\r\n        const funcDec = testSourceFile.statements.find(ts.isFunctionDeclaration)!;\r\n        const tags = ts.getJSDocTags(funcDec);\r\n        assert.isDefined(tags[0].comment);\r\n        assert.isDefined(tags[0].comment[0]);\r\n        assert.isString(tags[0].comment);\r\n        assert.equal(tags[0].comment as string, \"Some\\n text\\r\\n with newlines.\");\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: isPropertyName\", () => {\r\n    it(\"checks if a PrivateIdentifier is a valid property name\", () => {\r\n        const prop = ts.factory.createPrivateIdentifier(\"#foo\");\r\n        assert.isTrue(ts.isPropertyName(prop), \"PrivateIdentifier must be a valid property name.\");\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: getTypeAtLocation\", () => {\r\n    it(\"works on PropertyAccessExpression in implements clause\", () => {\r\n        const content = `namespace Test {\r\n            export interface Test {}\r\n        }\r\n        class Foo implements Test.Test {}`;\r\n\r\n        const host = new fakes.CompilerHost(vfs.createFromFileSystem(\r\n            Harness.IO,\r\n            /*ignoreCase*/ true,\r\n            { documents: [new documents.TextDocument(\"/file.ts\", content)], cwd: \"/\" },\r\n        ));\r\n\r\n        const program = ts.createProgram({\r\n            host,\r\n            rootNames: [\"/file.ts\"],\r\n            options: { noLib: true },\r\n        });\r\n\r\n        const checker = program.getTypeChecker();\r\n        const file = program.getSourceFile(\"/file.ts\")!;\r\n        const classDeclaration = file.statements.find(ts.isClassDeclaration)!;\r\n        const propertyAccess = classDeclaration.heritageClauses![0].types[0].expression as ts.PropertyAccessExpression;\r\n        const type = checker.getTypeAtLocation(propertyAccess);\r\n        assert.ok(!(type.flags & ts.TypeFlags.Any));\r\n        assert.equal(type, checker.getTypeAtLocation(propertyAccess.name));\r\n    });\r\n\r\n    it(\"works on SourceFile\", () => {\r\n        const content = `const foo = 1;`;\r\n        const host = new fakes.CompilerHost(vfs.createFromFileSystem(\r\n            Harness.IO,\r\n            /*ignoreCase*/ true,\r\n            { documents: [new documents.TextDocument(\"/file.ts\", content)], cwd: \"/\" },\r\n        ));\r\n\r\n        const program = ts.createProgram({\r\n            host,\r\n            rootNames: [\"/file.ts\"],\r\n            options: { noLib: true },\r\n        });\r\n\r\n        const checker = program.getTypeChecker();\r\n        const file = program.getSourceFile(\"/file.ts\")!;\r\n        const type = checker.getTypeAtLocation(file);\r\n        assert.equal(type.flags, ts.TypeFlags.Any);\r\n    });\r\n\r\n    it(\"works on ExpressionWithTypeArguments\", () => {\r\n        const content = `\r\n            function fn<T>(value: T) {\r\n                return { value };\r\n            }\r\n            const foo = fn<string>;\r\n        `;\r\n        const host = new fakes.CompilerHost(vfs.createFromFileSystem(\r\n            Harness.IO,\r\n            /*ignoreCase*/ true,\r\n            { documents: [new documents.TextDocument(\"/file.ts\", content)], cwd: \"/\" },\r\n        ));\r\n\r\n        const program = ts.createProgram({\r\n            host,\r\n            rootNames: [\"/file.ts\"],\r\n            options: { noLib: true },\r\n        });\r\n\r\n        const checker = program.getTypeChecker();\r\n        const file = program.getSourceFile(\"/file.ts\")!;\r\n        const [declaration] = (ts.findLast(file.statements, ts.isVariableStatement) as ts.VariableStatement).declarationList.declarations;\r\n        assert.equal(checker.getTypeAtLocation(declaration.initializer!).flags, ts.TypeFlags.Object);\r\n    });\r\n\r\n    it(\"returns an errorType for VariableDeclaration with BindingPattern name\", () => {\r\n        const content = \"const foo = [1];\\n\" + \"const [a] = foo;\";\r\n\r\n        const host = new fakes.CompilerHost(vfs.createFromFileSystem(\r\n            Harness.IO,\r\n            /*ignoreCase*/ true,\r\n            { documents: [new documents.TextDocument(\"/file.ts\", content)], cwd: \"/\" },\r\n        ));\r\n\r\n        const program = ts.createProgram({\r\n            host,\r\n            rootNames: [\"/file.ts\"],\r\n            options: { noLib: true },\r\n        });\r\n\r\n        const checker = program.getTypeChecker();\r\n        const file = program.getSourceFile(\"/file.ts\")!;\r\n        const [declaration] = (ts.findLast(file.statements, ts.isVariableStatement) as ts.VariableStatement).declarationList.declarations;\r\n        assert.equal(checker.getTypeAtLocation(declaration).flags, ts.TypeFlags.Any);\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: validateLocaleAndSetLanguage\", () => {\r\n    let savedUILocale: string | undefined;\r\n    beforeEach(() => savedUILocale = ts.getUILocale());\r\n    afterEach(() => ts.setUILocale(savedUILocale));\r\n\r\n    function verifyValidateLocale(locale: string, expectedToReadFile: boolean) {\r\n        it(`Verifying ${locale} ${expectedToReadFile ? \"reads\" : \"does not read\"} file`, () => {\r\n            const errors: ts.Diagnostic[] = [];\r\n            ts.validateLocaleAndSetLanguage(locale, {\r\n                getExecutingFilePath: () => \"/tsc.js\",\r\n                resolvePath: ts.identity,\r\n                fileExists: fileName => {\r\n                    assert.isTrue(expectedToReadFile, `Locale : ${locale} ${expectedToReadFile ? \"should\" : \"should not\"} check if ${fileName} exists.`);\r\n                    return expectedToReadFile;\r\n                },\r\n                readFile: fileName => {\r\n                    assert.isTrue(expectedToReadFile, `Locale : ${locale} ${expectedToReadFile ? \"should\" : \"should not\"} read ${fileName}.`);\r\n                    // Throw error here so that actual change to localized diagnostics messages doesnt take place\r\n                    throw new Error(\"cannot read file\");\r\n                },\r\n            }, errors);\r\n        });\r\n    }\r\n    ts.supportedLocaleDirectories.forEach(locale => verifyValidateLocale(locale, /*expectedToReadFile*/ true));\r\n    [\"en\", \"en-us\"].forEach(locale => verifyValidateLocale(locale, /*expectedToReadFile*/ false));\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs :: forEachChild of @param comments in JSDoc\", () => {\r\n    it(\"finds correct children\", () => {\r\n        const content = `\r\n/**\r\n * @param The {@link TypeReferencesInAedoc}.\r\n */\r\nvar x\r\n`;\r\n        const sourceFile = ts.createSourceFile(\"/file.ts\", content, ts.ScriptTarget.ESNext, /*setParentNodes*/ true);\r\n        const paramTag = sourceFile.getChildren()[0].getChildren()[0].getChildren()[0].getChildren()[0];\r\n        const kids = paramTag.getChildren();\r\n        const seen = new Set<ts.Node>();\r\n        ts.forEachChild(paramTag, n => {\r\n            assert.strictEqual(/*actual*/ false, seen.has(n), \"Found a duplicate-added child\");\r\n            seen.add(n);\r\n        });\r\n        assert.equal(5, kids.length);\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: getChild* methods on EndOfFileToken with JSDoc\", () => {\r\n    it(\"finds correct children\", () => {\r\n        const content = `\r\n/** jsdoc comment attached to EndOfFileToken */\r\n`;\r\n        const sourceFile = ts.createSourceFile(\"/file.ts\", content, ts.ScriptTarget.ESNext, /*setParentNodes*/ true);\r\n        const endOfFileToken = sourceFile.getChildren()[1];\r\n        assert.equal(endOfFileToken.getChildren().length, 1);\r\n        assert.equal(endOfFileToken.getChildCount(), 1);\r\n        assert.notEqual(endOfFileToken.getChildAt(0), /*expected*/ undefined);\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: get syntactic and effective modifiers\", () => {\r\n    it(\"caches and reports correct flags in TS file\", () => {\r\n        // https://github.com/microsoft/TypeScript/issues/42189\r\n        const content = `\r\nclass C {\r\n    /** @private */\r\n    prop = 1;\r\n}`;\r\n        const sourceFile = ts.createSourceFile(\"/file.ts\", content, ts.ScriptTarget.ESNext, /*setParentNodes*/ true);\r\n        const classNode = sourceFile.statements[0] as ts.ClassDeclaration;\r\n        const propNode = classNode.members[0] as ts.PropertyDeclaration;\r\n        assert.equal(ts.ModifierFlags.None, ts.getSyntacticModifierFlags(propNode));\r\n        assert.equal(ts.ModifierFlags.None, ts.getEffectiveModifierFlags(propNode));\r\n        assert.equal(ts.ModifierFlags.None, ts.getSyntacticModifierFlags(propNode));\r\n    });\r\n    it(\"caches and reports correct flags in JS file\", () => {\r\n        // https://github.com/microsoft/TypeScript/issues/42189\r\n        const content = `\r\nclass C {\r\n    /** @private */\r\n    prop = 1;\r\n}`;\r\n        const sourceFile = ts.createSourceFile(\"/file.js\", content, ts.ScriptTarget.ESNext, /*setParentNodes*/ true);\r\n        const classNode = sourceFile.statements[0] as ts.ClassDeclaration;\r\n        const propNode = classNode.members[0] as ts.PropertyDeclaration;\r\n        assert.equal(ts.ModifierFlags.None, ts.getSyntacticModifierFlags(propNode));\r\n        assert.equal(ts.ModifierFlags.Private, ts.getEffectiveModifierFlags(propNode));\r\n        assert.equal(ts.ModifierFlags.None, ts.getSyntacticModifierFlags(propNode));\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Public APIs:: createProgram\", () => {\r\n    function verifyAPI(useJsonParsingApi: boolean) {\r\n        const sys = TestServerHost.createWatchedSystem({\r\n            \"/home/src/projects/project/packages/a/index.js\": `export const a = 'a';`,\r\n            \"/home/src/projects/project/packages/a/test/index.js\": `import 'a';`,\r\n            \"/home/src/projects/project/packages/a/tsconfig.json\": jsonToReadableText({\r\n                compilerOptions: {\r\n                    checkJs: true,\r\n                    composite: true,\r\n                    declaration: true,\r\n                    emitDeclarationOnly: true,\r\n                    module: \"nodenext\",\r\n                    outDir: \"types\",\r\n                },\r\n            }),\r\n            \"/home/src/projects/project/packages/a/package.json\": jsonToReadableText({\r\n                name: \"a\",\r\n                version: \"0.0.0\",\r\n                type: \"module\",\r\n                exports: {\r\n                    \".\": {\r\n                        types: \"./types/index.d.ts\",\r\n                        default: \"./index.js\",\r\n                    },\r\n                },\r\n            }),\r\n        }, { currentDirectory: \"/home/src/projects/project\" });\r\n        const commandLine = ts.getParsedCommandLineOfConfigFile(\r\n            \"/home/src/projects/project/packages/a/tsconfig.json\",\r\n            /*optionsToExtend*/ undefined,\r\n            {\r\n                fileExists: sys.fileExists.bind(sys),\r\n                getCurrentDirectory: sys.getCurrentDirectory.bind(sys),\r\n                onUnRecoverableConfigFileDiagnostic: () => {},\r\n                readDirectory: sys.readDirectory.bind(sys),\r\n                readFile: sys.readFile.bind(sys),\r\n                useCaseSensitiveFileNames: sys.useCaseSensitiveFileNames,\r\n                directoryExists: sys.directoryExists.bind(sys),\r\n                getDirectories: sys.getDirectories.bind(sys),\r\n                realpath: sys.realpath.bind(sys),\r\n            },\r\n        )!;\r\n        const config = !useJsonParsingApi ? JSON.parse(sys.readFile(\"/home/src/projects/project/packages/a/tsconfig.json\")!) : undefined;\r\n        // This is really createCompilerHost but we want to use our own sys so simple usage\r\n        const host = ts.createCompilerHostWorker(\r\n            useJsonParsingApi ? commandLine.options : config.compilerOptions,\r\n            /*setParentNodes*/ undefined,\r\n            sys,\r\n        );\r\n        (useJsonParsingApi ? assert.doesNotThrow : assert.throws)(() =>\r\n            ts.createProgram({\r\n                rootNames: commandLine.fileNames,\r\n                options: useJsonParsingApi ? commandLine.options : config.compilerOptions,\r\n                host,\r\n            })\r\n        );\r\n    }\r\n    it(\"when using correct config file API\", () => {\r\n        verifyAPI(/*useJsonParsingApi*/ true);\r\n    });\r\n    it(\"when using direct json read\", () => {\r\n        verifyAPI(/*useJsonParsingApi*/ false);\r\n    });\r\n});\r\n",
  "word_count": 1126,
  "key_terms": [
    "api",
    "import",
    "class",
    "function",
    "interface",
    "export"
  ],
  "file_info": {
    "size": 14324,
    "sha": "7b7b4ecc50766078bc089b2af7af30db10e03d69",
    "download_url": "https://raw.githubusercontent.com/microsoft/TypeScript/main/src/testRunner/unittests/publicApi.ts"
  }
}