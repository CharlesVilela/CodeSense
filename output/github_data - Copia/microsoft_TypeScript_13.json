{
  "metadata": {
    "title": "findAllReferences.ts",
    "url": "https://github.com/microsoft/TypeScript/blob/main/src/services/findAllReferences.ts",
    "repo": "microsoft/TypeScript",
    "file_path": "src/services/findAllReferences.ts",
    "file_type": "code",
    "technology": "typescript",
    "professional_context": "api_reference",
    "english_level": "B1",
    "content_type": "github_documentation",
    "last_updated": "1761763041.3680146"
  },
  "content": "import {\r\n    createImportTracker,\r\n    ExportInfo,\r\n    ExportKind,\r\n    findModuleReferences,\r\n    getExportInfo,\r\n    getImportOrExportSymbol,\r\n    ImportExport,\r\n    ImportsResult,\r\n    ImportTracker,\r\n    ModuleReference,\r\n} from \"./_namespaces/ts.FindAllReferences.js\";\r\nimport {\r\n    __String,\r\n    addToSeen,\r\n    append,\r\n    AssignmentDeclarationKind,\r\n    BinaryExpression,\r\n    BindingElement,\r\n    Block,\r\n    CallExpression,\r\n    CancellationToken,\r\n    canHaveSymbol,\r\n    cast,\r\n    CheckFlags,\r\n    ClassLikeDeclaration,\r\n    climbPastPropertyAccess,\r\n    compareValues,\r\n    ConstructorDeclaration,\r\n    contains,\r\n    createQueue,\r\n    createTextSpan,\r\n    createTextSpanFromBounds,\r\n    createTextSpanFromRange,\r\n    Debug,\r\n    Declaration,\r\n    displayPart,\r\n    DocumentSpan,\r\n    emptyArray,\r\n    emptyOptions,\r\n    escapeLeadingUnderscores,\r\n    ExportSpecifier,\r\n    Expression,\r\n    externalHelpersModuleNameText,\r\n    FileIncludeReason,\r\n    FileReference,\r\n    filter,\r\n    find,\r\n    findAncestor,\r\n    findChildOfKind,\r\n    findIndex,\r\n    first,\r\n    firstDefined,\r\n    firstOrUndefined,\r\n    flatMap,\r\n    forEach,\r\n    forEachChild,\r\n    forEachChildRecursively,\r\n    forEachReturnStatement,\r\n    ForInOrOfStatement,\r\n    FunctionDeclaration,\r\n    FunctionExpression,\r\n    FunctionLikeDeclaration,\r\n    GetAccessorDeclaration,\r\n    getAdjustedReferenceLocation,\r\n    getAdjustedRenameLocation,\r\n    getAllSuperTypeNodes,\r\n    getAncestor,\r\n    getAssignmentDeclarationKind,\r\n    getCheckFlags,\r\n    getContainerNode,\r\n    getContainingObjectLiteralElement,\r\n    getContextualTypeFromParentOrAncestorTypeNode,\r\n    getDeclarationFromName,\r\n    getDeclarationOfKind,\r\n    getEffectiveModifierFlags,\r\n    getLocalSymbolForExportDefault,\r\n    getMeaningFromDeclaration,\r\n    getMeaningFromLocation,\r\n    getNameOfDeclaration,\r\n    getNameTable,\r\n    getNextJSDocCommentLocation,\r\n    getNodeId,\r\n    getNodeKind,\r\n    getPropertySymbolFromBindingElement,\r\n    getPropertySymbolsFromContextualType,\r\n    getQuoteFromPreference,\r\n    getReferencedFileLocation,\r\n    getSuperContainer,\r\n    getSymbolId,\r\n    getSyntacticModifierFlags,\r\n    getTargetLabel,\r\n    getTextOfNode,\r\n    getThisContainer,\r\n    getTouchingPropertyName,\r\n    GoToDefinition,\r\n    hasEffectiveModifier,\r\n    hasInitializer,\r\n    hasSyntacticModifier,\r\n    hasType,\r\n    HighlightSpan,\r\n    HighlightSpanKind,\r\n    Identifier,\r\n    ImplementationLocation,\r\n    InterfaceDeclaration,\r\n    InternalSymbolName,\r\n    isAccessExpression,\r\n    isArrayLiteralOrObjectLiteralDestructuringPattern,\r\n    isAssertionExpression,\r\n    isBinaryExpression,\r\n    isBindableObjectDefinePropertyCall,\r\n    isBindingElement,\r\n    isBreakOrContinueStatement,\r\n    isCallExpression,\r\n    isCallExpressionTarget,\r\n    isCatchClause,\r\n    isClassLike,\r\n    isClassStaticBlockDeclaration,\r\n    isComputedPropertyName,\r\n    isConstructorDeclaration,\r\n    isDeclaration,\r\n    isDeclarationName,\r\n    isExportAssignment,\r\n    isExportSpecifier,\r\n    isExpressionOfExternalModuleImportEqualsDeclaration,\r\n    isExpressionStatement,\r\n    isExpressionWithTypeArguments,\r\n    isExternalModule,\r\n    isExternalModuleSymbol,\r\n    isExternalOrCommonJsModule,\r\n    isForInOrOfStatement,\r\n    isFunctionExpression,\r\n    isFunctionLike,\r\n    isFunctionLikeDeclaration,\r\n    isIdentifier,\r\n    isIdentifierPart,\r\n    isImportMeta,\r\n    isImportOrExportSpecifier,\r\n    isImportSpecifier,\r\n    isImportTypeNode,\r\n    isInJSFile,\r\n    isInNonReferenceComment,\r\n    isInString,\r\n    isInterfaceDeclaration,\r\n    isJSDocMemberName,\r\n    isJSDocPropertyLikeTag,\r\n    isJSDocTag,\r\n    isJSDocTypeLiteral,\r\n    isJsxClosingElement,\r\n    isJsxElement,\r\n    isJsxFragment,\r\n    isJsxOpeningElement,\r\n    isJsxSelfClosingElement,\r\n    isJumpStatementTarget,\r\n    isLabeledStatement,\r\n    isLabelOfLabeledStatement,\r\n    isLiteralComputedPropertyDeclarationName,\r\n    isLiteralNameOfPropertyDeclarationOrIndexAccess,\r\n    isLiteralTypeNode,\r\n    isMethodOrAccessor,\r\n    isModuleDeclaration,\r\n    isModuleExportsAccessExpression,\r\n    isModuleOrEnumDeclaration,\r\n    isModuleSpecifierLike,\r\n    isNameOfModuleDeclaration,\r\n    isNamespaceExportDeclaration,\r\n    isNewExpressionTarget,\r\n    isNoSubstitutionTemplateLiteral,\r\n    isNumericLiteral,\r\n    isObjectBindingElementWithoutPropertyName,\r\n    isObjectLiteralExpression,\r\n    isObjectLiteralMethod,\r\n    isParameter,\r\n    isParameterPropertyDeclaration,\r\n    isPrivateIdentifierClassElementDeclaration,\r\n    isPropertyAccessExpression,\r\n    isPropertySignature,\r\n    isQualifiedName,\r\n    isReferencedFile,\r\n    isReferenceFileLocation,\r\n    isRightSideOfPropertyAccess,\r\n    isSatisfiesExpression,\r\n    isShorthandPropertyAssignment,\r\n    isSourceFile,\r\n    isStatement,\r\n    isStatic,\r\n    isStaticModifier,\r\n    isStringLiteralLike,\r\n    isSuperProperty,\r\n    isThis,\r\n    isTypeAliasDeclaration,\r\n    isTypeElement,\r\n    isTypeKeyword,\r\n    isTypeLiteralNode,\r\n    isTypeNode,\r\n    isTypeOperatorNode,\r\n    isUnionTypeNode,\r\n    isVariableDeclarationInitializedToBareOrAccessedRequire,\r\n    isVariableDeclarationList,\r\n    isVariableLike,\r\n    isVariableStatement,\r\n    isVoidExpression,\r\n    isWriteAccess,\r\n    JSDocPropertyLikeTag,\r\n    length,\r\n    map,\r\n    mapDefined,\r\n    MethodDeclaration,\r\n    ModifierFlags,\r\n    ModuleDeclaration,\r\n    ModuleExportName,\r\n    moduleExportNameIsDefault,\r\n    MultiMap,\r\n    NamedDeclaration,\r\n    Node,\r\n    NodeFlags,\r\n    nodeSeenTracker,\r\n    NumericLiteral,\r\n    ObjectLiteralExpression,\r\n    or,\r\n    ParameterDeclaration,\r\n    ParenthesizedExpression,\r\n    Path,\r\n    PrivateIdentifier,\r\n    Program,\r\n    PropertyAccessExpression,\r\n    PropertyAssignment,\r\n    PropertyDeclaration,\r\n    punctuationPart,\r\n    QuotePreference,\r\n    rangeIsOnSingleLine,\r\n    ReferencedSymbol,\r\n    ReferencedSymbolDefinitionInfo,\r\n    ReferencedSymbolEntry,\r\n    ReferenceEntry,\r\n    RenameLocation,\r\n    ScriptElementKind,\r\n    ScriptTarget,\r\n    SemanticMeaning,\r\n    SetAccessorDeclaration,\r\n    SignatureDeclaration,\r\n    skipAlias,\r\n    some,\r\n    SourceFile,\r\n    StringLiteral,\r\n    StringLiteralLike,\r\n    stripQuotes,\r\n    SuperContainer,\r\n    SwitchStatement,\r\n    Symbol,\r\n    SymbolDisplay,\r\n    SymbolDisplayPart,\r\n    SymbolDisplayPartKind,\r\n    SymbolFlags,\r\n    symbolName,\r\n    SyntaxKind,\r\n    textPart,\r\n    TextSpan,\r\n    tokenToString,\r\n    TransformFlags,\r\n    tryAddToSet,\r\n    tryCast,\r\n    tryGetClassExtendingExpressionWithTypeArguments,\r\n    tryGetImportFromModuleSpecifier,\r\n    TypeChecker,\r\n    TypeLiteralNode,\r\n    VariableDeclaration,\r\n} from \"./_namespaces/ts.js\";\r\n\r\n/** @internal */\r\nexport interface SymbolAndEntries {\r\n    readonly definition: Definition | undefined;\r\n    readonly references: readonly Entry[];\r\n}\r\n\r\n/** @internal */\r\nexport const enum DefinitionKind {\r\n    Symbol,\r\n    Label,\r\n    Keyword,\r\n    This,\r\n    String,\r\n    TripleSlashReference,\r\n}\r\n/** @internal */\r\nexport type Definition =\r\n    | { readonly type: DefinitionKind.Symbol; readonly symbol: Symbol; }\r\n    | { readonly type: DefinitionKind.Label; readonly node: Identifier; }\r\n    | { readonly type: DefinitionKind.Keyword; readonly node: Node; }\r\n    | { readonly type: DefinitionKind.This; readonly node: Node; }\r\n    | { readonly type: DefinitionKind.String; readonly node: StringLiteralLike; }\r\n    | { readonly type: DefinitionKind.TripleSlashReference; readonly reference: FileReference; readonly file: SourceFile; };\r\n\r\n/** @internal */\r\nexport const enum EntryKind {\r\n    Span,\r\n    Node,\r\n    StringLiteral,\r\n    SearchedLocalFoundProperty,\r\n    SearchedPropertyFoundLocal,\r\n}\r\n/** @internal */\r\nexport type NodeEntryKind = EntryKind.Node | EntryKind.StringLiteral | EntryKind.SearchedLocalFoundProperty | EntryKind.SearchedPropertyFoundLocal;\r\n/** @internal */\r\nexport type Entry = NodeEntry | SpanEntry;\r\n/** @internal */\r\nexport interface ContextWithStartAndEndNode {\r\n    start: Node;\r\n    end: Node;\r\n}\r\n/** @internal */\r\nexport type ContextNode = Node | ContextWithStartAndEndNode;\r\n/** @internal */\r\nexport interface NodeEntry {\r\n    readonly kind: NodeEntryKind;\r\n    readonly node: Node;\r\n    readonly context?: ContextNode;\r\n}\r\n/** @internal */\r\nexport interface SpanEntry {\r\n    readonly kind: EntryKind.Span;\r\n    readonly fileName: string;\r\n    readonly textSpan: TextSpan;\r\n}\r\nfunction nodeEntry(node: Node, kind: NodeEntryKind = EntryKind.Node): NodeEntry {\r\n    return {\r\n        kind,\r\n        node: (node as NamedDeclaration).name || node,\r\n        context: getContextNodeForNodeEntry(node),\r\n    };\r\n}\r\n\r\n/** @internal */\r\nexport function isContextWithStartAndEndNode(node: ContextNode): node is ContextWithStartAndEndNode {\r\n    return node && (node as Node).kind === undefined;\r\n}\r\n\r\nfunction getContextNodeForNodeEntry(node: Node): ContextNode | undefined {\r\n    if (isDeclaration(node)) {\r\n        return getContextNode(node);\r\n    }\r\n\r\n    if (!node.parent) return undefined;\r\n\r\n    if (!isDeclaration(node.parent) && !isExportAssignment(node.parent)) {\r\n        // Special property assignment in javascript\r\n        if (isInJSFile(node)) {\r\n            const binaryExpression = isBinaryExpression(node.parent) ?\r\n                node.parent :\r\n                isAccessExpression(node.parent) &&\r\n                    isBinaryExpression(node.parent.parent) &&\r\n                    node.parent.parent.left === node.parent ?\r\n                node.parent.parent :\r\n                undefined;\r\n            if (binaryExpression && getAssignmentDeclarationKind(binaryExpression) !== AssignmentDeclarationKind.None) {\r\n                return getContextNode(binaryExpression);\r\n            }\r\n        }\r\n\r\n        // Jsx Tags\r\n        if (isJsxOpeningElement(node.parent) || isJsxClosingElement(node.parent)) {\r\n            return node.parent.parent;\r\n        }\r\n        else if (\r\n            isJsxSelfClosingElement(node.parent) ||\r\n            isLabeledStatement(node.parent) ||\r\n            isBreakOrContinueStatement(node.parent)\r\n        ) {\r\n            return node.parent;\r\n        }\r\n        else if (isStringLiteralLike(node)) {\r\n            const validImport = tryGetImportFromModuleSpecifier(node);\r\n            if (validImport) {\r\n                const declOrStatement = findAncestor(validImport, node =>\r\n                    isDeclaration(node) ||\r\n                    isStatement(node) ||\r\n                    isJSDocTag(node))!;\r\n                return isDeclaration(declOrStatement) ?\r\n                    getContextNode(declOrStatement) :\r\n                    declOrStatement;\r\n            }\r\n        }\r\n\r\n        // Handle computed property name\r\n        const propertyName = findAncestor(node, isComputedPropertyName);\r\n        return propertyName ?\r\n            getContextNode(propertyName.parent) :\r\n            undefined;\r\n    }\r\n\r\n    if (\r\n        node.parent.name === node || // node is name of declaration, use parent\r\n        isConstructorDeclaration(node.parent) ||\r\n        isExportAssignment(node.parent) ||\r\n        // Property name of the import export specifier or binding pattern, use parent\r\n        ((isImportOrExportSpecifier(node.parent) || isBindingElement(node.parent))\r\n            && node.parent.propertyName === node) ||\r\n        // Is default export\r\n        (node.kind === SyntaxKind.DefaultKeyword && hasSyntacticModifier(node.parent, ModifierFlags.ExportDefault))\r\n    ) {\r\n        return getContextNode(node.parent);\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\n/** @internal */\r\nexport function getContextNode(node: NamedDeclaration | BinaryExpression | ForInOrOfStatement | SwitchStatement | undefined): ContextNode | undefined {\r\n    if (!node) return undefined;\r\n    switch (node.kind) {\r\n        case SyntaxKind.VariableDeclaration:\r\n            return !isVariableDeclarationList(node.parent) || node.parent.declarations.length !== 1 ?\r\n                node :\r\n                isVariableStatement(node.parent.parent) ?\r\n                node.parent.parent :\r\n                isForInOrOfStatement(node.parent.parent) ?\r\n                getContextNode(node.parent.parent) :\r\n                node.parent;\r\n\r\n        case SyntaxKind.BindingElement:\r\n            return getContextNode(node.parent.parent as NamedDeclaration);\r\n\r\n        case SyntaxKind.ImportSpecifier:\r\n            return node.parent.parent.parent;\r\n\r\n        case SyntaxKind.ExportSpecifier:\r\n        case SyntaxKind.NamespaceImport:\r\n            return node.parent.parent;\r\n\r\n        case SyntaxKind.ImportClause:\r\n        case SyntaxKind.NamespaceExport:\r\n            return node.parent;\r\n\r\n        case SyntaxKind.BinaryExpression:\r\n            return isExpressionStatement(node.parent) ?\r\n                node.parent :\r\n                node;\r\n\r\n        case SyntaxKind.ForOfStatement:\r\n        case SyntaxKind.ForInStatement:\r\n            return {\r\n                start: (node as ForInOrOfStatement).initializer,\r\n                end: (node as ForInOrOfStatement).expression,\r\n            };\r\n\r\n        case SyntaxKind.PropertyAssignment:\r\n        case SyntaxKind.ShorthandPropertyAssignment:\r\n            return isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent) ?\r\n                getContextNode(\r\n                    findAncestor(node.parent, node => isBinaryExpression(node) || isForInOrOfStatement(node)) as BinaryExpression | ForInOrOfStatement,\r\n                ) :\r\n                node;\r\n        case SyntaxKind.SwitchStatement:\r\n            return {\r\n                start: find(node.getChildren(node.getSourceFile()), node => node.kind === SyntaxKind.SwitchKeyword)!,\r\n                end: (node as SwitchStatement).caseBlock,\r\n            };\r\n        default:\r\n            return node;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function toContextSpan(textSpan: TextSpan, sourceFile: SourceFile, context: ContextNode | undefined): { contextSpan: TextSpan; } | undefined {\r\n    if (!context) return undefined;\r\n    const contextSpan = isContextWithStartAndEndNode(context) ?\r\n        getTextSpan(context.start, sourceFile, context.end) :\r\n        getTextSpan(context, sourceFile);\r\n    return contextSpan.start !== textSpan.start || contextSpan.length !== textSpan.length ?\r\n        { contextSpan } :\r\n        undefined;\r\n}\r\n\r\n/** @internal */\r\nexport const enum FindReferencesUse {\r\n    /**\r\n     * When searching for references to a symbol, the location will not be adjusted (this is the default behavior when not specified).\r\n     */\r\n    Other,\r\n    /**\r\n     * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.\r\n     */\r\n    References,\r\n    /**\r\n     * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.\r\n     * Unlike `References`, the location will only be adjusted keyword belonged to a declaration with a valid name.\r\n     * If set, we will find fewer references -- if it is referenced by several different names, we still only find references for the original name.\r\n     */\r\n    Rename,\r\n}\r\n\r\n/** @internal */\r\nexport interface Options {\r\n    readonly findInStrings?: boolean;\r\n    readonly findInComments?: boolean;\r\n    readonly use?: FindReferencesUse;\r\n    /** True if we are searching for implementations. We will have a different method of adding references if so. */\r\n    readonly implementations?: boolean;\r\n    /**\r\n     * True to opt in for enhanced renaming of shorthand properties and import/export specifiers.\r\n     * The options controls the behavior for the whole rename operation; it cannot be changed on a per-file basis.\r\n     * Default is false for backwards compatibility.\r\n     */\r\n    readonly providePrefixAndSuffixTextForRename?: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport function findReferencedSymbols(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], sourceFile: SourceFile, position: number): ReferencedSymbol[] | undefined {\r\n    const node = getTouchingPropertyName(sourceFile, position);\r\n    const options = { use: FindReferencesUse.References };\r\n    const referencedSymbols = Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options);\r\n    const checker = program.getTypeChecker();\r\n    // Unless the starting node is a declaration (vs e.g. JSDoc), don't attempt to compute isDefinition\r\n    const adjustedNode = Core.getAdjustedNode(node, options);\r\n    const symbol = isDefinitionForReference(adjustedNode) ? checker.getSymbolAtLocation(adjustedNode) : undefined;\r\n    return !referencedSymbols || !referencedSymbols.length ? undefined : mapDefined<SymbolAndEntries, ReferencedSymbol>(referencedSymbols, ({ definition, references }) =>\r\n        // Only include referenced symbols that have a valid definition.\r\n        definition && {\r\n            definition: checker.runWithCancellationToken(cancellationToken, checker => definitionToReferencedSymbolDefinitionInfo(definition, checker, node)),\r\n            references: references.map(r => toReferencedSymbolEntry(r, symbol)),\r\n        });\r\n}\r\n\r\nfunction isDefinitionForReference(node: Node): boolean {\r\n    return node.kind === SyntaxKind.DefaultKeyword\r\n        || !!getDeclarationFromName(node)\r\n        || isLiteralComputedPropertyDeclarationName(node)\r\n        || (node.kind === SyntaxKind.ConstructorKeyword && isConstructorDeclaration(node.parent));\r\n}\r\n\r\n/** @internal */\r\nexport function getImplementationsAtPosition(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], sourceFile: SourceFile, position: number): ImplementationLocation[] | undefined {\r\n    const node = getTouchingPropertyName(sourceFile, position);\r\n    let referenceEntries: Entry[] | undefined;\r\n    const entries = getImplementationReferenceEntries(program, cancellationToken, sourceFiles, node, position);\r\n\r\n    if (\r\n        node.parent.kind === SyntaxKind.PropertyAccessExpression\r\n        || node.parent.kind === SyntaxKind.BindingElement\r\n        || node.parent.kind === SyntaxKind.ElementAccessExpression\r\n        || node.kind === SyntaxKind.SuperKeyword\r\n    ) {\r\n        referenceEntries = entries && [...entries];\r\n    }\r\n    else if (entries) {\r\n        const queue = createQueue(entries);\r\n        const seenNodes = new Set<number>();\r\n        while (!queue.isEmpty()) {\r\n            const entry = queue.dequeue() as NodeEntry;\r\n            if (!addToSeen(seenNodes, getNodeId(entry.node))) {\r\n                continue;\r\n            }\r\n            referenceEntries = append(referenceEntries, entry);\r\n            const entries = getImplementationReferenceEntries(program, cancellationToken, sourceFiles, entry.node, entry.node.pos);\r\n            if (entries) {\r\n                queue.enqueue(...entries);\r\n            }\r\n        }\r\n    }\r\n    const checker = program.getTypeChecker();\r\n    return map(referenceEntries, entry => toImplementationLocation(entry, checker));\r\n}\r\n\r\nfunction getImplementationReferenceEntries(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], node: Node, position: number): readonly Entry[] | undefined {\r\n    if (node.kind === SyntaxKind.SourceFile) {\r\n        return undefined;\r\n    }\r\n\r\n    const checker = program.getTypeChecker();\r\n    // If invoked directly on a shorthand property assignment, then return\r\n    // the declaration of the symbol being assigned (not the symbol being assigned to).\r\n    if (node.parent.kind === SyntaxKind.ShorthandPropertyAssignment) {\r\n        const result: NodeEntry[] = [];\r\n        Core.getReferenceEntriesForShorthandPropertyAssignment(node, checker, node => result.push(nodeEntry(node)));\r\n        return result;\r\n    }\r\n    else if (node.kind === SyntaxKind.SuperKeyword || isSuperProperty(node.parent)) {\r\n        // References to and accesses on the super keyword only have one possible implementation, so no\r\n        // need to \"Find all References\"\r\n        const symbol = checker.getSymbolAtLocation(node)!;\r\n        return symbol.valueDeclaration && [nodeEntry(symbol.valueDeclaration)];\r\n    }\r\n    else {\r\n        // Perform \"Find all References\" and retrieve only those that are implementations\r\n        return getReferenceEntriesForNode(position, node, program, sourceFiles, cancellationToken, { implementations: true, use: FindReferencesUse.References });\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function findReferenceOrRenameEntries<T>(\r\n    program: Program,\r\n    cancellationToken: CancellationToken,\r\n    sourceFiles: readonly SourceFile[],\r\n    node: Node,\r\n    position: number,\r\n    options: Options | undefined,\r\n    convertEntry: ToReferenceOrRenameEntry<T>,\r\n): T[] | undefined {\r\n    return map(flattenEntries(Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options)), entry => convertEntry(entry, node, program.getTypeChecker()));\r\n}\r\n\r\n/** @internal */\r\nexport type ToReferenceOrRenameEntry<T> = (entry: Entry, originalNode: Node, checker: TypeChecker) => T;\r\n\r\n/** @internal */\r\nexport function getReferenceEntriesForNode(\r\n    position: number,\r\n    node: Node,\r\n    program: Program,\r\n    sourceFiles: readonly SourceFile[],\r\n    cancellationToken: CancellationToken,\r\n    options: Options = {},\r\n    sourceFilesSet: ReadonlySet<string> = new Set(sourceFiles.map(f => f.fileName)),\r\n): readonly Entry[] | undefined {\r\n    return flattenEntries(Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options, sourceFilesSet));\r\n}\r\n\r\nfunction flattenEntries(referenceSymbols: readonly SymbolAndEntries[] | undefined): readonly Entry[] | undefined {\r\n    return referenceSymbols && flatMap(referenceSymbols, r => r.references);\r\n}\r\n\r\nfunction definitionToReferencedSymbolDefinitionInfo(def: Definition, checker: TypeChecker, originalNode: Node): ReferencedSymbolDefinitionInfo {\r\n    const info = ((): { sourceFile: SourceFile; textSpan: TextSpan; name: string; kind: ScriptElementKind; displayParts: SymbolDisplayPart[]; context?: Node | ContextWithStartAndEndNode; } => {\r\n        switch (def.type) {\r\n            case DefinitionKind.Symbol: {\r\n                const { symbol } = def;\r\n                const { displayParts, kind } = getDefinitionKindAndDisplayParts(symbol, checker, originalNode);\r\n                const name = displayParts.map(p => p.text).join(\"\");\r\n                const declaration = symbol.declarations && firstOrUndefined(symbol.declarations);\r\n                const node = declaration ? (getNameOfDeclaration(declaration) || declaration) : originalNode;\r\n                return {\r\n                    ...getFileAndTextSpanFromNode(node),\r\n                    name,\r\n                    kind,\r\n                    displayParts,\r\n                    context: getContextNode(declaration),\r\n                };\r\n            }\r\n            case DefinitionKind.Label: {\r\n                const { node } = def;\r\n                return { ...getFileAndTextSpanFromNode(node), name: node.text, kind: ScriptElementKind.label, displayParts: [displayPart(node.text, SymbolDisplayPartKind.text)] };\r\n            }\r\n            case DefinitionKind.Keyword: {\r\n                const { node } = def;\r\n                const name = tokenToString(node.kind)!;\r\n                return { ...getFileAndTextSpanFromNode(node), name, kind: ScriptElementKind.keyword, displayParts: [{ text: name, kind: ScriptElementKind.keyword }] };\r\n            }\r\n            case DefinitionKind.This: {\r\n                const { node } = def;\r\n                const symbol = checker.getSymbolAtLocation(node);\r\n                const displayParts = symbol && SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(\r\n                            checker,\r\n                            symbol,\r\n                            node.getSourceFile(),\r\n                            getContainerNode(node),\r\n                            node,\r\n                        ).displayParts || [textPart(\"this\")];\r\n                return { ...getFileAndTextSpanFromNode(node), name: \"this\", kind: ScriptElementKind.variableElement, displayParts };\r\n            }\r\n            case DefinitionKind.String: {\r\n                const { node } = def;\r\n                return {\r\n                    ...getFileAndTextSpanFromNode(node),\r\n                    name: node.text,\r\n                    kind: ScriptElementKind.variableElement,\r\n                    displayParts: [displayPart(getTextOfNode(node), SymbolDisplayPartKind.stringLiteral)],\r\n                };\r\n            }\r\n            case DefinitionKind.TripleSlashReference: {\r\n                return {\r\n                    textSpan: createTextSpanFromRange(def.reference),\r\n                    sourceFile: def.file,\r\n                    name: def.reference.fileName,\r\n                    kind: ScriptElementKind.string,\r\n                    displayParts: [displayPart(`\"${def.reference.fileName}\"`, SymbolDisplayPartKind.stringLiteral)],\r\n                };\r\n            }\r\n            default:\r\n                return Debug.assertNever(def);\r\n        }\r\n    })();\r\n\r\n    const { sourceFile, textSpan, name, kind, displayParts, context } = info;\r\n    return {\r\n        containerKind: ScriptElementKind.unknown,\r\n        containerName: \"\",\r\n        fileName: sourceFile.fileName,\r\n        kind,\r\n        name,\r\n        textSpan,\r\n        displayParts,\r\n        ...toContextSpan(textSpan, sourceFile, context),\r\n    };\r\n}\r\n\r\nfunction getFileAndTextSpanFromNode(node: Node) {\r\n    const sourceFile = node.getSourceFile();\r\n    return {\r\n        sourceFile,\r\n        textSpan: getTextSpan(isComputedPropertyName(node) ? node.expression : node, sourceFile),\r\n    };\r\n}\r\n\r\nfunction getDefinitionKindAndDisplayParts(symbol: Symbol, checker: TypeChecker, node: Node): { displayParts: SymbolDisplayPart[]; kind: ScriptElementKind; } {\r\n    const meaning = Core.getIntersectingMeaningFromDeclarations(node, symbol);\r\n    const enclosingDeclaration = symbol.declarations && firstOrUndefined(symbol.declarations) || node;\r\n    const { displayParts, symbolKind } = SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(checker, symbol, enclosingDeclaration.getSourceFile(), enclosingDeclaration, enclosingDeclaration, meaning);\r\n    return { displayParts, kind: symbolKind };\r\n}\r\n\r\n/** @internal */\r\nexport function toRenameLocation(entry: Entry, originalNode: Node, checker: TypeChecker, providePrefixAndSuffixText: boolean, quotePreference: QuotePreference): RenameLocation {\r\n    return { ...entryToDocumentSpan(entry), ...(providePrefixAndSuffixText && getPrefixAndSuffixText(entry, originalNode, checker, quotePreference)) };\r\n}\r\n\r\nfunction toReferencedSymbolEntry(entry: Entry, symbol: Symbol | undefined): ReferencedSymbolEntry {\r\n    const referenceEntry = toReferenceEntry(entry);\r\n    if (!symbol) return referenceEntry;\r\n    return {\r\n        ...referenceEntry,\r\n        isDefinition: entry.kind !== EntryKind.Span && isDeclarationOfSymbol(entry.node, symbol),\r\n    };\r\n}\r\n\r\n/** @internal */\r\nexport function toReferenceEntry(entry: Entry): ReferenceEntry {\r\n    const documentSpan = entryToDocumentSpan(entry);\r\n    if (entry.kind === EntryKind.Span) {\r\n        return { ...documentSpan, isWriteAccess: false };\r\n    }\r\n    const { kind, node } = entry;\r\n    return {\r\n        ...documentSpan,\r\n        isWriteAccess: isWriteAccessForReference(node),\r\n        isInString: kind === EntryKind.StringLiteral ? true : undefined,\r\n    };\r\n}\r\n\r\nfunction entryToDocumentSpan(entry: Entry): DocumentSpan {\r\n    if (entry.kind === EntryKind.Span) {\r\n        return { textSpan: entry.textSpan, fileName: entry.fileName };\r\n    }\r\n    else {\r\n        const sourceFile = entry.node.getSourceFile();\r\n        const textSpan = getTextSpan(entry.node, sourceFile);\r\n        return {\r\n            textSpan,\r\n            fileName: sourceFile.fileName,\r\n            ...toContextSpan(textSpan, sourceFile, entry.context),\r\n        };\r\n    }\r\n}\r\n\r\ninterface PrefixAndSuffix {\r\n    readonly prefixText?: string;\r\n    readonly suffixText?: string;\r\n}\r\nfunction getPrefixAndSuffixText(entry: Entry, originalNode: Node, checker: TypeChecker, quotePreference: QuotePreference): PrefixAndSuffix {\r\n    if (entry.kind !== EntryKind.Span && (isIdentifier(originalNode) || isStringLiteralLike(originalNode))) {\r\n        const { node, kind } = entry;\r\n        const parent = node.parent;\r\n        const name = originalNode.text;\r\n        const isShorthandAssignment = isShorthandPropertyAssignment(parent);\r\n        if (isShorthandAssignment || (isObjectBindingElementWithoutPropertyName(parent) && parent.name === node && parent.dotDotDotToken === undefined)) {\r\n            const prefixColon: PrefixAndSuffix = { prefixText: name + \": \" };\r\n            const suffixColon: PrefixAndSuffix = { suffixText: \": \" + name };\r\n            if (kind === EntryKind.SearchedLocalFoundProperty) {\r\n                return prefixColon;\r\n            }\r\n            if (kind === EntryKind.SearchedPropertyFoundLocal) {\r\n                return suffixColon;\r\n            }\r\n\r\n            // In `const o = { x }; o.x`, symbolAtLocation at `x` in `{ x }` is the property symbol.\r\n            // For a binding element `const { x } = o;`, symbolAtLocation at `x` is the property symbol.\r\n            if (isShorthandAssignment) {\r\n                const grandParent = parent.parent;\r\n                if (\r\n                    isObjectLiteralExpression(grandParent) &&\r\n                    isBinaryExpression(grandParent.parent) &&\r\n                    isModuleExportsAccessExpression(grandParent.parent.left)\r\n                ) {\r\n                    return prefixColon;\r\n                }\r\n                return suffixColon;\r\n            }\r\n            else {\r\n                return prefixColon;\r\n            }\r\n        }\r\n        else if (isImportSpecifier(parent) && !parent.propertyName) {\r\n            // If the original symbol was using this alias, just rename the alias.\r\n            const originalSymbol = isExportSpecifier(originalNode.parent) ? checker.getExportSpecifierLocalTargetSymbol(originalNode.parent) : checker.getSymbolAtLocation(originalNode);\r\n            return contains(originalSymbol!.declarations, parent) ? { prefixText: name + \" as \" } : emptyOptions;\r\n        }\r\n        else if (isExportSpecifier(parent) && !parent.propertyName) {\r\n            // If the symbol for the node is same as declared node symbol use prefix text\r\n            return originalNode === entry.node || checker.getSymbolAtLocation(originalNode) === checker.getSymbolAtLocation(entry.node) ?\r\n                { prefixText: name + \" as \" } :\r\n                { suffixText: \" as \" + name };\r\n        }\r\n    }\r\n\r\n    // If the node is a numerical indexing literal, then add quotes around the property access.\r\n    if (entry.kind !== EntryKind.Span && isNumericLiteral(entry.node) && isAccessExpression(entry.node.parent)) {\r\n        const quote = getQuoteFromPreference(quotePreference);\r\n        return { prefixText: quote, suffixText: quote };\r\n    }\r\n\r\n    return emptyOptions;\r\n}\r\n\r\nfunction toImplementationLocation(entry: Entry, checker: TypeChecker): ImplementationLocation {\r\n    const documentSpan = entryToDocumentSpan(entry);\r\n    if (entry.kind !== EntryKind.Span) {\r\n        const { node } = entry;\r\n        return {\r\n            ...documentSpan,\r\n            ...implementationKindDisplayParts(node, checker),\r\n        };\r\n    }\r\n    else {\r\n        return { ...documentSpan, kind: ScriptElementKind.unknown, displayParts: [] };\r\n    }\r\n}\r\n\r\nfunction implementationKindDisplayParts(node: Node, checker: TypeChecker): { kind: ScriptElementKind; displayParts: SymbolDisplayPart[]; } {\r\n    const symbol = checker.getSymbolAtLocation(isDeclaration(node) && node.name ? node.name : node);\r\n    if (symbol) {\r\n        return getDefinitionKindAndDisplayParts(symbol, checker, node);\r\n    }\r\n    else if (node.kind === SyntaxKind.ObjectLiteralExpression) {\r\n        return {\r\n            kind: ScriptElementKind.interfaceElement,\r\n            displayParts: [punctuationPart(SyntaxKind.OpenParenToken), textPart(\"object literal\"), punctuationPart(SyntaxKind.CloseParenToken)],\r\n        };\r\n    }\r\n    else if (node.kind === SyntaxKind.ClassExpression) {\r\n        return {\r\n            kind: ScriptElementKind.localClassElement,\r\n            displayParts: [punctuationPart(SyntaxKind.OpenParenToken), textPart(\"anonymous local class\"), punctuationPart(SyntaxKind.CloseParenToken)],\r\n        };\r\n    }\r\n    else {\r\n        return { kind: getNodeKind(node), displayParts: [] };\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function toHighlightSpan(entry: Entry): { fileName: string; span: HighlightSpan; } {\r\n    const documentSpan = entryToDocumentSpan(entry);\r\n    if (entry.kind === EntryKind.Span) {\r\n        return {\r\n            fileName: documentSpan.fileName,\r\n            span: {\r\n                textSpan: documentSpan.textSpan,\r\n                kind: HighlightSpanKind.reference,\r\n            },\r\n        };\r\n    }\r\n\r\n    const writeAccess = isWriteAccessForReference(entry.node);\r\n    const span: HighlightSpan = {\r\n        textSpan: documentSpan.textSpan,\r\n        kind: writeAccess ? HighlightSpanKind.writtenReference : HighlightSpanKind.reference,\r\n        isInString: entry.kind === EntryKind.StringLiteral ? true : undefined,\r\n        ...documentSpan.contextSpan && { contextSpan: documentSpan.contextSpan },\r\n    };\r\n    return { fileName: documentSpan.fileName, span };\r\n}\r\n\r\nfunction getTextSpan(node: Node, sourceFile: SourceFile, endNode?: Node): TextSpan {\r\n    let start = node.getStart(sourceFile);\r\n    let end = (endNode || node).getEnd();\r\n    if (isStringLiteralLike(node) && (end - start) > 2) {\r\n        Debug.assert(endNode === undefined);\r\n        start += 1;\r\n        end -= 1;\r\n    }\r\n    if (endNode?.kind === SyntaxKind.CaseBlock) {\r\n        end = endNode.getFullStart();\r\n    }\r\n    return createTextSpanFromBounds(start, end);\r\n}\r\n\r\nfunction getTextSpanOfEntry(entry: Entry) {\r\n    return entry.kind === EntryKind.Span ? entry.textSpan :\r\n        getTextSpan(entry.node, entry.node.getSourceFile());\r\n}\r\n\r\n/**\r\n * A node is considered a writeAccess iff it is a name of a declaration or a target of an assignment.\r\n *\r\n * @internal\r\n */\r\nexport function isWriteAccessForReference(node: Node): boolean {\r\n    const decl = getDeclarationFromName(node);\r\n    return !!decl && declarationIsWriteAccess(decl) || node.kind === SyntaxKind.DefaultKeyword || isWriteAccess(node);\r\n}\r\n\r\n/**\r\n * Whether a reference, `node`, is a definition of the `target` symbol\r\n *\r\n * @internal\r\n */\r\nexport function isDeclarationOfSymbol(node: Node, target: Symbol | undefined): boolean {\r\n    if (!target) return false;\r\n    const source = getDeclarationFromName(node) ||\r\n        (node.kind === SyntaxKind.DefaultKeyword ? node.parent\r\n            : isLiteralComputedPropertyDeclarationName(node) ? node.parent.parent\r\n            : node.kind === SyntaxKind.ConstructorKeyword && isConstructorDeclaration(node.parent) ? node.parent.parent\r\n            : undefined);\r\n    const commonjsSource = source && isBinaryExpression(source) ? source.left as unknown as Declaration : undefined;\r\n    return !!(source && target.declarations?.some(d => d === source || d === commonjsSource));\r\n}\r\n\r\n/**\r\n * True if 'decl' provides a value, as in `function f() {}`;\r\n * false if 'decl' is just a location for a future write, as in 'let x;'\r\n */\r\nfunction declarationIsWriteAccess(decl: Declaration): boolean {\r\n    // Consider anything in an ambient declaration to be a write access since it may be coming from JS.\r\n    if (!!(decl.flags & NodeFlags.Ambient)) return true;\r\n\r\n    switch (decl.kind) {\r\n        case SyntaxKind.BinaryExpression:\r\n        case SyntaxKind.BindingElement:\r\n        case SyntaxKind.ClassDeclaration:\r\n        case SyntaxKind.ClassExpression:\r\n        case SyntaxKind.DefaultKeyword:\r\n        case SyntaxKind.EnumDeclaration:\r\n        case SyntaxKind.EnumMember:\r\n        case SyntaxKind.ExportSpecifier:\r\n        case SyntaxKind.ImportClause: // default import\r\n        case SyntaxKind.ImportEqualsDeclaration:\r\n        case SyntaxKind.ImportSpecifier:\r\n        case SyntaxKind.InterfaceDeclaration:\r\n        case SyntaxKind.JSDocCallbackTag:\r\n        case SyntaxKind.JSDocTypedefTag:\r\n        case SyntaxKind.JsxAttribute:\r\n        case SyntaxKind.ModuleDeclaration:\r\n        case SyntaxKind.NamespaceExportDeclaration:\r\n        case SyntaxKind.NamespaceImport:\r\n        case SyntaxKind.NamespaceExport:\r\n        case SyntaxKind.Parameter:\r\n        case SyntaxKind.ShorthandPropertyAssignment:\r\n        case SyntaxKind.TypeAliasDeclaration:\r\n        case SyntaxKind.TypeParameter:\r\n            return true;\r\n\r\n        case SyntaxKind.PropertyAssignment:\r\n            // In `({ x: y } = 0);`, `x` is not a write access. (Won't call this function for `y`.)\r\n            return !isArrayLiteralOrObjectLiteralDestructuringPattern((decl as PropertyAssignment).parent);\r\n\r\n        case SyntaxKind.FunctionDeclaration:\r\n        case SyntaxKind.FunctionExpression:\r\n        case SyntaxKind.Constructor:\r\n        case SyntaxKind.MethodDeclaration:\r\n        case SyntaxKind.GetAccessor:\r\n        case SyntaxKind.SetAccessor:\r\n            return !!(decl as FunctionDeclaration | FunctionExpression | ConstructorDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration).body;\r\n\r\n        case SyntaxKind.VariableDeclaration:\r\n        case SyntaxKind.PropertyDeclaration:\r\n            return !!(decl as VariableDeclaration | PropertyDeclaration).initializer || isCatchClause(decl.parent);\r\n\r\n        case SyntaxKind.MethodSignature:\r\n        case SyntaxKind.PropertySignature:\r\n        case SyntaxKind.JSDocPropertyTag:\r\n        case SyntaxKind.JSDocParameterTag:\r\n            return false;\r\n\r\n        default:\r\n            return Debug.failBadSyntaxKind(decl);\r\n    }\r\n}\r\n\r\n/**\r\n * Encapsulates the core find-all-references algorithm.\r\n *\r\n * @internal\r\n */\r\nexport namespace Core {\r\n    /** Core find-all-references algorithm. Handles special cases before delegating to `getReferencedSymbolsForSymbol`. */\r\n    export function getReferencedSymbolsForNode(position: number, node: Node, program: Program, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken, options: Options = {}, sourceFilesSet: ReadonlySet<string> = new Set(sourceFiles.map(f => f.fileName))): readonly SymbolAndEntries[] | undefined {\r\n        node = getAdjustedNode(node, options);\r\n        if (isSourceFile(node)) {\r\n            const resolvedRef = GoToDefinition.getReferenceAtPosition(node, position, program);\r\n            if (!resolvedRef?.file) {\r\n                return undefined;\r\n            }\r\n            const moduleSymbol = program.getTypeChecker().getMergedSymbol(resolvedRef.file.symbol);\r\n            if (moduleSymbol) {\r\n                return getReferencedSymbolsForModule(program, moduleSymbol, /*excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet);\r\n            }\r\n            const fileIncludeReasons = program.getFileIncludeReasons();\r\n            if (!fileIncludeReasons) {\r\n                return undefined;\r\n            }\r\n            return [{\r\n                definition: { type: DefinitionKind.TripleSlashReference, reference: resolvedRef.reference, file: node },\r\n                references: getReferencesForNonModule(resolvedRef.file, fileIncludeReasons, program) || emptyArray,\r\n            }];\r\n        }\r\n\r\n        if (!options.implementations) {\r\n            const special = getReferencedSymbolsSpecial(node, sourceFiles, cancellationToken);\r\n            if (special) {\r\n                return special;\r\n            }\r\n        }\r\n\r\n        const checker = program.getTypeChecker();\r\n        // constructors should use the class symbol, detected by name, if present\r\n        const symbol = checker.getSymbolAtLocation(isConstructorDeclaration(node) && node.parent.name || node);\r\n\r\n        // Could not find a symbol e.g. unknown identifier\r\n        if (!symbol) {\r\n            // String literal might be a property (and thus have a symbol), so do this here rather than in getReferencedSymbolsSpecial.\r\n            if (!options.implementations && isStringLiteralLike(node)) {\r\n                if (isModuleSpecifierLike(node)) {\r\n                    const fileIncludeReasons = program.getFileIncludeReasons();\r\n                    const referencedFileName = program.getResolvedModuleFromModuleSpecifier(node)?.resolvedModule?.resolvedFileName;\r\n                    const referencedFile = referencedFileName ? program.getSourceFile(referencedFileName) : undefined;\r\n                    if (referencedFile) {\r\n                        return [{ definition: { type: DefinitionKind.String, node }, references: getReferencesForNonModule(referencedFile, fileIncludeReasons, program) || emptyArray }];\r\n                    }\r\n                    // Fall through to string literal references. This is not very likely to return\r\n                    // anything useful, but I guess it's better than nothing, and there's an existing\r\n                    // test that expects this to happen (fourslash/cases/untypedModuleImport.ts).\r\n                }\r\n                return getReferencesForStringLiteral(node, sourceFiles, checker, cancellationToken);\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        if (symbol.escapedName === InternalSymbolName.ExportEquals) {\r\n            return getReferencedSymbolsForModule(program, symbol.parent!, /*excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet);\r\n        }\r\n\r\n        const moduleReferences = getReferencedSymbolsForModuleIfDeclaredBySourceFile(symbol, program, sourceFiles, cancellationToken, options, sourceFilesSet);\r\n        if (moduleReferences && !(symbol.flags & SymbolFlags.Transient)) {\r\n            return moduleReferences;\r\n        }\r\n\r\n        const aliasedSymbol = getMergedAliasedSymbolOfNamespaceExportDeclaration(node, symbol, checker);\r\n        const moduleReferencesOfExportTarget = aliasedSymbol &&\r\n            getReferencedSymbolsForModuleIfDeclaredBySourceFile(aliasedSymbol, program, sourceFiles, cancellationToken, options, sourceFilesSet);\r\n\r\n        const references = getReferencedSymbolsForSymbol(symbol, node, sourceFiles, sourceFilesSet, checker, cancellationToken, options);\r\n        return mergeReferences(program, moduleReferences, references, moduleReferencesOfExportTarget);\r\n    }\r\n\r\n    export function getAdjustedNode(node: Node, options: Options): Node {\r\n        if (options.use === FindReferencesUse.References) {\r\n            node = getAdjustedReferenceLocation(node);\r\n        }\r\n        else if (options.use === FindReferencesUse.Rename) {\r\n            node = getAdjustedRenameLocation(node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    export function getReferencesForFileName(fileName: string, program: Program, sourceFiles: readonly SourceFile[], sourceFilesSet: ReadonlySet<string> = new Set(sourceFiles.map(f => f.fileName))): readonly Entry[] {\r\n        const moduleSymbol = program.getSourceFile(fileName)?.symbol;\r\n        if (moduleSymbol) {\r\n            return getReferencedSymbolsForModule(program, moduleSymbol, /*excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet)[0]?.references || emptyArray;\r\n        }\r\n        const fileIncludeReasons = program.getFileIncludeReasons();\r\n        const referencedFile = program.getSourceFile(fileName);\r\n        return referencedFile && fileIncludeReasons && getReferencesForNonModule(referencedFile, fileIncludeReasons, program) || emptyArray;\r\n    }\r\n\r\n    function getReferencesForNonModule(referencedFile: SourceFile, refFileMap: MultiMap<Path, FileIncludeReason>, program: Program): readonly SpanEntry[] | undefined {\r\n        let entries: SpanEntry[] | undefined;\r\n        const references = refFileMap.get(referencedFile.path) || emptyArray;\r\n        for (const ref of references) {\r\n            if (isReferencedFile(ref)) {\r\n                const referencingFile = program.getSourceFileByPath(ref.file)!;\r\n                const location = getReferencedFileLocation(program, ref);\r\n                if (isReferenceFileLocation(location)) {\r\n                    entries = append(entries, {\r\n                        kind: EntryKind.Span,\r\n                        fileName: referencingFile.fileName,\r\n                        textSpan: createTextSpanFromRange(location),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return entries;\r\n    }\r\n\r\n    function getMergedAliasedSymbolOfNamespaceExportDeclaration(node: Node, symbol: Symbol, checker: TypeChecker) {\r\n        if (node.parent && isNamespaceExportDeclaration(node.parent)) {\r\n            const aliasedSymbol = checker.getAliasedSymbol(symbol);\r\n            const targetSymbol = checker.getMergedSymbol(aliasedSymbol);\r\n            if (aliasedSymbol !== targetSymbol) {\r\n                return targetSymbol;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    function getReferencedSymbolsForModuleIfDeclaredBySourceFile(symbol: Symbol, program: Program, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken, options: Options, sourceFilesSet: ReadonlySet<string>) {\r\n        const moduleSourceFile = (symbol.flags & SymbolFlags.Module) && symbol.declarations && find(symbol.declarations, isSourceFile);\r\n        if (!moduleSourceFile) return undefined;\r\n        const exportEquals = symbol.exports!.get(InternalSymbolName.ExportEquals);\r\n        // If !!exportEquals, we're about to add references to `import(\"mod\")` anyway, so don't double-count them.\r\n        const moduleReferences = getReferencedSymbolsForModule(program, symbol, !!exportEquals, sourceFiles, sourceFilesSet);\r\n        if (!exportEquals || !sourceFilesSet.has(moduleSourceFile.fileName)) return moduleReferences;\r\n        // Continue to get references to 'export ='.\r\n        const checker = program.getTypeChecker();\r\n        symbol = skipAlias(exportEquals, checker);\r\n        return mergeReferences(program, moduleReferences, getReferencedSymbolsForSymbol(symbol, /*node*/ undefined, sourceFiles, sourceFilesSet, checker, cancellationToken, options));\r\n    }\r\n\r\n    /**\r\n     * Merges the references by sorting them (by file index in sourceFiles and their location in it) that point to same definition symbol\r\n     */\r\n    function mergeReferences(program: Program, ...referencesToMerge: (SymbolAndEntries[] | undefined)[]): SymbolAndEntries[] | undefined {\r\n        let result: SymbolAndEntries[] | undefined;\r\n        for (const references of referencesToMerge) {\r\n            if (!references || !references.length) continue;\r\n            if (!result) {\r\n                result = references;\r\n                continue;\r\n            }\r\n            for (const entry of references) {\r\n                if (!entry.definition || entry.definition.type !== DefinitionKind.Symbol) {\r\n                    result.push(entry);\r\n                    continue;\r\n                }\r\n                const symbol = entry.definition.symbol;\r\n                const refIndex = findIndex(result, ref =>\r\n                    !!ref.definition &&\r\n                    ref.definition.type === DefinitionKind.Symbol &&\r\n                    ref.definition.symbol === symbol);\r\n                if (refIndex === -1) {\r\n                    result.push(entry);\r\n                    continue;\r\n                }\r\n\r\n                const reference = result[refIndex];\r\n                result[refIndex] = {\r\n                    definition: reference.definition,\r\n                    references: reference.references.concat(entry.references).sort((entry1, entry2) => {\r\n                        const entry1File = getSourceFileIndexOfEntry(program, entry1);\r\n                        const entry2File = getSourceFileIndexOfEntry(program, entry2);\r\n                        if (entry1File !== entry2File) {\r\n                            return compareValues(entry1File, entry2File);\r\n                        }\r\n\r\n                        const entry1Span = getTextSpanOfEntry(entry1);\r\n                        const entry2Span = getTextSpanOfEntry(entry2);\r\n                        return entry1Span.start !== entry2Span.start ?\r\n                            compareValues(entry1Span.start, entry2Span.start) :\r\n                            compareValues(entry1Span.length, entry2Span.length);\r\n                    }),\r\n                };\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getSourceFileIndexOfEntry(program: Program, entry: Entry) {\r\n        const sourceFile = entry.kind === EntryKind.Span ?\r\n            program.getSourceFile(entry.fileName)! :\r\n            entry.node.getSourceFile();\r\n        return program.getSourceFiles().indexOf(sourceFile);\r\n    }\r\n\r\n    function getReferencedSymbolsForModule(program: Program, symbol: Symbol, excludeImportTypeOfExportEquals: boolean, sourceFiles: readonly SourceFile[], sourceFilesSet: ReadonlySet<string>): SymbolAndEntries[] {\r\n        Debug.assert(!!symbol.valueDeclaration);\r\n\r\n        const references = mapDefined<ModuleReference, Entry>(findModuleReferences(program, sourceFiles, symbol), reference => {\r\n            if (reference.kind === \"import\") {\r\n                const parent = reference.literal.parent;\r\n                if (isLiteralTypeNode(parent)) {\r\n                    const importType = cast(parent.parent, isImportTypeNode);\r\n                    if (excludeImportTypeOfExportEquals && !importType.qualifier) {\r\n                        return undefined;\r\n                    }\r\n                }\r\n                // import(\"foo\") with no qualifier will reference the `export =` of the module, which may be referenced anyway.\r\n                return nodeEntry(reference.literal);\r\n            }\r\n            else if (reference.kind === \"implicit\") {\r\n                // Return either: The first JSX node in the (if not a tslib import), the first statement of the file, or the whole file if neither of those exist\r\n                const range = reference.literal.text !== externalHelpersModuleNameText && forEachChildRecursively(\r\n                            reference.referencingFile,\r\n                            n => !(n.transformFlags & TransformFlags.ContainsJsx) ? \"skip\" : isJsxElement(n) || isJsxSelfClosingElement(n) || isJsxFragment(n) ? n : undefined,\r\n                        ) || reference.referencingFile.statements[0] || reference.referencingFile;\r\n                return nodeEntry(range);\r\n            }\r\n            else {\r\n                return {\r\n                    kind: EntryKind.Span,\r\n                    fileName: reference.referencingFile.fileName,\r\n                    textSpan: createTextSpanFromRange(reference.ref),\r\n                };\r\n            }\r\n        });\r\n\r\n        if (symbol.declarations) {\r\n            for (const decl of symbol.declarations) {\r\n                switch (decl.kind) {\r\n                    case SyntaxKind.SourceFile:\r\n                        // Don't include the source file itself. (This may not be ideal behavior, but awkward to include an entire file as a reference.)\r\n                        break;\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                        if (sourceFilesSet.has(decl.getSourceFile().fileName)) {\r\n                            references.push(nodeEntry((decl as ModuleDeclaration).name));\r\n                        }\r\n                        break;\r\n                    default:\r\n                        // This may be merged with something.\r\n                        Debug.assert(!!(symbol.flags & SymbolFlags.Transient), \"Expected a module symbol to be declared by a SourceFile or ModuleDeclaration.\");\r\n                }\r\n            }\r\n        }\r\n\r\n        const exported = symbol.exports!.get(InternalSymbolName.ExportEquals);\r\n        if (exported?.declarations) {\r\n            for (const decl of exported.declarations) {\r\n                const sourceFile = decl.getSourceFile();\r\n                if (sourceFilesSet.has(sourceFile.fileName)) {\r\n                    // At `module.exports = ...`, reference node is `module`\r\n                    const node = isBinaryExpression(decl) && isPropertyAccessExpression(decl.left) ? decl.left.expression :\r\n                        isExportAssignment(decl) ? Debug.checkDefined(findChildOfKind(decl, SyntaxKind.ExportKeyword, sourceFile)) :\r\n                        getNameOfDeclaration(decl) || decl;\r\n                    references.push(nodeEntry(node));\r\n                }\r\n            }\r\n        }\r\n\r\n        return references.length ? [{ definition: { type: DefinitionKind.Symbol, symbol }, references }] : emptyArray;\r\n    }\r\n\r\n    /** As in a `readonly prop: any` or `constructor(readonly prop: any)`, not a `readonly any[]`. */\r\n    function isReadonlyTypeOperator(node: Node): boolean {\r\n        return node.kind === SyntaxKind.ReadonlyKeyword\r\n            && isTypeOperatorNode(node.parent)\r\n            && node.parent.operator === SyntaxKind.ReadonlyKeyword;\r\n    }\r\n\r\n    /** getReferencedSymbols for special node kinds. */\r\n    function getReferencedSymbolsSpecial(node: Node, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken): SymbolAndEntries[] | undefined {\r\n        if (isTypeKeyword(node.kind)) {\r\n            // A void expression (i.e., `void foo()`) is not special, but the `void` type is.\r\n            if (node.kind === SyntaxKind.VoidKeyword && isVoidExpression(node.parent)) {\r\n                return undefined;\r\n            }\r\n\r\n            // A modifier readonly (like on a property declaration) is not special;\r\n            // a readonly type keyword (like `readonly string[]`) is.\r\n            if (node.kind === SyntaxKind.ReadonlyKeyword && !isReadonlyTypeOperator(node)) {\r\n                return undefined;\r\n            }\r\n            // Likewise, when we *are* looking for a special keyword, make sure we\r\n            // *don't* include readonly member modifiers.\r\n            return getAllReferencesForKeyword(\r\n                sourceFiles,\r\n                node.kind,\r\n                cancellationToken,\r\n                node.kind === SyntaxKind.ReadonlyKeyword ? isReadonlyTypeOperator : undefined,\r\n            );\r\n        }\r\n\r\n        if (isImportMeta(node.parent) && node.parent.name === node) {\r\n            return getAllReferencesForImportMeta(sourceFiles, cancellationToken);\r\n        }\r\n\r\n        if (isStaticModifier(node) && isClassStaticBlockDeclaration(node.parent)) {\r\n            return [{ definition: { type: DefinitionKind.Keyword, node }, references: [nodeEntry(node)] }];\r\n        }\r\n\r\n        // Labels\r\n        if (isJumpStatementTarget(node)) {\r\n            const labelDefinition = getTargetLabel(node.parent, node.text);\r\n            // if we have a label definition, look within its statement for references, if not, then\r\n            // the label is undefined and we have no results..\r\n            return labelDefinition && getLabelReferencesInNode(labelDefinition.parent, labelDefinition);\r\n        }\r\n        else if (isLabelOfLabeledStatement(node)) {\r\n            // it is a label definition and not a target, search within the parent labeledStatement\r\n            return getLabelReferencesInNode(node.parent, node);\r\n        }\r\n\r\n        if (isThis(node)) {\r\n            return getReferencesForThisKeyword(node, sourceFiles, cancellationToken);\r\n        }\r\n\r\n        if (node.kind === SyntaxKind.SuperKeyword) {\r\n            return getReferencesForSuperKeyword(node);\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /** Core find-all-references algorithm for a normal symbol. */\r\n    function getReferencedSymbolsForSymbol(originalSymbol: Symbol, node: Node | undefined, sourceFiles: readonly SourceFile[], sourceFilesSet: ReadonlySet<string>, checker: TypeChecker, cancellationToken: CancellationToken, options: Options): SymbolAndEntries[] {\r\n        const symbol = node && skipPastExportOrImportSpecifierOrUnion(originalSymbol, node, checker, /*useLocalSymbolForExportSpecifier*/ !isForRenameWithPrefixAndSuffixText(options)) || originalSymbol;\r\n\r\n        // Compute the meaning from the location and the symbol it references\r\n        const searchMeaning = node && options.use !== FindReferencesUse.Rename ? getIntersectingMeaningFromDeclarations(node, symbol) : SemanticMeaning.All;\r\n        const result: SymbolAndEntries[] = [];\r\n        const state = new State(sourceFiles, sourceFilesSet, node ? getSpecialSearchKind(node) : SpecialSearchKind.None, checker, cancellationToken, searchMeaning, options, result);\r\n\r\n        const exportSpecifier = !isForRenameWithPrefixAndSuffixText(options) || !symbol.declarations ? undefined : find(symbol.declarations, isExportSpecifier);\r\n        if (exportSpecifier) {\r\n            // When renaming at an export specifier, rename the export and not the thing being exported.\r\n            getReferencesAtExportSpecifier(exportSpecifier.name, symbol, exportSpecifier, state.createSearch(node, originalSymbol, /*comingFrom*/ undefined), state, /*addReferencesHere*/ true, /*alwaysGetReferences*/ true);\r\n        }\r\n        else if (node && node.kind === SyntaxKind.DefaultKeyword && symbol.escapedName === InternalSymbolName.Default && symbol.parent) {\r\n            addReference(node, symbol, state);\r\n            searchForImportsOfExport(node, symbol, { exportingModuleSymbol: symbol.parent, exportKind: ExportKind.Default }, state);\r\n        }\r\n        else {\r\n            const search = state.createSearch(node, symbol, /*comingFrom*/ undefined, { allSearchSymbols: node ? populateSearchSymbolSet(symbol, node, checker, options.use === FindReferencesUse.Rename, !!options.providePrefixAndSuffixTextForRename, !!options.implementations) : [symbol] });\r\n            getReferencesInContainerOrFiles(symbol, state, search);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getReferencesInContainerOrFiles(symbol: Symbol, state: State, search: Search): void {\r\n        // Try to get the smallest valid scope that we can limit our search to;\r\n        // otherwise we'll need to search globally (i.e. include each file).\r\n        const scope = getSymbolScope(symbol);\r\n        if (scope) {\r\n            getReferencesInContainer(scope, scope.getSourceFile(), search, state, /*addReferencesHere*/ !(isSourceFile(scope) && !contains(state.sourceFiles, scope)));\r\n        }\r\n        else {\r\n            // Global search\r\n            for (const sourceFile of state.sourceFiles) {\r\n                state.cancellationToken.throwIfCancellationRequested();\r\n                searchForName(sourceFile, search, state);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getSpecialSearchKind(node: Node): SpecialSearchKind {\r\n        switch (node.kind) {\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.ConstructorKeyword:\r\n                return SpecialSearchKind.Constructor;\r\n            case SyntaxKind.Identifier:\r\n                if (isClassLike(node.parent)) {\r\n                    Debug.assert(node.parent.name === node);\r\n                    return SpecialSearchKind.Class;\r\n                }\r\n                // falls through\r\n            default:\r\n                return SpecialSearchKind.None;\r\n        }\r\n    }\r\n\r\n    /** Handle a few special cases relating to export/import specifiers. */\r\n    function skipPastExportOrImportSpecifierOrUnion(symbol: Symbol, node: Node, checker: TypeChecker, useLocalSymbolForExportSpecifier: boolean): Symbol | undefined {\r\n        const { parent } = node;\r\n        if (isExportSpecifier(parent) && useLocalSymbolForExportSpecifier) {\r\n            return getLocalSymbolForExportSpecifier(node as Identifier, symbol, parent, checker);\r\n        }\r\n        // If the symbol is declared as part of a declaration like `{ type: \"a\" } | { type: \"b\" }`, use the property on the union type to get more references.\r\n        return firstDefined(symbol.declarations, decl => {\r\n            if (!decl.parent) {\r\n                // Ignore UMD module and global merge\r\n                if (symbol.flags & SymbolFlags.Transient) return undefined;\r\n                // Assertions for GH#21814. We should be handling SourceFile symbols in `getReferencedSymbolsForModule` instead of getting here.\r\n                Debug.fail(`Unexpected symbol at ${Debug.formatSyntaxKind(node.kind)}: ${Debug.formatSymbol(symbol)}`);\r\n            }\r\n            return isTypeLiteralNode(decl.parent) && isUnionTypeNode(decl.parent.parent)\r\n                ? checker.getPropertyOfType(checker.getTypeFromTypeNode(decl.parent.parent), symbol.name)\r\n                : undefined;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Symbol that is currently being searched for.\r\n     * This will be replaced if we find an alias for the symbol.\r\n     */\r\n    interface Search {\r\n        /** If coming from an export, we will not recursively search for the imported symbol (since that's where we came from). */\r\n        readonly comingFrom?: ImportExport;\r\n\r\n        readonly symbol: Symbol;\r\n        readonly text: string;\r\n        readonly escapedText: __String;\r\n        /** Only set if `options.implementations` is true. These are the symbols checked to get the implementations of a property access. */\r\n        readonly parents: readonly Symbol[] | undefined;\r\n        readonly allSearchSymbols: readonly Symbol[];\r\n\r\n        /**\r\n         * Whether a symbol is in the search set.\r\n         * Do not compare directly to `symbol` because there may be related symbols to search for. See `populateSearchSymbolSet`.\r\n         */\r\n        includes(symbol: Symbol): boolean;\r\n    }\r\n\r\n    const enum SpecialSearchKind {\r\n        None,\r\n        Constructor,\r\n        Class,\r\n    }\r\n\r\n    function getNonModuleSymbolOfMergedModuleSymbol(symbol: Symbol) {\r\n        if (!(symbol.flags & (SymbolFlags.Module | SymbolFlags.Transient))) return undefined;\r\n        const decl = symbol.declarations && find(symbol.declarations, d => !isSourceFile(d) && !isModuleDeclaration(d));\r\n        return decl && decl.symbol;\r\n    }\r\n\r\n    /**\r\n     * Holds all state needed for the finding references.\r\n     * Unlike `Search`, there is only one `State`.\r\n     */\r\n    class State {\r\n        /** Cache for `explicitlyinheritsFrom`. */\r\n        readonly inheritsFromCache = new Map<string, boolean>();\r\n\r\n        /**\r\n         * Type nodes can contain multiple references to the same type. For example:\r\n         *      let x: Foo & (Foo & Bar) = ...\r\n         * Because we are returning the implementation locations and not the identifier locations,\r\n         * duplicate entries would be returned here as each of the type references is part of\r\n         * the same implementation. For that reason, check before we add a new entry.\r\n         */\r\n        readonly markSeenContainingTypeReference = nodeSeenTracker();\r\n\r\n        /**\r\n         * It's possible that we will encounter the right side of `export { foo as bar } from \"x\";` more than once.\r\n         * For example:\r\n         *     // b.ts\r\n         *     export { foo as bar } from \"./a\";\r\n         *     import { bar } from \"./b\";\r\n         *\r\n         * Normally at `foo as bar` we directly add `foo` and do not locally search for it (since it doesn't declare a local).\r\n         * But another reference to it may appear in the same source file.\r\n         * See `tests/cases/fourslash/transitiveExportImports3.ts`.\r\n         */\r\n        readonly markSeenReExportRHS = nodeSeenTracker();\r\n\r\n        constructor(\r\n            readonly sourceFiles: readonly SourceFile[],\r\n            readonly sourceFilesSet: ReadonlySet<string>,\r\n            readonly specialSearchKind: SpecialSearchKind,\r\n            readonly checker: TypeChecker,\r\n            readonly cancellationToken: CancellationToken,\r\n            readonly searchMeaning: SemanticMeaning,\r\n            readonly options: Options,\r\n            private readonly result: SymbolAndEntries[],\r\n        ) {\r\n        }\r\n\r\n        includesSourceFile(sourceFile: SourceFile): boolean {\r\n            return this.sourceFilesSet.has(sourceFile.fileName);\r\n        }\r\n\r\n        private importTracker: ImportTracker | undefined;\r\n        /** Gets every place to look for references of an exported symbols. See `ImportsResult` in `importTracker.ts` for more documentation. */\r\n        getImportSearches(exportSymbol: Symbol, exportInfo: ExportInfo): ImportsResult {\r\n            if (!this.importTracker) this.importTracker = createImportTracker(this.sourceFiles, this.sourceFilesSet, this.checker, this.cancellationToken);\r\n            return this.importTracker(exportSymbol, exportInfo, this.options.use === FindReferencesUse.Rename);\r\n        }\r\n\r\n        /** @param allSearchSymbols set of additional symbols for use by `includes`. */\r\n        createSearch(location: Node | undefined, symbol: Symbol, comingFrom: ImportExport | undefined, searchOptions: { text?: string; allSearchSymbols?: Symbol[]; } = {}): Search {\r\n            // Note: if this is an external module symbol, the name doesn't include quotes.\r\n            // Note: getLocalSymbolForExportDefault handles `export default class C {}`, but not `export default C` or `export { C as default }`.\r\n            // The other two forms seem to be handled downstream (e.g. in `skipPastExportOrImportSpecifier`), so special-casing the first form\r\n            // here appears to be intentional).\r\n            const {\r\n                text = stripQuotes(symbolName(getLocalSymbolForExportDefault(symbol) || getNonModuleSymbolOfMergedModuleSymbol(symbol) || symbol)),\r\n                allSearchSymbols = [symbol],\r\n            } = searchOptions;\r\n            const escapedText = escapeLeadingUnderscores(text);\r\n            const parents = this.options.implementations && location ? getParentSymbolsOfPropertyAccess(location, symbol, this.checker) : undefined;\r\n            return { symbol, comingFrom, text, escapedText, parents, allSearchSymbols, includes: sym => contains(allSearchSymbols, sym) };\r\n        }\r\n\r\n        private readonly symbolIdToReferences: Entry[][] = [];\r\n        /**\r\n         * Callback to add references for a particular searched symbol.\r\n         * This initializes a reference group, so only call this if you will add at least one reference.\r\n         */\r\n        referenceAdder(searchSymbol: Symbol): (node: Node, kind?: NodeEntryKind) => void {\r\n            const symbolId = getSymbolId(searchSymbol);\r\n            let references = this.symbolIdToReferences[symbolId];\r\n            if (!references) {\r\n                references = this.symbolIdToReferences[symbolId] = [];\r\n                this.result.push({ definition: { type: DefinitionKind.Symbol, symbol: searchSymbol }, references });\r\n            }\r\n            return (node, kind) => references.push(nodeEntry(node, kind));\r\n        }\r\n\r\n        /** Add a reference with no associated definition. */\r\n        addStringOrCommentReference(fileName: string, textSpan: TextSpan): void {\r\n            this.result.push({\r\n                definition: undefined,\r\n                references: [{ kind: EntryKind.Span, fileName, textSpan }],\r\n            });\r\n        }\r\n\r\n        // Source file ID -> symbol ID -> Whether the symbol has been searched for in the source file.\r\n        private readonly sourceFileToSeenSymbols: Set<number>[] = [];\r\n        /** Returns `true` the first time we search for a symbol in a file and `false` afterwards. */\r\n        markSearchedSymbols(sourceFile: SourceFile, symbols: readonly Symbol[]): boolean {\r\n            const sourceId = getNodeId(sourceFile);\r\n            const seenSymbols = this.sourceFileToSeenSymbols[sourceId] || (this.sourceFileToSeenSymbols[sourceId] = new Set<number>());\r\n\r\n            let anyNewSymbols = false;\r\n            for (const sym of symbols) {\r\n                anyNewSymbols = tryAddToSet(seenSymbols, getSymbolId(sym)) || anyNewSymbols;\r\n            }\r\n            return anyNewSymbols;\r\n        }\r\n    }\r\n\r\n    /** Search for all imports of a given exported symbol using `State.getImportSearches`. */\r\n    function searchForImportsOfExport(exportLocation: Node, exportSymbol: Symbol, exportInfo: ExportInfo, state: State): void {\r\n        const { importSearches, singleReferences, indirectUsers } = state.getImportSearches(exportSymbol, exportInfo);\r\n\r\n        // For `import { foo as bar }` just add the reference to `foo`, and don't otherwise search in the file.\r\n        if (singleReferences.length) {\r\n            const addRef = state.referenceAdder(exportSymbol);\r\n            for (const singleRef of singleReferences) {\r\n                if (shouldAddSingleReference(singleRef, state)) addRef(singleRef);\r\n            }\r\n        }\r\n\r\n        // For each import, find all references to that import in its source file.\r\n        for (const [importLocation, importSymbol] of importSearches) {\r\n            getReferencesInSourceFile(importLocation.getSourceFile(), state.createSearch(importLocation, importSymbol, ImportExport.Export), state);\r\n        }\r\n\r\n        if (indirectUsers.length) {\r\n            let indirectSearch: Search | undefined;\r\n            switch (exportInfo.exportKind) {\r\n                case ExportKind.Named:\r\n                    indirectSearch = state.createSearch(exportLocation, exportSymbol, ImportExport.Export);\r\n                    break;\r\n                case ExportKind.Default:\r\n                    // Search for a property access to '.default'. This can't be renamed.\r\n                    indirectSearch = state.options.use === FindReferencesUse.Rename ? undefined : state.createSearch(exportLocation, exportSymbol, ImportExport.Export, { text: \"default\" });\r\n                    break;\r\n                case ExportKind.ExportEquals:\r\n                    break;\r\n            }\r\n            if (indirectSearch) {\r\n                for (const indirectUser of indirectUsers) {\r\n                    searchForName(indirectUser, indirectSearch, state);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export function eachExportReference(\r\n        sourceFiles: readonly SourceFile[],\r\n        checker: TypeChecker,\r\n        cancellationToken: CancellationToken | undefined,\r\n        exportSymbol: Symbol,\r\n        exportingModuleSymbol: Symbol,\r\n        exportName: string,\r\n        isDefaultExport: boolean,\r\n        cb: (ref: ModuleExportName) => void,\r\n    ): void {\r\n        const importTracker = createImportTracker(sourceFiles, new Set(sourceFiles.map(f => f.fileName)), checker, cancellationToken);\r\n        const { importSearches, indirectUsers, singleReferences } = importTracker(exportSymbol, { exportKind: isDefaultExport ? ExportKind.Default : ExportKind.Named, exportingModuleSymbol }, /*isForRename*/ false);\r\n        for (const [importLocation] of importSearches) {\r\n            cb(importLocation);\r\n        }\r\n        for (const singleReference of singleReferences) {\r\n            if (isIdentifier(singleReference) && isImportTypeNode(singleReference.parent)) {\r\n                cb(singleReference);\r\n            }\r\n        }\r\n        for (const indirectUser of indirectUsers) {\r\n            for (const node of getPossibleSymbolReferenceNodes(indirectUser, isDefaultExport ? \"default\" : exportName)) {\r\n                // Import specifiers should be handled by importSearches\r\n                const symbol = checker.getSymbolAtLocation(node);\r\n                const hasExportAssignmentDeclaration = some(symbol?.declarations, d => tryCast(d, isExportAssignment) ? true : false);\r\n                if (isIdentifier(node) && !isImportOrExportSpecifier(node.parent) && (symbol === exportSymbol || hasExportAssignmentDeclaration)) {\r\n                    cb(node);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function shouldAddSingleReference(singleRef: Identifier | StringLiteral, state: State): boolean {\r\n        if (!hasMatchingMeaning(singleRef, state)) return false;\r\n        if (state.options.use !== FindReferencesUse.Rename) return true;\r\n        // Don't rename an import type `import(\"./module-name\")` when renaming `name` in `export = name;`\r\n        if (!isIdentifier(singleRef) && !isImportOrExportSpecifier(singleRef.parent)) return false;\r\n        // At `default` in `import { default as x }` or `export { default as x }`, do add a reference, but do not rename.\r\n        return !(isImportOrExportSpecifier(singleRef.parent) && moduleExportNameIsDefault(singleRef));\r\n    }\r\n\r\n    // Go to the symbol we imported from and find references for it.\r\n    function searchForImportedSymbol(symbol: Symbol, state: State): void {\r\n        if (!symbol.declarations) return;\r\n\r\n        for (const declaration of symbol.declarations) {\r\n            const exportingFile = declaration.getSourceFile();\r\n            // Need to search in the file even if it's not in the search-file set, because it might export the symbol.\r\n            getReferencesInSourceFile(exportingFile, state.createSearch(declaration, symbol, ImportExport.Import), state, state.includesSourceFile(exportingFile));\r\n        }\r\n    }\r\n\r\n    /** Search for all occurrences of an identifier in a source file (and filter out the ones that match). */\r\n    function searchForName(sourceFile: SourceFile, search: Search, state: State): void {\r\n        if (getNameTable(sourceFile).get(search.escapedText) !== undefined) {\r\n            getReferencesInSourceFile(sourceFile, search, state);\r\n        }\r\n    }\r\n\r\n    function getPropertySymbolOfDestructuringAssignment(location: Node, checker: TypeChecker): Symbol | undefined {\r\n        return isArrayLiteralOrObjectLiteralDestructuringPattern(location.parent.parent)\r\n            ? checker.getPropertySymbolOfDestructuringAssignment(location as Identifier)\r\n            : undefined;\r\n    }\r\n\r\n    /**\r\n     * Determines the smallest scope in which a symbol may have named references.\r\n     * Note that not every construct has been accounted for. This function can\r\n     * probably be improved.\r\n     *\r\n     * @returns undefined if the scope cannot be determined, implying that\r\n     * a reference to a symbol can occur anywhere.\r\n     */\r\n    function getSymbolScope(symbol: Symbol): Node | undefined {\r\n        // If this is the symbol of a named function expression or named class expression,\r\n        // then named references are limited to its own scope.\r\n        const { declarations, flags, parent, valueDeclaration } = symbol;\r\n        if (valueDeclaration && (valueDeclaration.kind === SyntaxKind.FunctionExpression || valueDeclaration.kind === SyntaxKind.ClassExpression)) {\r\n            return valueDeclaration;\r\n        }\r\n\r\n        if (!declarations) {\r\n            return undefined;\r\n        }\r\n\r\n        // If this is private property or method, the scope is the containing class\r\n        if (flags & (SymbolFlags.Property | SymbolFlags.Method)) {\r\n            const privateDeclaration = find(declarations, d => hasEffectiveModifier(d, ModifierFlags.Private) || isPrivateIdentifierClassElementDeclaration(d));\r\n            if (privateDeclaration) {\r\n                return getAncestor(privateDeclaration, SyntaxKind.ClassDeclaration);\r\n            }\r\n            // Else this is a public property and could be accessed from anywhere.\r\n            return undefined;\r\n        }\r\n\r\n        // If symbol is of object binding pattern element without property name we would want to\r\n        // look for property too and that could be anywhere\r\n        if (declarations.some(isObjectBindingElementWithoutPropertyName)) {\r\n            return undefined;\r\n        }\r\n\r\n        /*\r\n        If the symbol has a parent, it's globally visible unless:\r\n        - It's a private property (handled above).\r\n        - It's a type parameter.\r\n        - The parent is an external module: then we should only search in the module (and recurse on the export later).\r\n        - But if the parent has `export as namespace`, the symbol is globally visible through that namespace.\r\n        */\r\n        const exposedByParent = parent && !(symbol.flags & SymbolFlags.TypeParameter);\r\n        if (exposedByParent && !(isExternalModuleSymbol(parent) && !parent.globalExports)) {\r\n            return undefined;\r\n        }\r\n\r\n        let scope: Node | undefined;\r\n        for (const declaration of declarations) {\r\n            const container = getContainerNode(declaration);\r\n            if (scope && scope !== container) {\r\n                // Different declarations have different containers, bail out\r\n                return undefined;\r\n            }\r\n\r\n            if (!container || container.kind === SyntaxKind.SourceFile && !isExternalOrCommonJsModule(container as SourceFile)) {\r\n                // This is a global variable and not an external module, any declaration defined\r\n                // within this scope is visible outside the file\r\n                return undefined;\r\n            }\r\n\r\n            scope = container;\r\n            if (isFunctionExpression(scope)) {\r\n                let next: Node | undefined;\r\n                while (next = getNextJSDocCommentLocation(scope)) {\r\n                    scope = next;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If symbol.parent, this means we are in an export of an external module. (Otherwise we would have returned `undefined` above.)\r\n        // For an export of a module, we may be in a declaration file, and it may be accessed elsewhere. E.g.:\r\n        //     declare module \"a\" { export type T = number; }\r\n        //     declare module \"b\" { import { T } from \"a\"; export const x: T; }\r\n        // So we must search the whole source file. (Because we will mark the source file as seen, we we won't return to it when searching for imports.)\r\n        return exposedByParent ? scope!.getSourceFile() : scope; // TODO: GH#18217\r\n    }\r\n\r\n    /** Used as a quick check for whether a symbol is used at all in a file (besides its definition). */\r\n    export function isSymbolReferencedInFile(definition: Identifier, checker: TypeChecker, sourceFile: SourceFile, searchContainer: Node = sourceFile): boolean {\r\n        return eachSymbolReferenceInFile(definition, checker, sourceFile, () => true, searchContainer) || false;\r\n    }\r\n\r\n    export function eachSymbolReferenceInFile<T>(definition: Identifier, checker: TypeChecker, sourceFile: SourceFile, cb: (token: Identifier) => T, searchContainer: Node = sourceFile): T | undefined {\r\n        const symbol = isParameterPropertyDeclaration(definition.parent, definition.parent.parent)\r\n            ? first(checker.getSymbolsOfParameterPropertyDeclaration(definition.parent, definition.text))\r\n            : checker.getSymbolAtLocation(definition);\r\n        if (!symbol) return undefined;\r\n        for (const token of getPossibleSymbolReferenceNodes(sourceFile, symbol.name, searchContainer)) {\r\n            if (!isIdentifier(token) || token === definition || token.escapedText !== definition.escapedText) continue;\r\n            const referenceSymbol = checker.getSymbolAtLocation(token)!;\r\n            if (\r\n                referenceSymbol === symbol\r\n                || checker.getShorthandAssignmentValueSymbol(token.parent) === symbol\r\n                || isExportSpecifier(token.parent) && getLocalSymbolForExportSpecifier(token, referenceSymbol, token.parent, checker) === symbol\r\n            ) {\r\n                const res = cb(token);\r\n                if (res) return res;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function getTopMostDeclarationNamesInFile(declarationName: string, sourceFile: SourceFile): readonly Node[] {\r\n        const candidates = filter(getPossibleSymbolReferenceNodes(sourceFile, declarationName), name => !!getDeclarationFromName(name));\r\n        return candidates.reduce((topMost, decl) => {\r\n            const depth = getDepth(decl);\r\n            if (!some(topMost.declarationNames) || depth === topMost.depth) {\r\n                topMost.declarationNames.push(decl);\r\n                topMost.depth = depth;\r\n            }\r\n            else if (depth < topMost.depth) {\r\n                topMost.declarationNames = [decl];\r\n                topMost.depth = depth;\r\n            }\r\n            return topMost;\r\n        }, { depth: Infinity, declarationNames: [] as Node[] }).declarationNames;\r\n\r\n        function getDepth(declaration: Node | undefined) {\r\n            let depth = 0;\r\n            while (declaration) {\r\n                declaration = getContainerNode(declaration);\r\n                depth++;\r\n            }\r\n            return depth;\r\n        }\r\n    }\r\n\r\n    export function someSignatureUsage(\r\n        signature: SignatureDeclaration,\r\n        sourceFiles: readonly SourceFile[],\r\n        checker: TypeChecker,\r\n        cb: (name: Identifier, call?: CallExpression) => boolean,\r\n    ): boolean {\r\n        if (!signature.name || !isIdentifier(signature.name)) return false;\r\n\r\n        const symbol = Debug.checkDefined(checker.getSymbolAtLocation(signature.name));\r\n\r\n        for (const sourceFile of sourceFiles) {\r\n            for (const name of getPossibleSymbolReferenceNodes(sourceFile, symbol.name)) {\r\n                if (!isIdentifier(name) || name === signature.name || name.escapedText !== signature.name.escapedText) continue;\r\n                const called = climbPastPropertyAccess(name);\r\n                const call = isCallExpression(called.parent) && called.parent.expression === called ? called.parent : undefined;\r\n                const referenceSymbol = checker.getSymbolAtLocation(name);\r\n                if (referenceSymbol && checker.getRootSymbols(referenceSymbol).some(s => s === symbol)) {\r\n                    if (cb(name, call)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getPossibleSymbolReferenceNodes(sourceFile: SourceFile, symbolName: string, container: Node = sourceFile): readonly Node[] {\r\n        return mapDefined(getPossibleSymbolReferencePositions(sourceFile, symbolName, container), pos => {\r\n            const referenceLocation = getTouchingPropertyName(sourceFile, pos);\r\n            return referenceLocation === sourceFile ? undefined : referenceLocation;\r\n        });\r\n    }\r\n\r\n    function getPossibleSymbolReferencePositions(sourceFile: SourceFile, symbolName: string, container: Node = sourceFile): readonly number[] {\r\n        const positions: number[] = [];\r\n\r\n        /// TODO: Cache symbol existence for files to save text search\r\n        // Also, need to make this work for unicode escapes.\r\n\r\n        // Be resilient in the face of a symbol with no name or zero length name\r\n        if (!symbolName || !symbolName.length) {\r\n            return positions;\r\n        }\r\n\r\n        const text = sourceFile.text;\r\n        const sourceLength = text.length;\r\n        const symbolNameLength = symbolName.length;\r\n\r\n        let position = text.indexOf(symbolName, container.pos);\r\n        while (position >= 0) {\r\n            // If we are past the end, stop looking\r\n            if (position > container.end) break;\r\n\r\n            // We found a match.  Make sure it's not part of a larger word (i.e. the char\r\n            // before and after it have to be a non-identifier char).\r\n            const endPosition = position + symbolNameLength;\r\n\r\n            if (\r\n                (position === 0 || !isIdentifierPart(text.charCodeAt(position - 1), ScriptTarget.Latest)) &&\r\n                (endPosition === sourceLength || !isIdentifierPart(text.charCodeAt(endPosition), ScriptTarget.Latest))\r\n            ) {\r\n                // Found a real match.  Keep searching.\r\n                positions.push(position);\r\n            }\r\n            position = text.indexOf(symbolName, position + symbolNameLength + 1);\r\n        }\r\n\r\n        return positions;\r\n    }\r\n\r\n    function getLabelReferencesInNode(container: Node, targetLabel: Identifier): SymbolAndEntries[] {\r\n        const sourceFile = container.getSourceFile();\r\n        const labelName = targetLabel.text;\r\n        const references = mapDefined(getPossibleSymbolReferenceNodes(sourceFile, labelName, container), node =>\r\n            // Only pick labels that are either the target label, or have a target that is the target label\r\n            node === targetLabel || (isJumpStatementTarget(node) && getTargetLabel(node, labelName) === targetLabel) ? nodeEntry(node) : undefined);\r\n        return [{ definition: { type: DefinitionKind.Label, node: targetLabel }, references }];\r\n    }\r\n\r\n    function isValidReferencePosition(node: Node, searchSymbolName: string): boolean {\r\n        // Compare the length so we filter out strict superstrings of the symbol we are looking for\r\n        switch (node.kind) {\r\n            case SyntaxKind.PrivateIdentifier:\r\n                if (isJSDocMemberName(node.parent)) {\r\n                    return true;\r\n                }\r\n                // falls through I guess\r\n            case SyntaxKind.Identifier:\r\n                return (node as PrivateIdentifier | Identifier).text.length === searchSymbolName.length;\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.StringLiteral: {\r\n                const str = node as StringLiteralLike;\r\n                return str.text.length === searchSymbolName.length && (\r\n                    isLiteralNameOfPropertyDeclarationOrIndexAccess(str) ||\r\n                    isNameOfModuleDeclaration(node) ||\r\n                    isExpressionOfExternalModuleImportEqualsDeclaration(node) ||\r\n                    (isCallExpression(node.parent) && isBindableObjectDefinePropertyCall(node.parent) && node.parent.arguments[1] === node) ||\r\n                    isImportOrExportSpecifier(node.parent)\r\n                );\r\n            }\r\n\r\n            case SyntaxKind.NumericLiteral:\r\n                return isLiteralNameOfPropertyDeclarationOrIndexAccess(node as NumericLiteral) && (node as NumericLiteral).text.length === searchSymbolName.length;\r\n\r\n            case SyntaxKind.DefaultKeyword:\r\n                return \"default\".length === searchSymbolName.length;\r\n\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    function getAllReferencesForImportMeta(sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken): SymbolAndEntries[] | undefined {\r\n        const references = flatMap(sourceFiles, sourceFile => {\r\n            cancellationToken.throwIfCancellationRequested();\r\n            return mapDefined(getPossibleSymbolReferenceNodes(sourceFile, \"meta\", sourceFile), node => {\r\n                const parent = node.parent;\r\n                if (isImportMeta(parent)) {\r\n                    return nodeEntry(parent);\r\n                }\r\n            });\r\n        });\r\n        return references.length ? [{ definition: { type: DefinitionKind.Keyword, node: references[0].node }, references }] : undefined;\r\n    }\r\n\r\n    function getAllReferencesForKeyword(sourceFiles: readonly SourceFile[], keywordKind: SyntaxKind, cancellationToken: CancellationToken, filter?: (node: Node) => boolean): SymbolAndEntries[] | undefined {\r\n        const references = flatMap(sourceFiles, sourceFile => {\r\n            cancellationToken.throwIfCancellationRequested();\r\n            return mapDefined(getPossibleSymbolReferenceNodes(sourceFile, tokenToString(keywordKind)!, sourceFile), referenceLocation => {\r\n                if (referenceLocation.kind === keywordKind && (!filter || filter(referenceLocation))) {\r\n                    return nodeEntry(referenceLocation);\r\n                }\r\n            });\r\n        });\r\n        return references.length ? [{ definition: { type: DefinitionKind.Keyword, node: references[0].node }, references }] : undefined;\r\n    }\r\n\r\n    function getReferencesInSourceFile(sourceFile: SourceFile, search: Search, state: State, addReferencesHere = true): void {\r\n        state.cancellationToken.throwIfCancellationRequested();\r\n        return getReferencesInContainer(sourceFile, sourceFile, search, state, addReferencesHere);\r\n    }\r\n\r\n    /**\r\n     * Search within node \"container\" for references for a search value, where the search value is defined as a\r\n     * tuple of(searchSymbol, searchText, searchLocation, and searchMeaning).\r\n     * searchLocation: a node where the search value\r\n     */\r\n    function getReferencesInContainer(container: Node, sourceFile: SourceFile, search: Search, state: State, addReferencesHere: boolean): void {\r\n        if (!state.markSearchedSymbols(sourceFile, search.allSearchSymbols)) {\r\n            return;\r\n        }\r\n\r\n        for (const position of getPossibleSymbolReferencePositions(sourceFile, search.text, container)) {\r\n            getReferencesAtLocation(sourceFile, position, search, state, addReferencesHere);\r\n        }\r\n    }\r\n\r\n    function hasMatchingMeaning(referenceLocation: Node, state: State): boolean {\r\n        return !!(getMeaningFromLocation(referenceLocation) & state.searchMeaning);\r\n    }\r\n\r\n    function getReferencesAtLocation(sourceFile: SourceFile, position: number, search: Search, state: State, addReferencesHere: boolean): void {\r\n        const referenceLocation = getTouchingPropertyName(sourceFile, position);\r\n\r\n        if (!isValidReferencePosition(referenceLocation, search.text)) {\r\n            // This wasn't the start of a token.  Check to see if it might be a\r\n            // match in a comment or string if that's what the caller is asking\r\n            // for.\r\n            if (!state.options.implementations && (state.options.findInStrings && isInString(sourceFile, position) || state.options.findInComments && isInNonReferenceComment(sourceFile, position))) {\r\n                // In the case where we're looking inside comments/strings, we don't have\r\n                // an actual definition.  So just use 'undefined' here.  Features like\r\n                // 'Rename' won't care (as they ignore the definitions), and features like\r\n                // 'FindReferences' will just filter out these results.\r\n                state.addStringOrCommentReference(sourceFile.fileName, createTextSpan(position, search.text.length));\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (!hasMatchingMeaning(referenceLocation, state)) return;\r\n\r\n        let referenceSymbol = state.checker.getSymbolAtLocation(referenceLocation);\r\n        if (!referenceSymbol) {\r\n            return;\r\n        }\r\n\r\n        const parent = referenceLocation.parent;\r\n        if (isImportSpecifier(parent) && parent.propertyName === referenceLocation) {\r\n            // This is added through `singleReferences` in ImportsResult. If we happen to see it again, don't add it again.\r\n            return;\r\n        }\r\n\r\n        if (isExportSpecifier(parent)) {\r\n            Debug.assert(referenceLocation.kind === SyntaxKind.Identifier || referenceLocation.kind === SyntaxKind.StringLiteral);\r\n            getReferencesAtExportSpecifier(referenceLocation as Identifier | StringLiteral, referenceSymbol, parent, search, state, addReferencesHere);\r\n            return;\r\n        }\r\n\r\n        if (\r\n            isJSDocPropertyLikeTag(parent) && parent.isNameFirst &&\r\n            parent.typeExpression && isJSDocTypeLiteral(parent.typeExpression.type) &&\r\n            parent.typeExpression.type.jsDocPropertyTags && length(parent.typeExpression.type.jsDocPropertyTags)\r\n        ) {\r\n            getReferencesAtJSDocTypeLiteral(parent.typeExpression.type.jsDocPropertyTags, referenceLocation, search, state);\r\n            return;\r\n        }\r\n\r\n        const relatedSymbol = getRelatedSymbol(search, referenceSymbol, referenceLocation, state);\r\n        if (!relatedSymbol) {\r\n            getReferenceForShorthandProperty(referenceSymbol, search, state);\r\n            return;\r\n        }\r\n\r\n        switch (state.specialSearchKind) {\r\n            case SpecialSearchKind.None:\r\n                if (addReferencesHere) addReference(referenceLocation, relatedSymbol, state);\r\n                break;\r\n            case SpecialSearchKind.Constructor:\r\n                addConstructorReferences(referenceLocation, sourceFile, search, state);\r\n                break;\r\n            case SpecialSearchKind.Class:\r\n                addClassStaticThisReferences(referenceLocation, search, state);\r\n                break;\r\n            default:\r\n                Debug.assertNever(state.specialSearchKind);\r\n        }\r\n\r\n        // Use the parent symbol if the location is commonjs require syntax on javascript files only.\r\n        if (\r\n            isInJSFile(referenceLocation)\r\n            && isBindingElement(referenceLocation.parent)\r\n            && isVariableDeclarationInitializedToBareOrAccessedRequire(referenceLocation.parent.parent.parent)\r\n        ) {\r\n            referenceSymbol = referenceLocation.parent.symbol;\r\n            // The parent will not have a symbol if it's an ObjectBindingPattern (when destructuring is used).  In\r\n            // this case, just skip it, since the bound identifiers are not an alias of the import.\r\n            if (!referenceSymbol) return;\r\n        }\r\n\r\n        getImportOrExportReferences(referenceLocation, referenceSymbol, search, state);\r\n    }\r\n\r\n    function getReferencesAtJSDocTypeLiteral(jsDocPropertyTags: readonly JSDocPropertyLikeTag[], referenceLocation: Node, search: Search, state: State) {\r\n        const addRef = state.referenceAdder(search.symbol);\r\n\r\n        addReference(referenceLocation, search.symbol, state);\r\n        forEach(jsDocPropertyTags, propTag => {\r\n            if (isQualifiedName(propTag.name)) {\r\n                addRef(propTag.name.left);\r\n            }\r\n        });\r\n    }\r\n\r\n    function getReferencesAtExportSpecifier(\r\n        referenceLocation: ModuleExportName,\r\n        referenceSymbol: Symbol,\r\n        exportSpecifier: ExportSpecifier,\r\n        search: Search,\r\n        state: State,\r\n        addReferencesHere: boolean,\r\n        alwaysGetReferences?: boolean,\r\n    ): void {\r\n        Debug.assert(!alwaysGetReferences || !!state.options.providePrefixAndSuffixTextForRename, \"If alwaysGetReferences is true, then prefix/suffix text must be enabled\");\r\n\r\n        const { parent, propertyName, name } = exportSpecifier;\r\n        const exportDeclaration = parent.parent;\r\n        const localSymbol = getLocalSymbolForExportSpecifier(referenceLocation, referenceSymbol, exportSpecifier, state.checker);\r\n        if (!alwaysGetReferences && !search.includes(localSymbol)) {\r\n            return;\r\n        }\r\n\r\n        if (!propertyName) {\r\n            // Don't rename at `export { default } from \"m\";`. (but do continue to search for imports of the re-export)\r\n            if (!(state.options.use === FindReferencesUse.Rename && moduleExportNameIsDefault(name))) {\r\n                addRef();\r\n            }\r\n        }\r\n        else if (referenceLocation === propertyName) {\r\n            // For `export { foo as bar } from \"baz\"`, \"`foo`\" will be added from the singleReferences for import searches of the original export.\r\n            // For `export { foo as bar };`, where `foo` is a local, so add it now.\r\n            if (!exportDeclaration.moduleSpecifier) {\r\n                addRef();\r\n            }\r\n\r\n            if (addReferencesHere && state.options.use !== FindReferencesUse.Rename && state.markSeenReExportRHS(name)) {\r\n                addReference(name, Debug.checkDefined(exportSpecifier.symbol), state);\r\n            }\r\n        }\r\n        else {\r\n            if (state.markSeenReExportRHS(referenceLocation)) {\r\n                addRef();\r\n            }\r\n        }\r\n\r\n        // For `export { foo as bar }`, rename `foo`, but not `bar`.\r\n        if (!isForRenameWithPrefixAndSuffixText(state.options) || alwaysGetReferences) {\r\n            const isDefaultExport = moduleExportNameIsDefault(referenceLocation)\r\n                || moduleExportNameIsDefault(exportSpecifier.name);\r\n            const exportKind = isDefaultExport ? ExportKind.Default : ExportKind.Named;\r\n            const exportSymbol = Debug.checkDefined(exportSpecifier.symbol);\r\n            const exportInfo = getExportInfo(exportSymbol, exportKind, state.checker);\r\n            if (exportInfo) {\r\n                searchForImportsOfExport(referenceLocation, exportSymbol, exportInfo, state);\r\n            }\r\n        }\r\n\r\n        // At `export { x } from \"foo\"`, also search for the imported symbol `\"foo\".x`.\r\n        if (search.comingFrom !== ImportExport.Export && exportDeclaration.moduleSpecifier && !propertyName && !isForRenameWithPrefixAndSuffixText(state.options)) {\r\n            const imported = state.checker.getExportSpecifierLocalTargetSymbol(exportSpecifier);\r\n            if (imported) searchForImportedSymbol(imported, state);\r\n        }\r\n\r\n        function addRef() {\r\n            if (addReferencesHere) addReference(referenceLocation, localSymbol, state);\r\n        }\r\n    }\r\n\r\n    function getLocalSymbolForExportSpecifier(referenceLocation: ModuleExportName, referenceSymbol: Symbol, exportSpecifier: ExportSpecifier, checker: TypeChecker): Symbol {\r\n        return isExportSpecifierAlias(referenceLocation, exportSpecifier) && checker.getExportSpecifierLocalTargetSymbol(exportSpecifier) || referenceSymbol;\r\n    }\r\n\r\n    function isExportSpecifierAlias(referenceLocation: ModuleExportName, exportSpecifier: ExportSpecifier): boolean {\r\n        const { parent, propertyName, name } = exportSpecifier;\r\n        Debug.assert(propertyName === referenceLocation || name === referenceLocation);\r\n        if (propertyName) {\r\n            // Given `export { foo as bar } [from \"someModule\"]`: It's an alias at `foo`, but at `bar` it's a new symbol.\r\n            return propertyName === referenceLocation;\r\n        }\r\n        else {\r\n            // `export { foo } from \"foo\"` is a re-export.\r\n            // `export { foo };` is not a re-export, it creates an alias for the local variable `foo`.\r\n            return !parent.parent.moduleSpecifier;\r\n        }\r\n    }\r\n\r\n    function getImportOrExportReferences(referenceLocation: Node, referenceSymbol: Symbol, search: Search, state: State): void {\r\n        const importOrExport = getImportOrExportSymbol(referenceLocation, referenceSymbol, state.checker, search.comingFrom === ImportExport.Export);\r\n        if (!importOrExport) return;\r\n\r\n        const { symbol } = importOrExport;\r\n\r\n        if (importOrExport.kind === ImportExport.Import) {\r\n            if (!(isForRenameWithPrefixAndSuffixText(state.options))) {\r\n                searchForImportedSymbol(symbol, state);\r\n            }\r\n        }\r\n        else {\r\n            searchForImportsOfExport(referenceLocation, symbol, importOrExport.exportInfo, state);\r\n        }\r\n    }\r\n\r\n    function getReferenceForShorthandProperty({ flags, valueDeclaration }: Symbol, search: Search, state: State): void {\r\n        const shorthandValueSymbol = state.checker.getShorthandAssignmentValueSymbol(valueDeclaration)!;\r\n        const name = valueDeclaration && getNameOfDeclaration(valueDeclaration);\r\n        /*\r\n         * Because in short-hand property assignment, an identifier which stored as name of the short-hand property assignment\r\n         * has two meanings: property name and property value. Therefore when we do findAllReference at the position where\r\n         * an identifier is declared, the language service should return the position of the variable declaration as well as\r\n         * the position in short-hand property assignment excluding property accessing. However, if we do findAllReference at the\r\n         * position of property accessing, the referenceEntry of such position will be handled in the first case.\r\n         */\r\n        if (!(flags & SymbolFlags.Transient) && name && search.includes(shorthandValueSymbol)) {\r\n            addReference(name, shorthandValueSymbol, state);\r\n        }\r\n    }\r\n\r\n    function addReference(referenceLocation: Node, relatedSymbol: Symbol | RelatedSymbol, state: State): void {\r\n        const { kind, symbol } = \"kind\" in relatedSymbol ? relatedSymbol : { kind: undefined, symbol: relatedSymbol }; // eslint-disable-line local/no-in-operator\r\n\r\n        // if rename symbol from default export anonymous function, for example `export default function() {}`, we do not need to add reference\r\n        if (state.options.use === FindReferencesUse.Rename && referenceLocation.kind === SyntaxKind.DefaultKeyword) {\r\n            return;\r\n        }\r\n\r\n        const addRef = state.referenceAdder(symbol);\r\n        if (state.options.implementations) {\r\n            addImplementationReferences(referenceLocation, addRef, state);\r\n        }\r\n        else {\r\n            addRef(referenceLocation, kind);\r\n        }\r\n    }\r\n\r\n    /** Adds references when a constructor is used with `new this()` in its own class and `super()` calls in subclasses.  */\r\n    function addConstructorReferences(referenceLocation: Node, sourceFile: SourceFile, search: Search, state: State): void {\r\n        if (isNewExpressionTarget(referenceLocation)) {\r\n            addReference(referenceLocation, search.symbol, state);\r\n        }\r\n\r\n        const pusher = () => state.referenceAdder(search.symbol);\r\n\r\n        if (isClassLike(referenceLocation.parent)) {\r\n            Debug.assert(referenceLocation.kind === SyntaxKind.DefaultKeyword || referenceLocation.parent.name === referenceLocation);\r\n            // This is the class declaration containing the constructor.\r\n            findOwnConstructorReferences(search.symbol, sourceFile, pusher());\r\n        }\r\n        else {\r\n            // If this class appears in `extends C`, then the extending class' \"super\" calls are references.\r\n            const classExtending = tryGetClassByExtendingIdentifier(referenceLocation);\r\n            if (classExtending) {\r\n                findSuperConstructorAccesses(classExtending, pusher());\r\n                findInheritedConstructorReferences(classExtending, state);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addClassStaticThisReferences(referenceLocation: Node, search: Search, state: State): void {\r\n        addReference(referenceLocation, search.symbol, state);\r\n        const classLike = referenceLocation.parent;\r\n        if (state.options.use === FindReferencesUse.Rename || !isClassLike(classLike)) return;\r\n        Debug.assert(classLike.name === referenceLocation);\r\n        const addRef = state.referenceAdder(search.symbol);\r\n        for (const member of classLike.members) {\r\n            if (!(isMethodOrAccessor(member) && isStatic(member))) {\r\n                continue;\r\n            }\r\n            if (member.body) {\r\n                member.body.forEachChild(function cb(node) {\r\n                    if (node.kind === SyntaxKind.ThisKeyword) {\r\n                        addRef(node);\r\n                    }\r\n                    else if (!isFunctionLike(node) && !isClassLike(node)) {\r\n                        node.forEachChild(cb);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * `classSymbol` is the class where the constructor was defined.\r\n     * Reference the constructor and all calls to `new this()`.\r\n     */\r\n    function findOwnConstructorReferences(classSymbol: Symbol, sourceFile: SourceFile, addNode: (node: Node) => void): void {\r\n        const constructorSymbol = getClassConstructorSymbol(classSymbol);\r\n        if (constructorSymbol && constructorSymbol.declarations) {\r\n            for (const decl of constructorSymbol.declarations) {\r\n                const ctrKeyword = findChildOfKind(decl, SyntaxKind.ConstructorKeyword, sourceFile)!;\r\n                Debug.assert(decl.kind === SyntaxKind.Constructor && !!ctrKeyword);\r\n                addNode(ctrKeyword);\r\n            }\r\n        }\r\n\r\n        if (classSymbol.exports) {\r\n            classSymbol.exports.forEach(member => {\r\n                const decl = member.valueDeclaration;\r\n                if (decl && decl.kind === SyntaxKind.MethodDeclaration) {\r\n                    const body = (decl as MethodDeclaration).body;\r\n                    if (body) {\r\n                        forEachDescendantOfKind(body, SyntaxKind.ThisKeyword, thisKeyword => {\r\n                            if (isNewExpressionTarget(thisKeyword)) {\r\n                                addNode(thisKeyword);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function getClassConstructorSymbol(classSymbol: Symbol): Symbol | undefined {\r\n        return classSymbol.members && classSymbol.members.get(InternalSymbolName.Constructor);\r\n    }\r\n\r\n    /** Find references to `super` in the constructor of an extending class.  */\r\n    function findSuperConstructorAccesses(classDeclaration: ClassLikeDeclaration, addNode: (node: Node) => void): void {\r\n        const constructor = getClassConstructorSymbol(classDeclaration.symbol);\r\n        if (!(constructor && constructor.declarations)) {\r\n            return;\r\n        }\r\n\r\n        for (const decl of constructor.declarations) {\r\n            Debug.assert(decl.kind === SyntaxKind.Constructor);\r\n            const body = (decl as ConstructorDeclaration).body;\r\n            if (body) {\r\n                forEachDescendantOfKind(body, SyntaxKind.SuperKeyword, node => {\r\n                    if (isCallExpressionTarget(node)) {\r\n                        addNode(node);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function hasOwnConstructor(classDeclaration: ClassLikeDeclaration): boolean {\r\n        return !!getClassConstructorSymbol(classDeclaration.symbol);\r\n    }\r\n\r\n    function findInheritedConstructorReferences(classDeclaration: ClassLikeDeclaration, state: State): void {\r\n        if (hasOwnConstructor(classDeclaration)) return;\r\n        const classSymbol = classDeclaration.symbol;\r\n        const search = state.createSearch(/*location*/ undefined, classSymbol, /*comingFrom*/ undefined);\r\n        getReferencesInContainerOrFiles(classSymbol, state, search);\r\n    }\r\n\r\n    function addImplementationReferences(refNode: Node, addReference: (node: Node) => void, state: State): void {\r\n        // Check if we found a function/propertyAssignment/method with an implementation or initializer\r\n        if (isDeclarationName(refNode) && isImplementation(refNode.parent)) {\r\n            addReference(refNode);\r\n            return;\r\n        }\r\n\r\n        if (refNode.kind !== SyntaxKind.Identifier) {\r\n            return;\r\n        }\r\n\r\n        if (refNode.parent.kind === SyntaxKind.ShorthandPropertyAssignment) {\r\n            // Go ahead and dereference the shorthand assignment by going to its definition\r\n            getReferenceEntriesForShorthandPropertyAssignment(refNode, state.checker, addReference);\r\n        }\r\n\r\n        // Check if the node is within an extends or implements clause\r\n        const containingNode = getContainingNodeIfInHeritageClause(refNode);\r\n        if (containingNode) {\r\n            addReference(containingNode);\r\n            return;\r\n        }\r\n\r\n        // If we got a type reference, try and see if the reference applies to any expressions that can implement an interface\r\n        // Find the first node whose parent isn't a type node -- i.e., the highest type node.\r\n        const typeNode = findAncestor(refNode, a => !isQualifiedName(a.parent) && !isTypeNode(a.parent) && !isTypeElement(a.parent))!;\r\n        const typeHavingNode = typeNode.parent;\r\n        if (hasType(typeHavingNode) && typeHavingNode.type === typeNode && state.markSeenContainingTypeReference(typeHavingNode)) {\r\n            if (hasInitializer(typeHavingNode)) {\r\n                addIfImplementation(typeHavingNode.initializer!);\r\n            }\r\n            else if (isFunctionLike(typeHavingNode) && (typeHavingNode as FunctionLikeDeclaration).body) {\r\n                const body = (typeHavingNode as FunctionLikeDeclaration).body!;\r\n                if (body.kind === SyntaxKind.Block) {\r\n                    forEachReturnStatement(body as Block, returnStatement => {\r\n                        if (returnStatement.expression) addIfImplementation(returnStatement.expression);\r\n                    });\r\n                }\r\n                else {\r\n                    addIfImplementation(body);\r\n                }\r\n            }\r\n            else if (isAssertionExpression(typeHavingNode) || isSatisfiesExpression(typeHavingNode)) {\r\n                addIfImplementation(typeHavingNode.expression);\r\n            }\r\n        }\r\n\r\n        function addIfImplementation(e: Expression): void {\r\n            if (isImplementationExpression(e)) addReference(e);\r\n        }\r\n    }\r\n\r\n    function getContainingNodeIfInHeritageClause(node: Node): ClassLikeDeclaration | InterfaceDeclaration | undefined {\r\n        return isIdentifier(node) || isPropertyAccessExpression(node) ? getContainingNodeIfInHeritageClause(node.parent)\r\n            : isExpressionWithTypeArguments(node) ? tryCast(node.parent.parent, or(isClassLike, isInterfaceDeclaration)) : undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this is an expression that can be considered an implementation\r\n     */\r\n    function isImplementationExpression(node: Expression): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ParenthesizedExpression:\r\n                return isImplementationExpression((node as ParenthesizedExpression).expression);\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines if the parent symbol occurs somewhere in the child's ancestry. If the parent symbol\r\n     * is an interface, determines if some ancestor of the child symbol extends or inherits from it.\r\n     * Also takes in a cache of previous results which makes this slightly more efficient and is\r\n     * necessary to avoid potential loops like so:\r\n     *     class A extends B { }\r\n     *     class B extends A { }\r\n     *\r\n     * We traverse the AST rather than using the type checker because users are typically only interested\r\n     * in explicit implementations of an interface/class when calling \"Go to Implementation\". Sibling\r\n     * implementations of types that share a common ancestor with the type whose implementation we are\r\n     * searching for need to be filtered out of the results. The type checker doesn't let us make the\r\n     * distinction between structurally compatible implementations and explicit implementations, so we\r\n     * must use the AST.\r\n     *\r\n     * @param symbol         A class or interface Symbol\r\n     * @param parent        Another class or interface Symbol\r\n     * @param cachedResults A map of symbol id pairs (i.e. \"child,parent\") to booleans indicating previous results\r\n     */\r\n    function explicitlyInheritsFrom(symbol: Symbol, parent: Symbol, cachedResults: Map<string, boolean>, checker: TypeChecker): boolean {\r\n        if (symbol === parent) {\r\n            return true;\r\n        }\r\n\r\n        const key = getSymbolId(symbol) + \",\" + getSymbolId(parent);\r\n        const cached = cachedResults.get(key);\r\n        if (cached !== undefined) {\r\n            return cached;\r\n        }\r\n\r\n        // Set the key so that we don't infinitely recurse\r\n        cachedResults.set(key, false);\r\n\r\n        const inherits = !!symbol.declarations && symbol.declarations.some(declaration =>\r\n            getAllSuperTypeNodes(declaration).some(typeReference => {\r\n                const type = checker.getTypeAtLocation(typeReference);\r\n                return !!type && !!type.symbol && explicitlyInheritsFrom(type.symbol, parent, cachedResults, checker);\r\n            })\r\n        );\r\n        cachedResults.set(key, inherits);\r\n        return inherits;\r\n    }\r\n\r\n    function getReferencesForSuperKeyword(superKeyword: Node): SymbolAndEntries[] | undefined {\r\n        let searchSpaceNode: SuperContainer | ClassLikeDeclaration | TypeLiteralNode | InterfaceDeclaration | ObjectLiteralExpression | undefined = getSuperContainer(superKeyword, /*stopOnFunctions*/ false);\r\n        if (!searchSpaceNode) {\r\n            return undefined;\r\n        }\r\n        // Whether 'super' occurs in a static context within a class.\r\n        let staticFlag = ModifierFlags.Static;\r\n\r\n        switch (searchSpaceNode.kind) {\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n                staticFlag &= getSyntacticModifierFlags(searchSpaceNode);\r\n                searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class\r\n                break;\r\n            default:\r\n                return undefined;\r\n        }\r\n\r\n        const sourceFile = searchSpaceNode.getSourceFile();\r\n        const references = mapDefined(getPossibleSymbolReferenceNodes(sourceFile, \"super\", searchSpaceNode), node => {\r\n            if (node.kind !== SyntaxKind.SuperKeyword) {\r\n                return;\r\n            }\r\n\r\n            const container = getSuperContainer(node, /*stopOnFunctions*/ false);\r\n\r\n            // If we have a 'super' container, we must have an enclosing class.\r\n            // Now make sure the owning class is the same as the search-space\r\n            // and has the same static qualifier as the original 'super's owner.\r\n            return container && isStatic(container) === !!staticFlag && container.parent.symbol === searchSpaceNode.symbol ? nodeEntry(node) : undefined;\r\n        });\r\n\r\n        return [{ definition: { type: DefinitionKind.Symbol, symbol: searchSpaceNode.symbol }, references }];\r\n    }\r\n\r\n    function isParameterName(node: Node) {\r\n        return node.kind === SyntaxKind.Identifier && node.parent.kind === SyntaxKind.Parameter && (node.parent as ParameterDeclaration).name === node;\r\n    }\r\n\r\n    function getReferencesForThisKeyword(thisOrSuperKeyword: Node, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken): SymbolAndEntries[] | undefined {\r\n        let searchSpaceNode: Node = getThisContainer(thisOrSuperKeyword, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);\r\n\r\n        // Whether 'this' occurs in a static context within a class.\r\n        let staticFlag = ModifierFlags.Static;\r\n\r\n        switch (searchSpaceNode.kind) {\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n                if (isObjectLiteralMethod(searchSpaceNode)) {\r\n                    staticFlag &= getSyntacticModifierFlags(searchSpaceNode);\r\n                    searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning object literals\r\n                    break;\r\n                }\r\n                // falls through\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n                staticFlag &= getSyntacticModifierFlags(searchSpaceNode);\r\n                searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class\r\n                break;\r\n            case SyntaxKind.SourceFile:\r\n                if (isExternalModule(searchSpaceNode as SourceFile) || isParameterName(thisOrSuperKeyword)) {\r\n                    return undefined;\r\n                }\r\n                // falls through\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n                break;\r\n            // Computed properties in classes are not handled here because references to this are illegal,\r\n            // so there is no point finding references to them.\r\n            default:\r\n                return undefined;\r\n        }\r\n\r\n        const references = flatMap(searchSpaceNode.kind === SyntaxKind.SourceFile ? sourceFiles : [searchSpaceNode.getSourceFile()], sourceFile => {\r\n            cancellationToken.throwIfCancellationRequested();\r\n            return getPossibleSymbolReferenceNodes(sourceFile, \"this\", isSourceFile(searchSpaceNode) ? sourceFile : searchSpaceNode).filter(node => {\r\n                if (!isThis(node)) {\r\n                    return false;\r\n                }\r\n                const container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);\r\n                if (!canHaveSymbol(container)) return false;\r\n                switch (searchSpaceNode.kind) {\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                        return (searchSpaceNode as FunctionExpression | FunctionDeclaration).symbol === container.symbol;\r\n                    case SyntaxKind.MethodDeclaration:\r\n                    case SyntaxKind.MethodSignature:\r\n                        return isObjectLiteralMethod(searchSpaceNode) && searchSpaceNode.symbol === container.symbol;\r\n                    case SyntaxKind.ClassExpression:\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.ObjectLiteralExpression:\r\n                        // Make sure the container belongs to the same class/object literals\r\n                        // and has the appropriate static modifier from the original container.\r\n                        return container.parent && canHaveSymbol(container.parent) && (searchSpaceNode as ClassLikeDeclaration | ObjectLiteralExpression).symbol === container.parent.symbol && isStatic(container) === !!staticFlag;\r\n                    case SyntaxKind.SourceFile:\r\n                        return container.kind === SyntaxKind.SourceFile && !isExternalModule(container) && !isParameterName(node);\r\n                }\r\n            });\r\n        }).map(n => nodeEntry(n));\r\n\r\n        const thisParameter = firstDefined(references, r => isParameter(r.node.parent) ? r.node : undefined);\r\n        return [{\r\n            definition: { type: DefinitionKind.This, node: thisParameter || thisOrSuperKeyword },\r\n            references,\r\n        }];\r\n    }\r\n\r\n    function getReferencesForStringLiteral(node: StringLiteralLike, sourceFiles: readonly SourceFile[], checker: TypeChecker, cancellationToken: CancellationToken): SymbolAndEntries[] {\r\n        const type = getContextualTypeFromParentOrAncestorTypeNode(node, checker);\r\n        const references = flatMap(sourceFiles, sourceFile => {\r\n            cancellationToken.throwIfCancellationRequested();\r\n            return mapDefined(getPossibleSymbolReferenceNodes(sourceFile, node.text), ref => {\r\n                if (isStringLiteralLike(ref) && ref.text === node.text) {\r\n                    if (type) {\r\n                        const refType = getContextualTypeFromParentOrAncestorTypeNode(ref, checker);\r\n                        if (type !== checker.getStringType() && (type === refType || isStringLiteralPropertyReference(ref, checker))) {\r\n                            return nodeEntry(ref, EntryKind.StringLiteral);\r\n                        }\r\n                    }\r\n                    else {\r\n                        return isNoSubstitutionTemplateLiteral(ref) && !rangeIsOnSingleLine(ref, sourceFile) ? undefined :\r\n                            nodeEntry(ref, EntryKind.StringLiteral);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        return [{\r\n            definition: { type: DefinitionKind.String, node },\r\n            references,\r\n        }];\r\n    }\r\n\r\n    function isStringLiteralPropertyReference(node: StringLiteralLike, checker: TypeChecker) {\r\n        if (isPropertySignature(node.parent)) {\r\n            return checker.getPropertyOfType(checker.getTypeAtLocation(node.parent.parent), node.text);\r\n        }\r\n    }\r\n\r\n    // For certain symbol kinds, we need to include other symbols in the search set.\r\n    // This is not needed when searching for re-exports.\r\n    function populateSearchSymbolSet(symbol: Symbol, location: Node, checker: TypeChecker, isForRename: boolean, providePrefixAndSuffixText: boolean, implementations: boolean): Symbol[] {\r\n        const result: Symbol[] = [];\r\n        forEachRelatedSymbol<void>(\r\n            symbol,\r\n            location,\r\n            checker,\r\n            isForRename,\r\n            !(isForRename && providePrefixAndSuffixText),\r\n            (sym, root, base) => {\r\n                // static method/property and instance method/property might have the same name. Only include static or only include instance.\r\n                if (base) {\r\n                    if (isStaticSymbol(symbol) !== isStaticSymbol(base)) {\r\n                        base = undefined;\r\n                    }\r\n                }\r\n                result.push(base || root || sym);\r\n            }, // when try to find implementation, implementations is true, and not allowed to find base class\r\n            /*allowBaseTypes*/ () => !implementations,\r\n        );\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param allowBaseTypes return true means it would try to find in base class or interface.\r\n     */\r\n    function forEachRelatedSymbol<T>(\r\n        symbol: Symbol,\r\n        location: Node,\r\n        checker: TypeChecker,\r\n        isForRenamePopulateSearchSymbolSet: boolean,\r\n        onlyIncludeBindingElementAtReferenceLocation: boolean,\r\n        /**\r\n         * @param baseSymbol This symbol means one property/mehtod from base class or interface when it is not null or undefined,\r\n         */\r\n        cbSymbol: (symbol: Symbol, rootSymbol?: Symbol, baseSymbol?: Symbol, kind?: NodeEntryKind) => T | undefined,\r\n        allowBaseTypes: (rootSymbol: Symbol) => boolean,\r\n    ): T | undefined {\r\n        const containingObjectLiteralElement = getContainingObjectLiteralElement(location);\r\n        if (containingObjectLiteralElement) {\r\n            /* Because in short-hand property assignment, location has two meaning : property name and as value of the property\r\n            * When we do findAllReference at the position of the short-hand property assignment, we would want to have references to position of\r\n            * property name and variable declaration of the identifier.\r\n            * Like in below example, when querying for all references for an identifier 'name', of the property assignment, the language service\r\n            * should show both 'name' in 'obj' and 'name' in variable declaration\r\n            *      const name = \"Foo\";\r\n            *      const obj = { name };\r\n            * In order to do that, we will populate the search set with the value symbol of the identifier as a value of the property assignment\r\n            * so that when matching with potential reference symbol, both symbols from property declaration and variable declaration\r\n            * will be included correctly.\r\n            */\r\n            const shorthandValueSymbol = checker.getShorthandAssignmentValueSymbol(location.parent); // gets the local symbol\r\n            if (shorthandValueSymbol && isForRenamePopulateSearchSymbolSet) {\r\n                // When renaming 'x' in `const o = { x }`, just rename the local variable, not the property.\r\n                return cbSymbol(shorthandValueSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, EntryKind.SearchedLocalFoundProperty);\r\n            }\r\n\r\n            // If the location is in a context sensitive location (i.e. in an object literal) try\r\n            // to get a contextual type for it, and add the property symbol from the contextual\r\n            // type to the search set\r\n            const contextualType = checker.getContextualType(containingObjectLiteralElement.parent);\r\n            const res = contextualType && firstDefined(\r\n                getPropertySymbolsFromContextualType(containingObjectLiteralElement, checker, contextualType, /*unionSymbolOk*/ true),\r\n                sym => fromRoot(sym, EntryKind.SearchedPropertyFoundLocal),\r\n            );\r\n            if (res) return res;\r\n\r\n            // If the location is name of property symbol from object literal destructuring pattern\r\n            // Search the property symbol\r\n            //      for ( { property: p2 } of elems) { }\r\n            const propertySymbol = getPropertySymbolOfDestructuringAssignment(location, checker);\r\n            const res1 = propertySymbol && cbSymbol(propertySymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, EntryKind.SearchedPropertyFoundLocal);\r\n            if (res1) return res1;\r\n\r\n            const res2 = shorthandValueSymbol && cbSymbol(shorthandValueSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, EntryKind.SearchedLocalFoundProperty);\r\n            if (res2) return res2;\r\n        }\r\n\r\n        const aliasedSymbol = getMergedAliasedSymbolOfNamespaceExportDeclaration(location, symbol, checker);\r\n        if (aliasedSymbol) {\r\n            // In case of UMD module and global merging, search for global as well\r\n            const res = cbSymbol(aliasedSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, EntryKind.Node);\r\n            if (res) return res;\r\n        }\r\n\r\n        const res = fromRoot(symbol);\r\n        if (res) return res;\r\n\r\n        if (symbol.valueDeclaration && isParameterPropertyDeclaration(symbol.valueDeclaration, symbol.valueDeclaration.parent)) {\r\n            // For a parameter property, now try on the other symbol (property if this was a parameter, parameter if this was a property).\r\n            const paramProps = checker.getSymbolsOfParameterPropertyDeclaration(cast(symbol.valueDeclaration, isParameter), symbol.name);\r\n            Debug.assert(paramProps.length === 2 && !!(paramProps[0].flags & SymbolFlags.FunctionScopedVariable) && !!(paramProps[1].flags & SymbolFlags.Property)); // is [parameter, property]\r\n            return fromRoot(symbol.flags & SymbolFlags.FunctionScopedVariable ? paramProps[1] : paramProps[0]);\r\n        }\r\n\r\n        const exportSpecifier = getDeclarationOfKind<ExportSpecifier>(symbol, SyntaxKind.ExportSpecifier);\r\n        if (!isForRenamePopulateSearchSymbolSet || exportSpecifier && !exportSpecifier.propertyName) {\r\n            const localSymbol = exportSpecifier && checker.getExportSpecifierLocalTargetSymbol(exportSpecifier);\r\n            if (localSymbol) {\r\n                const res = cbSymbol(localSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, EntryKind.Node);\r\n                if (res) return res;\r\n            }\r\n        }\r\n\r\n        // symbolAtLocation for a binding element is the local symbol. See if the search symbol is the property.\r\n        // Don't do this when populating search set for a rename when prefix and suffix text will be provided -- just rename the local.\r\n        if (!isForRenamePopulateSearchSymbolSet) {\r\n            let bindingElementPropertySymbol: Symbol | undefined;\r\n            if (onlyIncludeBindingElementAtReferenceLocation) {\r\n                bindingElementPropertySymbol = isObjectBindingElementWithoutPropertyName(location.parent) ? getPropertySymbolFromBindingElement(checker, location.parent) : undefined;\r\n            }\r\n            else {\r\n                bindingElementPropertySymbol = getPropertySymbolOfObjectBindingPatternWithoutPropertyName(symbol, checker);\r\n            }\r\n            return bindingElementPropertySymbol && fromRoot(bindingElementPropertySymbol, EntryKind.SearchedPropertyFoundLocal);\r\n        }\r\n\r\n        Debug.assert(isForRenamePopulateSearchSymbolSet);\r\n        // due to the above assert and the arguments at the uses of this function,\r\n        // (onlyIncludeBindingElementAtReferenceLocation <=> !providePrefixAndSuffixTextForRename) holds\r\n        const includeOriginalSymbolOfBindingElement = onlyIncludeBindingElementAtReferenceLocation;\r\n\r\n        if (includeOriginalSymbolOfBindingElement) {\r\n            const bindingElementPropertySymbol = getPropertySymbolOfObjectBindingPatternWithoutPropertyName(symbol, checker);\r\n            return bindingElementPropertySymbol && fromRoot(bindingElementPropertySymbol, EntryKind.SearchedPropertyFoundLocal);\r\n        }\r\n\r\n        function fromRoot(sym: Symbol, kind?: NodeEntryKind): T | undefined {\r\n            // If this is a union property:\r\n            //   - In populateSearchSymbolsSet we will add all the symbols from all its source symbols in all unioned types.\r\n            //   - In findRelatedSymbol, we will just use the union symbol if any source symbol is included in the search.\r\n            // If the symbol is an instantiation from a another symbol (e.g. widened symbol):\r\n            //   - In populateSearchSymbolsSet, add the root the list\r\n            //   - In findRelatedSymbol, return the source symbol if that is in the search. (Do not return the instantiation symbol.)\r\n            return firstDefined(checker.getRootSymbols(sym), rootSymbol =>\r\n                cbSymbol(sym, rootSymbol, /*baseSymbol*/ undefined, kind)\r\n                // Add symbol of properties/methods of the same name in base classes and implemented interfaces definitions\r\n                || (rootSymbol.parent && rootSymbol.parent.flags & (SymbolFlags.Class | SymbolFlags.Interface) && allowBaseTypes(rootSymbol)\r\n                    ? getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.name, checker, base => cbSymbol(sym, rootSymbol, base, kind))\r\n                    : undefined));\r\n        }\r\n\r\n        function getPropertySymbolOfObjectBindingPatternWithoutPropertyName(symbol: Symbol, checker: TypeChecker): Symbol | undefined {\r\n            const bindingElement = getDeclarationOfKind<BindingElement>(symbol, SyntaxKind.BindingElement);\r\n            if (bindingElement && isObjectBindingElementWithoutPropertyName(bindingElement)) {\r\n                return getPropertySymbolFromBindingElement(checker, bindingElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find symbol of the given property-name and add the symbol to the given result array\r\n     * @param symbol a symbol to start searching for the given propertyName\r\n     * @param propertyName a name of property to search for\r\n     * @param result an array of symbol of found property symbols\r\n     * @param previousIterationSymbolsCache a cache of symbol from previous iterations of calling this function to prevent infinite revisiting of the same symbol.\r\n     *                                The value of previousIterationSymbol is undefined when the function is first called.\r\n     */\r\n    function getPropertySymbolsFromBaseTypes<T>(symbol: Symbol, propertyName: string, checker: TypeChecker, cb: (symbol: Symbol) => T | undefined): T | undefined {\r\n        const seen = new Set<Symbol>();\r\n        return recur(symbol);\r\n\r\n        function recur(symbol: Symbol): T | undefined {\r\n            // Use `addToSeen` to ensure we don't infinitely recurse in this situation:\r\n            //      interface C extends C {\r\n            //          /*findRef*/propName: string;\r\n            //      }\r\n            if (!(symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) || !addToSeen(seen, symbol)) return;\r\n\r\n            return firstDefined(symbol.declarations, declaration =>\r\n                firstDefined(getAllSuperTypeNodes(declaration), typeReference => {\r\n                    const type = checker.getTypeAtLocation(typeReference);\r\n                    const propertySymbol = type.symbol && checker.getPropertyOfType(type, propertyName);\r\n                    // Visit the typeReference as well to see if it directly or indirectly uses that property\r\n                    // When `propertySymbol` is missing continue the recursion through parents as some parent up the chain might be an abstract class that implements interface having the property\r\n                    return propertySymbol && firstDefined(checker.getRootSymbols(propertySymbol), cb) || type.symbol && recur(type.symbol);\r\n                }));\r\n        }\r\n    }\r\n\r\n    interface RelatedSymbol {\r\n        readonly symbol: Symbol;\r\n        readonly kind: NodeEntryKind | undefined;\r\n    }\r\n\r\n    function isStaticSymbol(symbol: Symbol): boolean {\r\n        if (!symbol.valueDeclaration) return false;\r\n        const modifierFlags = getEffectiveModifierFlags(symbol.valueDeclaration);\r\n        return !!(modifierFlags & ModifierFlags.Static);\r\n    }\r\n\r\n    function getRelatedSymbol(search: Search, referenceSymbol: Symbol, referenceLocation: Node, state: State): RelatedSymbol | undefined {\r\n        const { checker } = state;\r\n        return forEachRelatedSymbol(referenceSymbol, referenceLocation, checker, /*isForRenamePopulateSearchSymbolSet*/ false, /*onlyIncludeBindingElementAtReferenceLocation*/ state.options.use !== FindReferencesUse.Rename || !!state.options.providePrefixAndSuffixTextForRename, (sym, rootSymbol, baseSymbol, kind): RelatedSymbol | undefined => {\r\n            // check whether the symbol used to search itself is just the searched one.\r\n            if (baseSymbol) {\r\n                // static method/property and instance method/property might have the same name. Only check static or only check instance.\r\n                if (isStaticSymbol(referenceSymbol) !== isStaticSymbol(baseSymbol)) {\r\n                    baseSymbol = undefined;\r\n                }\r\n            }\r\n            return search.includes(baseSymbol || rootSymbol || sym)\r\n                // For a base type, use the symbol for the derived type. For a synthetic (e.g. union) property, use the union symbol.\r\n                ? { symbol: rootSymbol && !(getCheckFlags(sym) & CheckFlags.Synthetic) ? rootSymbol : sym, kind }\r\n                : undefined;\r\n        }, /*allowBaseTypes*/ rootSymbol => !(search.parents && !search.parents.some(parent => explicitlyInheritsFrom(rootSymbol.parent!, parent, state.inheritsFromCache, checker))));\r\n    }\r\n\r\n    /**\r\n     * Given an initial searchMeaning, extracted from a location, widen the search scope based on the declarations\r\n     * of the corresponding symbol. e.g. if we are searching for \"Foo\" in value position, but \"Foo\" references a class\r\n     * then we need to widen the search to include type positions as well.\r\n     * On the contrary, if we are searching for \"Bar\" in type position and we trace bar to an interface, and an uninstantiated\r\n     * module, we want to keep the search limited to only types, as the two declarations (interface and uninstantiated module)\r\n     * do not intersect in any of the three spaces.\r\n     */\r\n    export function getIntersectingMeaningFromDeclarations(node: Node, symbol: Symbol): SemanticMeaning {\r\n        let meaning = getMeaningFromLocation(node);\r\n        const { declarations } = symbol;\r\n        if (declarations) {\r\n            let lastIterationMeaning: SemanticMeaning;\r\n            do {\r\n                // The result is order-sensitive, for instance if initialMeaning === Namespace, and declarations = [class, instantiated module]\r\n                // we need to consider both as they initialMeaning intersects with the module in the namespace space, and the module\r\n                // intersects with the class in the value space.\r\n                // To achieve that we will keep iterating until the result stabilizes.\r\n\r\n                // Remember the last meaning\r\n                lastIterationMeaning = meaning;\r\n\r\n                for (const declaration of declarations) {\r\n                    const declarationMeaning = getMeaningFromDeclaration(declaration);\r\n\r\n                    if (declarationMeaning & meaning) {\r\n                        meaning |= declarationMeaning;\r\n                    }\r\n                }\r\n            }\r\n            while (meaning !== lastIterationMeaning);\r\n        }\r\n        return meaning;\r\n    }\r\n\r\n    function isImplementation(node: Node): boolean {\r\n        return !!(node.flags & NodeFlags.Ambient) ? !(isInterfaceDeclaration(node) || isTypeAliasDeclaration(node)) :\r\n            (isVariableLike(node) ? hasInitializer(node) :\r\n                isFunctionLikeDeclaration(node) ? !!node.body :\r\n                isClassLike(node) || isModuleOrEnumDeclaration(node));\r\n    }\r\n\r\n    export function getReferenceEntriesForShorthandPropertyAssignment(node: Node, checker: TypeChecker, addReference: (node: Node) => void): void {\r\n        const refSymbol = checker.getSymbolAtLocation(node)!;\r\n        const shorthandSymbol = checker.getShorthandAssignmentValueSymbol(refSymbol.valueDeclaration);\r\n\r\n        if (shorthandSymbol) {\r\n            for (const declaration of shorthandSymbol.getDeclarations()!) {\r\n                if (getMeaningFromDeclaration(declaration) & SemanticMeaning.Value) {\r\n                    addReference(declaration);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function forEachDescendantOfKind(node: Node, kind: SyntaxKind, action: (node: Node) => void): void {\r\n        forEachChild(node, child => {\r\n            if (child.kind === kind) {\r\n                action(child);\r\n            }\r\n            forEachDescendantOfKind(child, kind, action);\r\n        });\r\n    }\r\n\r\n    /** Get `C` given `N` if `N` is in the position `class C extends N` or `class C extends foo.N` where `N` is an identifier. */\r\n    function tryGetClassByExtendingIdentifier(node: Node): ClassLikeDeclaration | undefined {\r\n        return tryGetClassExtendingExpressionWithTypeArguments(climbPastPropertyAccess(node).parent);\r\n    }\r\n\r\n    /**\r\n     * If we are just looking for implementations and this is a property access expression, we need to get the\r\n     * symbol of the local type of the symbol the property is being accessed on. This is because our search\r\n     * symbol may have a different parent symbol if the local type's symbol does not declare the property\r\n     * being accessed (i.e. it is declared in some parent class or interface)\r\n     */\r\n    function getParentSymbolsOfPropertyAccess(location: Node, symbol: Symbol, checker: TypeChecker): readonly Symbol[] | undefined {\r\n        const propertyAccessExpression = isRightSideOfPropertyAccess(location) ? location.parent as PropertyAccessExpression : undefined;\r\n        const lhsType = propertyAccessExpression && checker.getTypeAtLocation(propertyAccessExpression.expression);\r\n        const res = mapDefined(lhsType && (lhsType.isUnionOrIntersection() ? lhsType.types : lhsType.symbol === symbol.parent ? undefined : [lhsType]), t => t.symbol && t.symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) ? t.symbol : undefined);\r\n        return res.length === 0 ? undefined : res;\r\n    }\r\n\r\n    function isForRenameWithPrefixAndSuffixText(options: Options) {\r\n        return options.use === FindReferencesUse.Rename && options.providePrefixAndSuffixTextForRename;\r\n    }\r\n}\r\n",
  "word_count": 11672,
  "key_terms": [
    "import",
    "class",
    "method",
    "implementation",
    "function",
    "interface",
    "parameter",
    "variable",
    "merge",
    "state",
    "export",
    "object",
    "container"
  ],
  "file_info": {
    "size": 138449,
    "sha": "a2ed0feb795a7dc3eeb3cdcbb0862af16b5517db",
    "download_url": "https://raw.githubusercontent.com/microsoft/TypeScript/main/src/services/findAllReferences.ts"
  }
}