{
  "metadata": {
    "title": "programApi.ts",
    "url": "https://github.com/microsoft/TypeScript/blob/main/src/testRunner/unittests/programApi.ts",
    "repo": "microsoft/TypeScript",
    "file_path": "src/testRunner/unittests/programApi.ts",
    "file_type": "code",
    "technology": "typescript",
    "professional_context": "api_reference",
    "english_level": "B1",
    "content_type": "github_documentation",
    "last_updated": "1761763045.7929263"
  },
  "content": "import * as documents from \"../_namespaces/documents.js\";\r\nimport * as fakes from \"../_namespaces/fakes.js\";\r\nimport * as Harness from \"../_namespaces/Harness.js\";\r\nimport * as ts from \"../_namespaces/ts.js\";\r\nimport * as vfs from \"../_namespaces/vfs.js\";\r\nimport { jsonToReadableText } from \"./helpers.js\";\r\n\r\nfunction verifyMissingFilePaths(missing: ReturnType<ts.Program[\"getMissingFilePaths\"]>, expected: readonly string[]) {\r\n    assert.isDefined(missing);\r\n    const missingPaths = ts.arrayFrom(missing.keys());\r\n    const map = new Set(expected);\r\n    for (const missing of missingPaths) {\r\n        const value = map.has(missing);\r\n        assert.isTrue(value, `${missing} to be ${value === undefined ? \"not present\" : \"present only once\"}, in actual: ${missingPaths} expected: ${expected}`);\r\n        map.delete(missing);\r\n    }\r\n    const notFound = ts.arrayFrom(ts.mapDefinedIterator(map.keys(), k => map.has(k) ? k : undefined));\r\n    assert.equal(notFound.length, 0, `Not found ${notFound} in actual: ${missingPaths} expected: ${expected}`);\r\n}\r\n\r\ndescribe(\"unittests:: programApi:: Program.getMissingFilePaths\", () => {\r\n    const options: ts.CompilerOptions = {\r\n        noLib: true,\r\n    };\r\n\r\n    const emptyFileName = \"empty.ts\";\r\n    const emptyFileRelativePath = \"./\" + emptyFileName;\r\n\r\n    const emptyFile = new documents.TextDocument(emptyFileName, \"\");\r\n\r\n    const referenceFileName = \"reference.ts\";\r\n    const referenceFileRelativePath = \"./\" + referenceFileName;\r\n\r\n    const referenceFile = new documents.TextDocument(\r\n        referenceFileName,\r\n        '/// <reference path=\"d:/imaginary/nonexistent1.ts\"/>\\n' + // Absolute\r\n            '/// <reference path=\"./nonexistent2.ts\"/>\\n' + // Relative\r\n            '/// <reference path=\"nonexistent3.ts\"/>\\n' + // Unqualified\r\n            '/// <reference path=\"nonexistent4\"/>\\n', // No extension\r\n    );\r\n\r\n    const testCompilerHost = new fakes.CompilerHost(\r\n        vfs.createFromFileSystem(\r\n            Harness.IO,\r\n            /*ignoreCase*/ true,\r\n            { documents: [emptyFile, referenceFile], cwd: \"d:\\\\pretend\\\\\" },\r\n        ),\r\n        { newLine: ts.NewLineKind.LineFeed },\r\n    );\r\n\r\n    it(\"handles no missing root files\", () => {\r\n        const program = ts.createProgram([emptyFileRelativePath], options, testCompilerHost);\r\n        const missing = program.getMissingFilePaths();\r\n        verifyMissingFilePaths(missing, []);\r\n    });\r\n\r\n    it(\"handles missing root file\", () => {\r\n        const program = ts.createProgram([\"./nonexistent.ts\"], options, testCompilerHost);\r\n        const missing = program.getMissingFilePaths();\r\n        verifyMissingFilePaths(missing, [\"d:/pretend/nonexistent.ts\"]); // Absolute path\r\n    });\r\n\r\n    it(\"handles multiple missing root files\", () => {\r\n        const program = ts.createProgram([\"./nonexistent0.ts\", \"./nonexistent1.ts\"], options, testCompilerHost);\r\n        const missing = program.getMissingFilePaths();\r\n        verifyMissingFilePaths(missing, [\"d:/pretend/nonexistent0.ts\", \"d:/pretend/nonexistent1.ts\"]);\r\n    });\r\n\r\n    it(\"handles a mix of present and missing root files\", () => {\r\n        const program = ts.createProgram([\"./nonexistent0.ts\", emptyFileRelativePath, \"./nonexistent1.ts\"], options, testCompilerHost);\r\n        const missing = program.getMissingFilePaths();\r\n        verifyMissingFilePaths(missing, [\"d:/pretend/nonexistent0.ts\", \"d:/pretend/nonexistent1.ts\"]);\r\n    });\r\n\r\n    it(\"handles repeatedly specified root files\", () => {\r\n        const program = ts.createProgram([\"./nonexistent.ts\", \"./nonexistent.ts\"], options, testCompilerHost);\r\n        const missing = program.getMissingFilePaths();\r\n        verifyMissingFilePaths(missing, [\"d:/pretend/nonexistent.ts\"]);\r\n    });\r\n\r\n    it(\"normalizes file paths\", () => {\r\n        const program0 = ts.createProgram([\"./nonexistent.ts\", \"./NONEXISTENT.ts\"], options, testCompilerHost);\r\n        const program1 = ts.createProgram([\"./NONEXISTENT.ts\", \"./nonexistent.ts\"], options, testCompilerHost);\r\n        const missing0 = ts.arrayFrom(program0.getMissingFilePaths().keys());\r\n        const missing1 = ts.arrayFrom(program1.getMissingFilePaths().keys());\r\n        assert.equal(missing0.length, 1);\r\n        assert.deepEqual(missing0, missing1);\r\n    });\r\n\r\n    it(\"handles missing triple slash references\", () => {\r\n        const program = ts.createProgram([referenceFileRelativePath], options, testCompilerHost);\r\n        const missing = program.getMissingFilePaths();\r\n        verifyMissingFilePaths(missing, [\r\n            // From absolute reference\r\n            \"d:/imaginary/nonexistent1.ts\",\r\n\r\n            // From relative reference\r\n            \"d:/pretend/nonexistent2.ts\",\r\n\r\n            // From unqualified reference\r\n            \"d:/pretend/nonexistent3.ts\",\r\n\r\n            // From no-extension reference\r\n            \"d:/pretend/nonexistent4.d.ts\",\r\n            \"d:/pretend/nonexistent4.ts\",\r\n            \"d:/pretend/nonexistent4.tsx\",\r\n        ]);\r\n    });\r\n\r\n    it(\"should not have missing file paths\", () => {\r\n        const testSource = `\r\n            class Foo extends HTMLElement {\r\n                bar: string = 'baz';\r\n            }`;\r\n\r\n        const host: ts.CompilerHost = {\r\n            getSourceFile: (fileName: string, languageVersion: ts.ScriptTarget, _onError?: (message: string) => void) => {\r\n                return fileName === \"test.ts\" ? ts.createSourceFile(fileName, testSource, languageVersion) : undefined;\r\n            },\r\n            getDefaultLibFileName: () => \"\",\r\n            writeFile: (_fileName, _content) => {\r\n                throw new Error(\"unsupported\");\r\n            },\r\n            getCurrentDirectory: () => ts.sys.getCurrentDirectory(),\r\n            getCanonicalFileName: fileName => ts.sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase(),\r\n            getNewLine: () => ts.sys.newLine,\r\n            useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\r\n            fileExists: fileName => fileName === \"test.ts\",\r\n            readFile: fileName => fileName === \"test.ts\" ? testSource : undefined,\r\n            resolveModuleNames: (_moduleNames: string[], _containingFile: string) => {\r\n                throw new Error(\"unsupported\");\r\n            },\r\n            getDirectories: _path => {\r\n                throw new Error(\"unsupported\");\r\n            },\r\n        };\r\n\r\n        const program = ts.createProgram([\"test.ts\"], { module: ts.ModuleKind.ES2015 }, host);\r\n        assert(program.getSourceFiles().length === 1, \"expected 'getSourceFiles' length to be 1\");\r\n        assert(program.getMissingFilePaths().size === 0, \"expected 'getMissingFilePaths' length to be 0\");\r\n        assert((program.getFileProcessingDiagnostics()?.length || 0) === 0, \"expected 'getFileProcessingDiagnostics' length to be 0\");\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: Program.isSourceFileFromExternalLibrary\", () => {\r\n    it(\"works on redirect files\", () => {\r\n        // In this example '/node_modules/foo/index.d.ts' will redirect to '/node_modules/bar/node_modules/foo/index.d.ts'.\r\n        const a = new documents.TextDocument(\"/a.ts\", 'import * as bar from \"bar\"; import * as foo from \"foo\";');\r\n        const bar = new documents.TextDocument(\"/node_modules/bar/index.d.ts\", 'import * as foo from \"foo\";');\r\n        const fooPackageJsonText = jsonToReadableText({ name: \"foo\", version: \"1.2.3\" });\r\n        const fooIndexText = \"export const x: number;\";\r\n        const barFooPackage = new documents.TextDocument(\"/node_modules/bar/node_modules/foo/package.json\", fooPackageJsonText);\r\n        const barFooIndex = new documents.TextDocument(\"/node_modules/bar/node_modules/foo/index.d.ts\", fooIndexText);\r\n        const fooPackage = new documents.TextDocument(\"/node_modules/foo/package.json\", fooPackageJsonText);\r\n        const fooIndex = new documents.TextDocument(\"/node_modules/foo/index.d.ts\", fooIndexText);\r\n\r\n        const fs = vfs.createFromFileSystem(Harness.IO, /*ignoreCase*/ false, { documents: [a, bar, barFooPackage, barFooIndex, fooPackage, fooIndex], cwd: \"/\" });\r\n        const program = ts.createProgram([\"/a.ts\"], ts.emptyOptions, new fakes.CompilerHost(fs, { newLine: ts.NewLineKind.LineFeed }));\r\n        assertIsExternal(program, [a, bar, barFooIndex, fooIndex], f => f !== a);\r\n    });\r\n\r\n    it('works on `/// <reference types=\"\" />`', () => {\r\n        const a = new documents.TextDocument(\"/a.ts\", '/// <reference types=\"foo\" />');\r\n        const fooIndex = new documents.TextDocument(\"/node_modules/foo/index.d.ts\", \"declare const foo: number;\");\r\n        const fs = vfs.createFromFileSystem(Harness.IO, /*ignoreCase*/ false, { documents: [a, fooIndex], cwd: \"/\" });\r\n        const program = ts.createProgram([\"/a.ts\"], ts.emptyOptions, new fakes.CompilerHost(fs, { newLine: ts.NewLineKind.LineFeed }));\r\n        assertIsExternal(program, [a, fooIndex], f => f !== a);\r\n    });\r\n\r\n    function assertIsExternal(program: ts.Program, files: readonly documents.TextDocument[], isExternalExpected: (file: documents.TextDocument) => boolean): void {\r\n        for (const file of files) {\r\n            const actual = program.isSourceFileFromExternalLibrary(program.getSourceFile(file.file)!);\r\n            const expected = isExternalExpected(file);\r\n            assert.equal(actual, expected, `Expected ${file.file} isSourceFileFromExternalLibrary to be ${expected}, got ${actual}`);\r\n        }\r\n    }\r\n});\r\n\r\ndescribe(\"unittests:: Program.getNodeCount / Program.getIdentifierCount\", () => {\r\n    it(\"works on projects that have .json files\", () => {\r\n        const main = new documents.TextDocument(\"/main.ts\", 'export { version } from \"./package.json\";');\r\n        const pkg = new documents.TextDocument(\"/package.json\", jsonToReadableText({ version: \"1.0.0\" }));\r\n\r\n        const fs = vfs.createFromFileSystem(Harness.IO, /*ignoreCase*/ false, { documents: [main, pkg], cwd: \"/\" });\r\n        const program = ts.createProgram([\"/main.ts\"], { resolveJsonModule: true }, new fakes.CompilerHost(fs, { newLine: ts.NewLineKind.LineFeed }));\r\n\r\n        const json = program.getSourceFile(\"/package.json\")!;\r\n        assert.equal(json.scriptKind, ts.ScriptKind.JSON);\r\n        assert.isNumber(json.nodeCount);\r\n        assert.isNumber(json.identifierCount);\r\n\r\n        assert.isNotNaN(program.getNodeCount());\r\n        assert.isNotNaN(program.getIdentifierCount());\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: programApi:: Program.getTypeChecker / Program.getSemanticDiagnostics\", () => {\r\n    it(\"does not produce errors on `as const` it would not normally produce on the command line\", () => {\r\n        const main = new documents.TextDocument(\"/main.ts\", \"0 as const\");\r\n\r\n        const fs = vfs.createFromFileSystem(Harness.IO, /*ignoreCase*/ false, { documents: [main], cwd: \"/\" });\r\n        const program = ts.createProgram([\"/main.ts\"], {}, new fakes.CompilerHost(fs, { newLine: ts.NewLineKind.LineFeed }));\r\n        const typeChecker = program.getTypeChecker();\r\n        const sourceFile = program.getSourceFile(\"main.ts\")!;\r\n        typeChecker.getTypeAtLocation(((sourceFile.statements[0] as ts.ExpressionStatement).expression as ts.AsExpression).type);\r\n        const diag = program.getSemanticDiagnostics();\r\n        assert.isEmpty(diag);\r\n    });\r\n    it(\"getSymbolAtLocation does not cause additional error to be added on module resolution failure\", () => {\r\n        const main = new documents.TextDocument(\"/main.ts\", 'import \"./module\";');\r\n        const mod = new documents.TextDocument(\"/module.d.ts\", \"declare const foo: any;\");\r\n\r\n        const fs = vfs.createFromFileSystem(Harness.IO, /*ignoreCase*/ false, { documents: [main, mod], cwd: \"/\" });\r\n        const program = ts.createProgram([\"/main.ts\"], {}, new fakes.CompilerHost(fs, { newLine: ts.NewLineKind.LineFeed }));\r\n\r\n        const sourceFile = program.getSourceFile(\"main.ts\")!;\r\n        const typeChecker = program.getTypeChecker();\r\n        typeChecker.getSymbolAtLocation((sourceFile.statements[0] as ts.ImportDeclaration).moduleSpecifier);\r\n        assert.isEmpty(program.getSemanticDiagnostics());\r\n    });\r\n});\r\n\r\ndescribe(\"unittests:: programApi:: CompilerOptions relative paths\", () => {\r\n    it(\"resolves relative paths by getCurrentDirectory\", () => {\r\n        const main = new documents.TextDocument(\"/main.ts\", 'import \"module\";');\r\n        const mod = new documents.TextDocument(\"/lib/module.ts\", \"declare const foo: any;\");\r\n\r\n        const fs = vfs.createFromFileSystem(Harness.IO, /*ignoreCase*/ false, { documents: [main, mod], cwd: \"/\" });\r\n        const program = ts.createProgram([\"./main.ts\"], {\r\n            paths: { \"*\": [\"./lib/*\"] },\r\n        }, new fakes.CompilerHost(fs, { newLine: ts.NewLineKind.LineFeed }));\r\n\r\n        assert.isEmpty(program.getConfigFileParsingDiagnostics());\r\n        assert.isEmpty(program.getGlobalDiagnostics());\r\n        assert.isEmpty(program.getSemanticDiagnostics());\r\n    });\r\n});\r\n",
  "word_count": 1071,
  "key_terms": [
    "import",
    "class",
    "function"
  ],
  "file_info": {
    "size": 12926,
    "sha": "44f391b8690020791eb6dc64472ca0a92d36e773",
    "download_url": "https://raw.githubusercontent.com/microsoft/TypeScript/main/src/testRunner/unittests/programApi.ts"
  }
}