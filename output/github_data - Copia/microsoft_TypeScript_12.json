{
  "metadata": {
    "title": "fixUnreferenceableDecoratorMetadata.ts",
    "url": "https://github.com/microsoft/TypeScript/blob/main/src/services/codefixes/fixUnreferenceableDecoratorMetadata.ts",
    "repo": "microsoft/TypeScript",
    "file_path": "src/services/codefixes/fixUnreferenceableDecoratorMetadata.ts",
    "file_type": "code",
    "technology": "typescript",
    "professional_context": "api_reference",
    "english_level": "B1",
    "content_type": "github_documentation",
    "last_updated": "1761763040.5207577"
  },
  "content": "import {\r\n    createCodeFixActionWithoutFixAll,\r\n    registerCodeFix,\r\n} from \"../_namespaces/ts.codefix.js\";\r\nimport {\r\n    append,\r\n    CodeFixAction,\r\n    Diagnostics,\r\n    emptyArray,\r\n    find,\r\n    forEachImportClauseDeclaration,\r\n    getTokenAtPosition,\r\n    ImportClause,\r\n    ImportEqualsDeclaration,\r\n    ImportSpecifier,\r\n    isIdentifier,\r\n    isImportClause,\r\n    isImportEqualsDeclaration,\r\n    isImportSpecifier,\r\n    Node,\r\n    or,\r\n    Program,\r\n    refactor,\r\n    skipAlias,\r\n    SourceFile,\r\n    SymbolFlags,\r\n    SyntaxKind,\r\n    textChanges,\r\n    tryCast,\r\n} from \"../_namespaces/ts.js\";\r\n\r\nconst fixId = \"fixUnreferenceableDecoratorMetadata\";\r\nconst errorCodes = [Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled.code];\r\nregisterCodeFix({\r\n    errorCodes,\r\n    getCodeActions: context => {\r\n        const importDeclaration = getImportDeclaration(context.sourceFile, context.program, context.span.start);\r\n        if (!importDeclaration) return;\r\n\r\n        const namespaceChanges = textChanges.ChangeTracker.with(context, t => importDeclaration.kind === SyntaxKind.ImportSpecifier && doNamespaceImportChange(t, context.sourceFile, importDeclaration, context.program));\r\n        const typeOnlyChanges = textChanges.ChangeTracker.with(context, t => doTypeOnlyImportChange(t, context.sourceFile, importDeclaration, context.program));\r\n        let actions: CodeFixAction[] | undefined;\r\n        if (namespaceChanges.length) {\r\n            actions = append(actions, createCodeFixActionWithoutFixAll(fixId, namespaceChanges, Diagnostics.Convert_named_imports_to_namespace_import));\r\n        }\r\n        if (typeOnlyChanges.length) {\r\n            actions = append(actions, createCodeFixActionWithoutFixAll(fixId, typeOnlyChanges, Diagnostics.Use_import_type));\r\n        }\r\n        return actions;\r\n    },\r\n    fixIds: [fixId],\r\n});\r\n\r\nfunction getImportDeclaration(sourceFile: SourceFile, program: Program, start: number): ImportClause | ImportSpecifier | ImportEqualsDeclaration | undefined {\r\n    const identifier = tryCast(getTokenAtPosition(sourceFile, start), isIdentifier);\r\n    if (!identifier || identifier.parent.kind !== SyntaxKind.TypeReference) return;\r\n\r\n    const checker = program.getTypeChecker();\r\n    const symbol = checker.getSymbolAtLocation(identifier);\r\n    return find(symbol?.declarations || emptyArray, or(isImportClause, isImportSpecifier, isImportEqualsDeclaration) as (n: Node) => n is ImportClause | ImportSpecifier | ImportEqualsDeclaration);\r\n}\r\n\r\n// Converts the import declaration of the offending import to a type-only import,\r\n// only if it can be done without affecting other imported names. If the conversion\r\n// cannot be done cleanly, we could offer to *extract* the offending import to a\r\n// new type-only import declaration, but honestly I doubt anyone will ever use this\r\n// codefix at all, so it's probably not worth the lines of code.\r\nfunction doTypeOnlyImportChange(changes: textChanges.ChangeTracker, sourceFile: SourceFile, importDeclaration: ImportClause | ImportSpecifier | ImportEqualsDeclaration, program: Program) {\r\n    if (importDeclaration.kind === SyntaxKind.ImportEqualsDeclaration) {\r\n        changes.insertModifierBefore(sourceFile, SyntaxKind.TypeKeyword, importDeclaration.name);\r\n        return;\r\n    }\r\n\r\n    const importClause = importDeclaration.kind === SyntaxKind.ImportClause ? importDeclaration : importDeclaration.parent.parent;\r\n    if (importClause.name && importClause.namedBindings) {\r\n        // Cannot convert an import with a default import and named bindings to type-only\r\n        // (it's a grammar error).\r\n        return;\r\n    }\r\n\r\n    const checker = program.getTypeChecker();\r\n    const importsValue = !!forEachImportClauseDeclaration(importClause, decl => {\r\n        if (skipAlias(decl.symbol, checker).flags & SymbolFlags.Value) return true;\r\n    });\r\n\r\n    if (importsValue) {\r\n        // Assume that if someone wrote a non-type-only import that includes some values,\r\n        // they intend to use those values in value positions, even if they haven't yet.\r\n        // Don't convert it to type-only.\r\n        return;\r\n    }\r\n\r\n    changes.insertModifierBefore(sourceFile, SyntaxKind.TypeKeyword, importClause);\r\n}\r\n\r\nfunction doNamespaceImportChange(changes: textChanges.ChangeTracker, sourceFile: SourceFile, importDeclaration: ImportSpecifier, program: Program) {\r\n    refactor.doChangeNamedToNamespaceOrDefault(sourceFile, program, changes, importDeclaration.parent);\r\n}\r\n",
  "word_count": 376,
  "key_terms": [
    "import",
    "function"
  ],
  "file_info": {
    "size": 4597,
    "sha": "61c2a20949a4efe8cf8bdeb5483a725b8778d29a",
    "download_url": "https://raw.githubusercontent.com/microsoft/TypeScript/main/src/services/codefixes/fixUnreferenceableDecoratorMetadata.ts"
  }
}